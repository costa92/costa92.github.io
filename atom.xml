<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>翼舞成梦</title>
  
  <subtitle>翼舞成梦</subtitle>
  <link href="https://costalong.com/atom.xml" rel="self"/>
  
  <link href="https://costalong.com/"/>
  <updated>2023-09-13T13:06:11.545Z</updated>
  <id>https://costalong.com/</id>
  
  <author>
    <name>costalong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ubuntu 安装 nfs</title>
    <link href="https://costalong.com/2023/09/13/linux/ubuntu-install-nfs-server/"/>
    <id>https://costalong.com/2023/09/13/linux/ubuntu-install-nfs-server/</id>
    <published>2023-09-13T10:49:02.000Z</published>
    <updated>2023-09-13T13:06:11.545Z</updated>
    
    <content type="html"><![CDATA[<ol><li>安装nfs服务</li></ol><pre class=" language-sh"><code class="language-sh">sudo apt install nfs-kernel-server</code></pre><ol start="2"><li>编辑配置文件</li></ol><pre class=" language-sh"><code class="language-sh">sudo vim /etc/exports# Example for NFSv4:# /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)# /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)#/data/nfs-share *(rw,sync,no_subtree_check,no_root_squash) </code></pre><ol start="3"><li>创建共享目录</li></ol><pre class=" language-sh"><code class="language-sh">sudo mkdir -p /data/nfs-share</code></pre><ol start="4"><li>重启nfs服务</li></ol><pre class=" language-sh"><code class="language-sh">sudo service nfs-kernel-server restart</code></pre><ol start="5"><li><p>常用命令工具</p><p>已经安装的nfs无需安装客户端</p></li></ol><pre class=" language-sh"><code class="language-sh"># 显示已经mount到本机上sudo showmount -e localhost# 将配置文件中的目录全部重新 Export一次，无需重启sudo exportfs -rv# 查看nfs的运行状态sudo nfsstat#查看rpc执行信息，可以用于检测rpc运行情况sudo rpcinfo#查看网络端口，NFS默认是使用111端口。sudo netstat -tu -4</code></pre><ol start="6"><li>客户端的命令</li></ol><pre class=" language-sh"><code class="language-sh"># 安装客户端命令sudo apt install nfs-common</code></pre><ol start="7"><li>显示指定的（192.168.2.167）NFS服务器上export出来的目录</li></ol><pre class=" language-sh"><code class="language-sh">sudo showmount -e 192.168.2.167</code></pre><ol start="8"><li>创建本地挂载目录</li></ol><pre class=" language-sh"><code class="language-sh">sudo mkdir -p /mnt/data</code></pre><ol start="9"><li>挂载共享目录</li></ol><pre class=" language-sh"><code class="language-sh">sudo mount -t nfs 192.168.3.167:/data/nfs-share /mnt/data</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;安装nfs服务&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&quot; language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;sudo apt install nfs-kernel-server
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;</summary>
      
    
    
    
    <category term="linux" scheme="https://costalong.com/categories/linux/"/>
    
    
    <category term="nfs" scheme="https://costalong.com/tags/nfs/"/>
    
    <category term="storage" scheme="https://costalong.com/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>nfs实现k8s持久化</title>
    <link href="https://costalong.com/2023/09/13/k8s/k8s-install-nfs/"/>
    <id>https://costalong.com/2023/09/13/k8s/k8s-install-nfs/</id>
    <published>2023-09-13T10:37:51.000Z</published>
    <updated>2023-09-13T13:06:11.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-部署nfs服务端"><a href="#1-部署nfs服务端" class="headerlink" title="1. 部署nfs服务端"></a>1. 部署nfs服务端</h3><p>在任意一台服务器上安装</p><p>（1）安装nfs服务:</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y nfs-utils rpcbindvim /etc/exports/nfsdata *<span class="token punctuation">(</span>rw,no_root_squash,no_all_squash,sync<span class="token punctuation">)</span></code></pre><p>（2）保存配置文件后，执行如下操作：<br>在服务端创建对应的目录和赋予权限：</p><pre class=" language-bash"><code class="language-bash"> <span class="token function">mkdir</span> /nfsdata <span class="token function">chmod</span> 777 /nfsdata</code></pre><p>（3） 启动rpcbind和nfs服务：</p><pre class=" language-bash"><code class="language-bash">systemctl start rpcbind <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> rpcbindsystemctl start nfs <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> nfs</code></pre><p>（4）每个node安装nfs工具</p><pre class=" language-bash"><code class="language-bash"> yum <span class="token function">install</span> -y nfs-utils </code></pre><p>（5） 每个node查询NFS服务器</p><pre class=" language-bash"><code class="language-bash">showmount -e nfs-ipshowmount -e 192.168.11.101</code></pre><h4 id="NFS-PersistentVolume"><a href="#NFS-PersistentVolume" class="headerlink" title="NFS PersistentVolume"></a>NFS PersistentVolume</h4><p>（1）下面创建一个 PV mypv1，配置文件 nfs-pv1.yml 如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mypv1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Recycle  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /data/NFS/k8s/pv1    <span class="token key atrule">server</span><span class="token punctuation">:</span> 192.168.11.101</code></pre><p>① capacity 指定 PV 的容量为 1G。</p><p>② accessModes 指定访问模式为 ReadWriteOnce，支持的访问模式有：</p><p>ReadWriteOnce – PV 能以 read-write 模式 mount 到单个节点。</p><p>ReadOnlyMany – PV 能以 read-only 模式 mount 到多个节点。</p><p>ReadWriteMany – PV 能以 read-write 模式 mount 到多个节点。</p><p>③ persistentVolumeReclaimPolicy 指定当 PV 的回收策略为 Recycle，支持的策略有：</p><p>Retain – 需要管理员手工回收。</p><p>Recycle – 清除 PV 中的数据，效果相当于执行 rm -rf /thevolume/*。</p><p>Delete – 删除 Storage Provider 上的对应存储资源，例如 AWS EBS、GCE PD、Azure Disk、OpenStack Cinder Volume 等。</p><p>④ storageClassName 指定 PV 的 class 为 nfs。相当于为 PV 设置了一个分类，PVC 可以指定 class 申请相应 class 的 PV。</p><p>⑤ 指定 PV 在 NFS 服务器上对应的目录。</p><p>注意要做storage-provider段要提前建好文件夹</p><p>注意要做storage-provider段要提前建好文件夹</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>dev@rediscom k8s<span class="token punctuation">]</span>$ <span class="token function">ls</span>pv1</code></pre><p>（2）创建 mypv1：</p><pre class=" language-bash"><code class="language-bash">kubectl apply -f nfs-pv1.yaml</code></pre><p>（3）查看 mypv1：</p><pre class=" language-bash"><code class="language-bash">kubectl get <span class="token function">pv</span></code></pre><p><img src="/medias/loading.gif" data-original="/images/k8s/nfs/16373020145856.jpg" alt="pv"></p><p>STATUS 为 Available，表示 mypv1 就绪，可以被 PVC 申请。</p><h4 id="创建-PVC"><a href="#创建-PVC" class="headerlink" title="创建 PVC"></a>创建 PVC</h4><p>(1）接下来创建 PVC mypvc1，配置文件 nfs-pvc1.yml 如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mypvc1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">resources</span><span class="token punctuation">:</span>    <span class="token key atrule">requests</span><span class="token punctuation">:</span>      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs</code></pre><p>PVC 就很简单了，只需要指定 PV 的容量，访问模式和 class。</p><p>（2）创建 mypvc1：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl apply -f nfs-pvc1.yml</span>persistentvolumeclaim/mypvc1 created<span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pvc</span>NAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGEmypvc1   Bound    mypv1    1Gi        RWO            nfs            11s</code></pre><p>从 kubectl get pvc 和 kubectl get pv 的输出可以看到 mypvc1 已经 Bound 到 mypv1，申请成功。</p><h3 id="2-Pod使用pvc"><a href="#2-Pod使用pvc" class="headerlink" title="2 Pod使用pvc"></a>2 Pod使用pvc</h3><p>（1）接下来就可以在 Pod 中使用存储了，Pod 配置文件 pod1.yml 如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mypod1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mypod1      <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox      <span class="token key atrule">args</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> /bin/sh      <span class="token punctuation">-</span> <span class="token punctuation">-</span>c      <span class="token punctuation">-</span> sleep 30000      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"mydata"</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> mydata  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mydata      <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>        <span class="token key atrule">claimName</span><span class="token punctuation">:</span> mypvc1</code></pre><p>与使用普通 Volume 的格式类似，在 volumes 中过 persistentVolumeClaim 指定使用 mypvc1 申请的 Volume。</p><p>（2）创建 mypod1：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master pod<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl apply -f pod1.yaml</span>pod/mypod1 created<span class="token punctuation">[</span>root@k8s-master pod<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -o wide</span>NAME                     READY   STATUS              RESTARTS   AGE     IP              NODE        NOMINATED NODE   READINESS GATESmypod1                   0/1     ContainerCreating   0          20s     <span class="token operator">&lt;</span>none<span class="token operator">></span>          k8s-node4   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>nginx-58dcb77688-h8c5x   1/1     Running             0          3d23h   172.31.156.68   k8s-node1   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></code></pre><p>（3）验证 PV 是否可用：</p><pre class=" language-bash"><code class="language-bash">kubectl <span class="token function">exec</span> mypod1 <span class="token function">touch</span> /mydata/hello</code></pre><p>查看生成文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@rediscom ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /data/NFS/k8s/pv1/</span><span class="token punctuation">[</span>root@rediscom pv1<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>hello</code></pre><p>可见，在 Pod 中创建的文件 /mydata/hello 确实已经保存到了 NFS 服务器目录 /nfsdata/pv1 中。</p><p>如果不再需要使用 PV，可用删除 PVC 回收 PV。</p><h3 id="3-回收-PV"><a href="#3-回收-PV" class="headerlink" title="3. 回收 PV"></a>3. 回收 PV</h3><p>通过pvc回收pv<br>（1）当 PV 不再需要时，可通过删除 PVC 回收。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pvc</span>NAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGEmypvc1   Bound    mypv1    1Gi        RWO            nfs            22m<span class="token comment" spellcheck="true"># 删除pvc</span><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl delete pvc mypvc1</span>persistentvolumeclaim <span class="token string">"mypvc1"</span> deleted</code></pre><p>当 PVC mypvc1 被删除后，发现 Kubernetes 启动了一个新 Pod，这个 Pod 的作用就是清除 PV mypv1 的数据。这个时候再看 NFS 服务器目录 /data/NFS/k8s/pv1/ 中已经没有数据了</p><p><img src="/medias/loading.gif" data-original="/images/k8s/nfs/16373060619523.jpg" alt="data1"></p><p><strong>注意:</strong> 删除 mypvc1 时之前要停止与它相关的 pod ，不然 mypvc1一直处于 Terminating 状态</p><p>（2）当数据清除完毕，mypv1 的状态重新变为 Available，此时则可以被新的 PVC 申请。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pv</span>NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGEmypv1   1Gi        RWO            Recycle          Available           nfs                     67m</code></pre><p>（3）因为 PV 的回收策略设置为 Recycle，所以数据会被清除，但这可能不是我们想要的结果。如果我们希望保留数据，可以将策略设置为 Retain。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mypv1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Retain  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /data/NFS/k8s/pv1    <span class="token key atrule">server</span><span class="token punctuation">:</span> 192.168.11.101</code></pre><p>（4）通过 kubectl apply 更新 PV：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master pv<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl apply -f nfs-pv1.yaml</span>persistentvolume/mypv1 configured<span class="token punctuation">[</span>root@k8s-master pv<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pv</span>NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGEmypv1   1Gi        RWO            Retain           Available           nfs                     81m<span class="token punctuation">[</span>root@k8s-master pv<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#</span></code></pre><p>（5）回收策略已经变为 Retain，通过下面步骤验证其效果：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl exec mypod1 touch /mydata/hello</span>kubectl exec <span class="token punctuation">[</span>POD<span class="token punctuation">]</span> <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> is DEPRECATED and will be removed in a future version. Use kubectl exec <span class="token punctuation">[</span>POD<span class="token punctuation">]</span> <span class="token punctuation">-</span><span class="token punctuation">-</span> <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> instead.<span class="token key atrule">error</span><span class="token punctuation">:</span> unable to upgrade connection<span class="token punctuation">:</span> container not found ("mypod1")<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod</span>NAME                     READY   STATUS    RESTARTS   AGEmypod1                   1/1     Running   0          27snginx<span class="token punctuation">-</span>58dcb77688<span class="token punctuation">-</span>h8c5x   1/1     Running   0          4d<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl exec mypod1 touch /mydata/hello</span>kubectl exec <span class="token punctuation">[</span>POD<span class="token punctuation">]</span> <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> is DEPRECATED and will be removed in a future version. Use kubectl exec <span class="token punctuation">[</span>POD<span class="token punctuation">]</span> <span class="token punctuation">-</span><span class="token punctuation">-</span> <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> instead.<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl delete -f ../pod/pod1.yaml</span>pod "mypod1" deleted<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pvc</span>NAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGEmypvc1   Bound    mypv1    1Gi        RWO            nfs            3m48s<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl delete pvc mypvc1</span>persistentvolumeclaim "mypvc1" deleted<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pvc</span>No resources found in default namespace.<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#</span></code></pre><p>（6）我们再看 NFS 服务器目录 /nfsdata/pv1 中数据还保留。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@rediscom pv1<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>hello<span class="token punctuation">[</span>root@rediscom pv1<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#</span></code></pre><p>（7）虽然 mypv1 中的数据得到了保留，但其 PV 状态会一直处于 Released，不能被其他 PVC 申请。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pv</span>NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS     CLAIM            STORAGECLASS   REASON   AGEmypv1   1Gi        RWO            Retain           Released   default/mypvc1   nfs                     89m</code></pre><p>8）为了重新使用存储资源，可以删除并重新创建 mypv1。删除操作只是删除了 PV 对象，存储空间中的数据并不会被删除。</p><p>新建的 mypv1 状态为 Available，已经可以被 PVC 申请。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl delete pv mypv1</span><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ubectl apply -f nfs-pv1.yaml</span><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pv</span>NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGEmypv1   1Gi        RWO            Retain           Available           nfs                     2s<span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#</span></code></pre><p>PV 还支持 Delete 的回收策略，会删除 PV 在 Storage Provider 上对应存储空间。NFS 的 PV 不支持 Delete，支持 Delete 的 Provider 有 AWS EBS、GCE PD、Azure Disk、OpenStack Cinder Volume 等</p><h3 id="4-PV的动态供给"><a href="#4-PV的动态供给" class="headerlink" title="4.  PV的动态供给"></a>4.  PV的动态供给</h3><p>pv的供给方式</p><p>前面的例子中，我们提前创建了 PV，然后通过 PVC 申请 PV 并在 Pod 中使用，这种方式叫做静态供给（Static Provision）。</p><p>与之对应的是动态供给（Dynamical Provision），即如果没有满足 PVC 条件的 PV，会动态创建 PV。相比静态供给，动态供给有明显的优势：不需要提前创建 PV，减少了管理员的工作量，效率高。</p><p>动态供给是通过 StorageClass 实现的，StorageClass 定义了如何创建 PV</p><p>pv动态供给举例<br>StorageClass standard：</p><p><img src="/medias/loading.gif" data-original="/images/k8s/nfs/16373075330215.jpg" alt="standard"></p><p>StorageClass slow：</p><p><img src="/medias/loading.gif" data-original="/images/k8s/nfs/16373075453270.jpg" alt="slow"></p><p>这两个 StorageClass 都会动态创建 AWS EBS，不同在于 standard 创建的是 gp2 类型的 EBS，而 slow 创建的是 io1 类型的 EBS。不同类型的 EBS 支持的参数可参考 AWS 官方文档。</p><p>StorageClass 支持 Delete 和 Retain 两种 reclaimPolicy，默认是 Delete。</p><p>与之前一样，PVC 在申请 PV 时，只需要指定 StorageClass 和容量以及访问模式，比如：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mypvc1<span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>   <span class="token punctuation">-</span> ReadWriteOnce <span class="token key atrule">resources</span><span class="token punctuation">:</span>   <span class="token key atrule">requests</span><span class="token punctuation">:</span>     <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> standard</code></pre><p>除了 AWS EBS，Kubernetes 支持其他多种动态供给 PV 的 Provisioner，完整列表请参考 <a href="https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner">https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-部署nfs服务端&quot;&gt;&lt;a href=&quot;#1-部署nfs服务端&quot; class=&quot;headerlink&quot; title=&quot;1. 部署nfs服务端&quot;&gt;&lt;/a&gt;1. 部署nfs服务端&lt;/h3&gt;&lt;p&gt;在任意一台服务器上安装&lt;/p&gt;
&lt;p&gt;（1）安装nfs服务:&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="k8s" scheme="https://costalong.com/categories/k8s/"/>
    
    
    <category term="k8s" scheme="https://costalong.com/tags/k8s/"/>
    
    <category term="nfs" scheme="https://costalong.com/tags/nfs/"/>
    
    <category term="storage" scheme="https://costalong.com/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>traefik 简介</title>
    <link href="https://costalong.com/2023/09/13/traefik/treafik-introduce/"/>
    <id>https://costalong.com/2023/09/13/traefik/treafik-introduce/</id>
    <published>2023-09-13T03:18:12.000Z</published>
    <updated>2023-09-13T13:06:11.545Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-官方文档"><a href="#1-官方文档" class="headerlink" title="1. 官方文档"></a>1. 官方文档</h3><p><a href="https://doc.traefik.io/traefik/">https://doc.traefik.io/traefik/</a></p><h3 id="2-简介"><a href="#2-简介" class="headerlink" title="2. 简介"></a>2. 简介</h3><p>traefik是一个使你把微服务暴露出来变的更容易的http反向代理和负载均衡软件。traefik支持K8S、docker swarm、mesos、consul、etcd、zookeeper等基础设施组件，动态的应用它的配置文件设置。</p><h3 id="3-流量示意图"><a href="#3-流量示意图" class="headerlink" title="3. 流量示意图"></a>3. 流量示意图</h3><p><img src="/medias/loading.gif" data-original="http://file.longqiuhong.com/uploads/picgo/treafik-flow.png" alt="treafik-flow"></p><p>代理入口</p><p><img src="/medias/loading.gif" data-original="https://file.longqiuhong.com/uploads/picgo/route-flow.png" alt="route-flow"></p><p>路由：</p><p><img src="/medias/loading.gif" data-original="http://file.longqiuhong.com/uploads/picgo/routers.png" alt="routers"></p><h3 id="4-核心概念"><a href="#4-核心概念" class="headerlink" title="4. 核心概念"></a>4. 核心概念</h3><p>当启动Traefik时，需要定义<code>entrypoints</code>，然后通过entrypoints的路由来分析传入的请求，来查看他们是否是一组规则匹配，如果匹配，则路由可能将请求通过一系列的转换过来在发送到服务上去。</p><p><img src="/medias/loading.gif" data-original="https://file.longqiuhong.com/uploads/picgo/agence.png" alt="agence"></p><ul><li><code>Providers</code> 是基础组件，traefik的配置发现是通过它来实现，它可以是协调器，容器引擎，云提供商或键值存储，通过查询 Providers 的API来查询路由的相关信息，一旦检查变化，就会动态更新路由</li><li><code>Entrypoints</code>监听传入的流量，是网络的入口点，定义了接受请求的端口(HTTP或者TCP)</li><li><code>Routers</code>分析请求(host,path,headers,SSL等)，负责将传入的请求连接到可以处理这些请求的服务上去</li><li><code>Service</code>将请求转发给应用，负责配置如何最终将处理传入请求的实际服务</li><li><code>Middlewares</code>中间件，用来修改请求或者根据请求来做出判断，中间件被附件到路由上，是一种在请求发送到服务之前调整请求的一种方法</li></ul><h3 id="5-路由规则"><a href="#5-路由规则" class="headerlink" title="5. 路由规则"></a>5. 路由规则</h3><p>路由类型分为三种，分别为：<code>http</code>、<code>tcp</code>、<code>udp</code></p><p>路由规则是指，Traefik接收到的请求，根据给定规则路由到不同的服务中。</p><table><thead><tr><th>Rule</th><th>Description</th></tr></thead><tbody><tr><td>Headers(<code>key</code>, <code>value</code>)</td><td>Check if there is a key keydefined in the headers, with the value value</td></tr><tr><td>HeadersRegexp(<code>key</code>, <code>regexp</code>)</td><td>Check if there is a key keydefined in the headers, with a value that matches the regular expression regexp</td></tr><tr><td>Host(<code>example.com</code>, …)</td><td>Check if the request domain (host header value) targets one of the given domains.</td></tr><tr><td>HostHeader(<code>example.com</code>, …)</td><td>Check if the request domain (host header value) targets one of the given domains.</td></tr><tr><td>HostRegexp(<code>example.com</code>, <code>{subdomain:[a-z]+}.example.com</code>, …)</td><td>Check if the request domain matches the given regexp.</td></tr><tr><td>Method(<code>GET</code>, …)</td><td>Check if the request method is one of the given methods (GET, POST, PUT, DELETE, PATCH, HEAD)</td></tr><tr><td>Path(<code>/path</code>, <code>/articles/{cat:[a-z]+}/{id:[0-9]+}</code>, …)</td><td>Match exact request path. It accepts a sequence of literal and regular expression paths.</td></tr><tr><td>PathPrefix(<code>/products/</code>, <code>/articles/{cat:[a-z]+}/{id:[0-9]+}</code>)</td><td>Match request prefix path. It accepts a sequence of literal and regular expression prefix paths.</td></tr><tr><td>Query(<code>foo=bar</code>, <code>bar=baz</code>)</td><td>Match Query String parameters. It accepts a sequence of key=value pairs.</td></tr><tr><td>ClientIP(<code>10.0.0.0/16</code>, <code>::1</code>)</td><td>Match if the request client IP is one of the given IP/CIDR. It accepts IPv4, IPv6 and CIDR formats</td></tr></tbody></table><p>这个正则配起来稍微有点小坑</p><p>为了对<code>Host</code>和<code>Path</code>使用正则表达式，需要声明一个任意命名的变量，然后跟上用冒号分隔的正则表达式，所有这些都用花括号括起来。</p><pre class=" language-yaml"><code class="language-yaml">HostRegexp(`grafana.<span class="token punctuation">{</span>domain<span class="token punctuation">:</span>.*<span class="token punctuation">}</span>`)</code></pre><h3 id="6-服务"><a href="#6-服务" class="headerlink" title="6. 服务"></a>6. 服务</h3><p><img src="/medias/loading.gif" data-original="https://file.longqiuhong.com/uploads/picgo/services.png" alt="services"></p><p>服务负责配置如何到达实际的服务，最终将处理传入的请求。使用<code>service</code>定义：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">http</span><span class="token punctuation">:</span>  <span class="token key atrule">services</span><span class="token punctuation">:</span>    <span class="token key atrule">traefik</span><span class="token punctuation">:</span>      <span class="token key atrule">loadBalancer</span><span class="token punctuation">:</span>        <span class="token key atrule">servers</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">url</span><span class="token punctuation">:</span> <span class="token string">"http://127.0.0.1:10000"</span></code></pre><p>​更多配置，可以参考：<a href="https://doc.traefik.io/traefik/routing/services/">官网介绍</a></p><h3 id="7-中间件"><a href="#7-中间件" class="headerlink" title="7. 中间件"></a>7. 中间件</h3><p><img src="/medias/loading.gif" data-original="http://file.longqiuhong.com/uploads/picgo/middleware.png" alt="middleware"></p><p>从图中基本可以明白中间件的作用，也可以理解成拦截器。<br>Traefik中有几种可用的中间件：一些可以修改请求、请求头，一些负责重定向，一些可以添加身份验证等等。</p><p>下面是一个官网给出的示例：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># As YAML Configuration File</span><span class="token key atrule">http</span><span class="token punctuation">:</span>  <span class="token key atrule">routers</span><span class="token punctuation">:</span>    <span class="token key atrule">router1</span><span class="token punctuation">:</span>      <span class="token key atrule">service</span><span class="token punctuation">:</span> myService      <span class="token key atrule">middlewares</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token string">"foo-add-prefix"</span>      <span class="token key atrule">rule</span><span class="token punctuation">:</span> <span class="token string">"Host(`example.com`)"</span>  <span class="token key atrule">middlewares</span><span class="token punctuation">:</span>    <span class="token key atrule">foo-add-prefix</span><span class="token punctuation">:</span>      <span class="token key atrule">addPrefix</span><span class="token punctuation">:</span>        <span class="token key atrule">prefix</span><span class="token punctuation">:</span> <span class="token string">"/foo"</span>  <span class="token key atrule">services</span><span class="token punctuation">:</span>    <span class="token key atrule">service1</span><span class="token punctuation">:</span>      <span class="token key atrule">loadBalancer</span><span class="token punctuation">:</span>        <span class="token key atrule">servers</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">url</span><span class="token punctuation">:</span> <span class="token string">"http://127.0.0.1:80"</span></code></pre><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><ul><li><a href="https://github.com/traefik/traefik">Traefik源码仓库</a></li><li><a href="https://traefik.io/">Traefik官网</a></li><li><a href="https://doc.traefik.io/traefik/reference/static-configuration/file/">Traefik静态配置项-File provider</a></li><li><a href="https://letsencrypt.org/">Let’s Encrypt</a></li><li><a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">Systemd文档</a></li><li><a href="https://ormissia.github.io/posts/deployment/3003-linux-traefik/">ormissia blog</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-官方文档&quot;&gt;&lt;a href=&quot;#1-官方文档&quot; class=&quot;headerlink&quot; title=&quot;1. 官方文档&quot;&gt;&lt;/a&gt;1. 官方文档&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://doc.traefik.io/traefik/&quot;&gt;https://do</summary>
      
    
    
    
    <category term="traefik" scheme="https://costalong.com/categories/traefik/"/>
    
    
    <category term="k8s" scheme="https://costalong.com/tags/k8s/"/>
    
    <category term="traefik" scheme="https://costalong.com/tags/traefik/"/>
    
  </entry>
  
  <entry>
    <title>InitContainers模式</title>
    <link href="https://costalong.com/2023/09/09/k8s/initcontainers-mo-shi/"/>
    <id>https://costalong.com/2023/09/09/k8s/initcontainers-mo-shi/</id>
    <published>2023-09-09T15:05:13.000Z</published>
    <updated>2023-09-13T13:06:11.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="initContainer使用"><a href="#initContainer使用" class="headerlink" title="initContainer使用"></a>initContainer使用</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>init容器是在同一个Pod中的其他容器之前启动和执行的容器。它的目的是<strong>为Pod上托管的主应用程序执行初始化逻辑</strong>。例如，创建必要的用户帐户、执行数据库迁移、创建数据库模式等等。</p><h2 id="Init-Containers-注意事项"><a href="#Init-Containers-注意事项" class="headerlink" title="Init Containers 注意事项"></a>Init Containers 注意事项</h2><p>在创建 init 容器时，应该考虑一些注意事项：</p><ol><li><p>它们总是在 Pod 中的其他容器之前执行。因此，它们不应包含需要很长时间才能完成的复杂逻辑。启动脚本通常小而简洁。如果您发现向 init 容器添加了太多逻辑，则应考虑将其中的一部分移至应用程序容器本身。</p></li><li><p>init 容器按顺序启动和执行。除非成功完成其前任容器，否则不会调用 init 容器。因此，如果启动任务很长，您可以考虑将其分解为多个步骤，每个步骤由一个 init 容器处理，以便您知道哪些步骤失败。</p></li><li><p>如果任何 init 容器失败，整个 Pod 将重新启动（除非您将 restartPolicy 设置为 Never）。重新启动 Pod 意味着再次重新执行所有容器，包括任何 init 容器。因此，您可能需要确保启动逻辑可以容忍多次执行而不会导致重复。例如，如果数据库迁移已经完成，再次执行迁移命令应该被忽略。</p></li><li><p>init 容器是延迟应用程序初始化直到一个或多个依赖项可用的良好候选者。例如，如果您的应用程序依赖于强加 API 请求速率限制的 API，您可能需要等待特定时间段才能接收来自该 API 的响应。在应用程序容器中实现这个逻辑可能很复杂；因为它需要与健康和准备探测器相结合。一个更简单的方法是创建一个 init 容器，它会等待 API 准备就绪后再成功退出。只有在 init 容器成功完成其工作后，应用程序容器才会启动。</p></li><li><p>Init 容器不能像应用程序容器那样使用健康和就绪探测。原因是它们旨在成功启动和退出，就像 Jobs 和 CronJobs 的行为方式一样。</p></li><li><p>同一个 Pod 上的所有容器共享相同的 Volumes 和网络。您可以利用此功能在应用程序及其初始化容器之间共享数据。</p></li></ol><h2 id="Init容器“Request”和“Limits”行为"><a href="#Init容器“Request”和“Limits”行为" class="headerlink" title="Init容器“Request”和“Limits”行为"></a>Init容器“Request”和“Limits”行为</h2><p>init 容器总是在同一个 Pod 上的其他应用程序容器之前启动。因此，调度程序对 init 容器的资源和限制给予更高的优先级。必须彻底考虑此类行为，因为它可能会导致不希望的结果。例如，如果你有一个 init 容器和一个应用程序容器，并且你将 init 容器的资源和限制设置为高于应用程序容器的资源和限制，那么只有在有一个满足 init 的可用节点时，整个 Pod 才会被调度容器要求。换句话说，即使有一个未使用的节点可以运行应用程序容器，如果 init 容器具有该节点可以处理的更高资源先决条件，Pod 也不会部署到该节点。因此，在定义 init 容器的请求和限制时，您应该尽可能严格。作为最佳实践，除非绝对需要，否则不要将这些参数设置为高于应用程序容器的值</p><h5 id="应用场景01：为数据库做种"><a href="#应用场景01：为数据库做种" class="headerlink" title="应用场景01：为数据库做种"></a>应用场景01：为数据库做种</h5><p>在这个场景中，我们为 MySQL 数据库提供服务。该数据库用于测试应用程序。它不必包含真实数据，但必须填充足够的数据，以便我们可以测试应用程序的查询速度。我们使用 init 容器来处理 SQL 转储文件的下载并将其恢复到托管在另一个容器中的数据库。</p><p>定义文件可能如下所示：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mydb  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> db<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">initContainers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> fetch      <span class="token key atrule">image</span><span class="token punctuation">:</span> mwendler/wget      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"wget"</span><span class="token punctuation">,</span><span class="token string">"--no-check-certificate"</span><span class="token punctuation">,</span><span class="token string">"https://sample-videos.com/sql/Sample-SQL-File-1000rows.sql"</span><span class="token punctuation">,</span><span class="token string">"-O"</span><span class="token punctuation">,</span><span class="token string">"/docker-entrypoint-initdb.d/dump.sql"</span><span class="token punctuation">]</span>      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /docker<span class="token punctuation">-</span>entrypoint<span class="token punctuation">-</span>initdb.d          <span class="token key atrule">name</span><span class="token punctuation">:</span> dump  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mysql      <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql      <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> MYSQL_ROOT_PASSWORD          <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"example"</span>      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /docker<span class="token punctuation">-</span>entrypoint<span class="token punctuation">-</span>initdb.d          <span class="token key atrule">name</span><span class="token punctuation">:</span> dump  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> dump</code></pre><p>上面的定义创建了一个 Pod，它托管着两个容器：init 容器和应用程序容器。让我们来看看这个定义的有趣方面：</p><ol><li>init 容器负责下载包含数据库转储的 SQL 文件。我们使用 mwendler/wget 镜像，因为我们只需要 wget 命令。</li><li>下载的 SQL 的目标目录是 MySQL 镜像用来执行 SQL 文件的目录（/docker-entrypoint-initdb.d）。此行为内置于我们在应用程序容器中使用的 MySQL 镜像中。</li><li>init 容器将/docker-entrypoint-initdb.d挂载到emptyDir卷。因为两个容器都托管在同一个 Pod 上，所以它们共享相同的卷。因此，数据库容器可以访问放置在 emptyDir 卷上的 SQL 文件。</li></ol><h5 id="如果没有使用-InitContainers会发生什么？"><a href="#如果没有使用-InitContainers会发生什么？" class="headerlink" title="如果没有使用 InitContainers会发生什么？"></a>如果没有使用 InitContainers会发生什么？</h5><p>在这个例子中，我们使用初始化模式来建立关注点分离的最佳实践。如果我们在不使用 init 模式的情况下实现相同的逻辑，我们必须基于 mysql 基础镜像创建一个新镜像，安装 wget，并使用它来下载 SQL 文件。这种方法的缺点是：</p><p>如果我们需要对下载逻辑进行任何更改，我们需要创建一个新镜像，推送它并更改其在定义文件中的引用。这增加了必须维护自定义镜像的负担。</p><p>它在 DB 容器与其启动逻辑之间创建了紧密耦合的关系，这使得应用程序更难管理并增加了引入错误和错误的可能性。</p><h2 id="场景-02：延迟应用程序启动，直到依赖项准备就绪"><a href="#场景-02：延迟应用程序启动，直到依赖项准备就绪" class="headerlink" title="场景 02：延迟应用程序启动，直到依赖项准备就绪"></a>场景 02：延迟应用程序启动，直到依赖项准备就绪</h2><p>init 容器的另一个常见用例是当您需要应用程序等待另一个服务完全运行（响应请求）时。以下定义演示了这种情况：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp<span class="token punctuation">-</span>pod  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> myapp<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">initContainers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> init<span class="token punctuation">-</span>myservice    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox<span class="token punctuation">:</span><span class="token number">1.28</span>    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'sh'</span><span class="token punctuation">,</span> <span class="token string">'-c'</span><span class="token punctuation">,</span> <span class="token string">'until nslookup myservice; do echo waiting for myservice; sleep 2; done;'</span><span class="token punctuation">]</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp<span class="token punctuation">-</span>container    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox<span class="token punctuation">:</span><span class="token number">1.28</span>    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'sh'</span><span class="token punctuation">,</span> <span class="token string">'-c'</span><span class="token punctuation">,</span> <span class="token string">'echo The app is running! &amp;&amp; sleep 3600'</span><span class="token punctuation">]</span></code></pre><p>因此，假设我们的应用程序在 myapp-container 上运行时无法正常运行，除非 myservice 应用程序正在运行。我们需要延迟 myapp 启动，直到 myservice 准备就绪。为此，我们使用一个简单的 nslookup 命令（第 11 行）不断检查“myservice”的名称解析是否成功。如果 nslookup 能够解析“myservice”，则服务将启动。使用成功退出代码，init 容器终止，让应用程序容器启动。否则，容器在再次尝试之前会休眠两秒钟，从而延迟应用程序容器的启动。</p><p>为了完整起见，这是 myservice 的定义文件：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> myservice<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">9376</span></code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>初始化模式是设计需要启动逻辑的应用程序时要遵循的重要实践。</p><p>Kubernetes 提供 init 容器作为将应用程序逻辑与其启动过程分离的一种手段。</p><p>将应用程序初始化逻辑放在 init 容器中具有许多优点：</p><ol><li><p>您将强加关注点分离原则。一个应用程序可以有它的工程师团队，而它的初始化逻辑是由另一个团队编写的。</p></li><li><p>当涉及到授权和访问控制时，拥有一个单独的团队来处理应用程序的初始化步骤可以使公司更加灵活。例如，如果启动应用程序需要使用需要安全许可的资源（例如，修改防火墙规则），则可以由具有合适凭据的人员完成。应用团队不参与操作。</p></li><li><p>如果涉及的初始化步骤太多，可以将它们分解成多个 init 容器依次执行。如果一个步骤失败，init 容器会报告错误，这可以让您更好地了解逻辑的哪一部分不成功。</p></li></ol><p>使用 init 容器时应考虑以下几点：</p><ol><li><p>初始化容器在失败时重新启动。因此，他们的代码必须是幂等的。</p></li><li><p>初始化容器是请求和限制首先由调度程序检查。不正确的值可能会对调度程序关于放置整个 Pod（包括应用程序容器）的位置的决定产生负面影响。</p></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;initContainer使用&quot;&gt;&lt;a href=&quot;#initContainer使用&quot; class=&quot;headerlink&quot; title=&quot;initContainer使用&quot;&gt;&lt;/a&gt;initContainer使用&lt;/h1&gt;&lt;h2 id=&quot;介绍：&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="k8s" scheme="https://costalong.com/categories/k8s/"/>
    
    
    <category term="k8s" scheme="https://costalong.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>CSI--容器储存接口</title>
    <link href="https://costalong.com/2023/09/03/k8s/csi-fen-xi-rong-qi-chu-cun-jie-kou/"/>
    <id>https://costalong.com/2023/09/03/k8s/csi-fen-xi-rong-qi-chu-cun-jie-kou/</id>
    <published>2023-09-03T14:08:17.000Z</published>
    <updated>2023-09-13T13:06:11.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-CSI简介–-储存接口"><a href="#1-CSI简介–-储存接口" class="headerlink" title="1. CSI简介– 储存接口"></a>1. CSI简介– 储存接口</h2><p>  k8s 的设计理念是支持可插拔架构，从而有利用扩展k8s 的功能。在次思想下，k8s 提供了 3 个特定功能得到接口，分别是：容器网络接口（CNI）、容器运行时接口（CRI）、容器储存接口（CSI）。本文主要介绍容器储存接口（CSI）。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-CSI简介–-储存接口&quot;&gt;&lt;a href=&quot;#1-CSI简介–-储存接口&quot; class=&quot;headerlink&quot; title=&quot;1. CSI简介– 储存接口&quot;&gt;&lt;/a&gt;1. CSI简介– 储存接口&lt;/h2&gt;&lt;p&gt;  k8s 的设计理念是支持可插拔架构，从而有利</summary>
      
    
    
    
    <category term="k8s" scheme="https://costalong.com/categories/k8s/"/>
    
    
    <category term="k8s" scheme="https://costalong.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>go-redis 教程</title>
    <link href="https://costalong.com/2023/01/30/go-redis-jiao-cheng/"/>
    <id>https://costalong.com/2023/01/30/go-redis-jiao-cheng/</id>
    <published>2023-01-30T04:25:44.000Z</published>
    <updated>2023-01-30T13:44:35.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装go-redis包"><a href="#安装go-redis包" class="headerlink" title="安装go-redis包"></a>安装go-redis包</h2><pre class=" language-bash"><code class="language-bash">go get github.com/redis/go-redis/v9</code></pre><h2 id="连接-redis-服务"><a href="#连接-redis-服务" class="headerlink" title="连接 redis 服务"></a>连接 redis 服务</h2><ol><li>使用 options 方式</li></ol><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/redis/go-redis/v9"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    rdb <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">NewClient</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>redis<span class="token punctuation">.</span>Options<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span>  <span class="token string">"localhost:6379"</span><span class="token punctuation">,</span>        Password<span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// no password set</span>        DB<span class="token punctuation">:</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// use default DB</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    res<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Ping</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>使用 dns 字符串方式</li></ol><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/redis/go-redis/v9"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注意 redis 是没有用户的，所以user 设置为空 </span>    opt<span class="token punctuation">,</span> err <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">ParseURL</span><span class="token punctuation">(</span><span class="token string">"redis://&lt;user>:&lt;pass>@localhost:6379/&lt;db>"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    rdb <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">NewClient</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span>    res<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Ping</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ol start="3"><li>连接 redis 服务设置连接名字</li></ol><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/redis/go-redis/v9"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注意 redis 是没有用户的，所以user 设置为空 </span>    opt<span class="token punctuation">,</span> err <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">ParseURL</span><span class="token punctuation">(</span><span class="token string">"redis://&lt;user>:&lt;pass>@localhost:6379/&lt;db>"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    rdb <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">NewClient</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span>    res<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Ping</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="redis-数据类型"><a href="#redis-数据类型" class="headerlink" title="redis 数据类型"></a>redis 数据类型</h2><p>redis 的数据类型有五种，分别为: 字符串(string)、列表(list)、集合(set)、哈希(hash)、有序集合(zset)</p><h3 id="操作字符串-string"><a href="#操作字符串-string" class="headerlink" title="操作字符串 (string)"></a>操作字符串 (string)</h3><ol><li>获取字符串内容执行命令</li></ol><p>redis 命令</p><pre class=" language-redis"><code class="language-redis">get mykey</code></pre><p>直接返回结果</p><pre class=" language-go"><code class="language-go">key <span class="token operator">:=</span> <span class="token string">"mykey"</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>val<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span></code></pre><p>保存命令并稍后分别访问值与错误</p><pre class=" language-go"><code class="language-go">key <span class="token operator">:=</span> <span class="token string">"mykey"</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>get <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> key<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>get<span class="token punctuation">.</span><span class="token function">Val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>执行go-redis包不支持的命令</p><pre class=" language-go"><code class="language-go">key <span class="token operator">:=</span> <span class="token string">"mykey"</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>val<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token string">"get"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> redis<span class="token punctuation">.</span>Nil <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"key dose not exists"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span></code></pre><pre class=" language-go"><code class="language-go">key <span class="token operator">:=</span> <span class="token string">"mykey"</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>val<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token string">"get"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> err<span class="token punctuation">)</span></code></pre><p>帮助函数完整列表:</p><pre class=" language-go"><code class="language-go">s<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span>flag<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Int</span><span class="token punctuation">(</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Int64</span><span class="token punctuation">(</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Uint64</span><span class="token punctuation">(</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Float32</span><span class="token punctuation">(</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Float64</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ss<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">StringSlice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ns<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Int64Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ns<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Uint64Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fs<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Float32Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fs<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Float64Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>bs<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">BoolSlice</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ol start="2"><li>设置字符串数据</li></ol><p>redis 命令</p><pre class=" language-redis"><code class="language-redis">set mykey "ddd" EX 10 </code></pre><p>go-redis </p><pre class=" language-go"><code class="language-go">key <span class="token operator">:=</span> <span class="token string">"mykey"</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>cmd <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token string">"ddd"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>   fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>cmd<span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>设置key到期的时间</p><pre class=" language-go"><code class="language-go">expireAt <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">AddDate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>args <span class="token operator">:=</span> redis<span class="token punctuation">.</span>SetArgs<span class="token punctuation">{</span>    ExpireAt<span class="token punctuation">:</span> expireAt<span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">SetArgs</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token string">"key"</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装go-redis包&quot;&gt;&lt;a href=&quot;#安装go-redis包&quot; class=&quot;headerlink&quot; title=&quot;安装go-redis包&quot;&gt;&lt;/a&gt;安装go-redis包&lt;/h2&gt;&lt;pre class=&quot; language-bash&quot;&gt;&lt;code cla</summary>
      
    
    
    
    
    <category term="go" scheme="https://costalong.com/tags/go/"/>
    
    <category term="redis" scheme="https://costalong.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>git 安装</title>
    <link href="https://costalong.com/2023/01/28/git/"/>
    <id>https://costalong.com/2023/01/28/git/</id>
    <published>2023-01-28T03:18:12.000Z</published>
    <updated>2023-09-13T13:06:11.543Z</updated>
    
    <content type="html"><![CDATA[<p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p><h2 id="Mac-install"><a href="#Mac-install" class="headerlink" title="Mac install"></a>Mac install</h2><pre class=" language-bash"><code class="language-bash">brew <span class="token function">install</span> <span class="token function">git</span></code></pre><h2 id="Ubuntu-install"><a href="#Ubuntu-install" class="headerlink" title="Ubuntu install"></a>Ubuntu install</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> <span class="token function">git</span></code></pre><h2 id="git-提交标准"><a href="#git-提交标准" class="headerlink" title="git 提交标准"></a>git 提交标准</h2><p><img src="/medias/loading.gif" data-original="http://file.longqiuhong.com/uploads/picgo/16315958305196.jpg" alt="git 提交标准"></p><h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><p><img src="/medias/loading.gif" data-original="https://file.longqiuhong.com/uploads/picgo/04453ab5aed44227919c808b392b48d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="git 常用的命令"></p><p>查看代码版本：</p><pre class=" language-sh"><code class="language-sh">git describe --always --tags --abbrev=0 --match 'v*' --exclude '*/*' | tr -d "[\r\n]"</code></pre><p>删除tag</p><pre class=" language-sh"><code class="language-sh">git tag --delete  tag name  // v本地git push origin :refs/tags/v1.0.0  // 删除远程 v1.0.0</code></pre><p>修改tag 名称</p><pre class=" language-sh"><code class="language-sh">git tag new_tag old_taggit tag -d old_taggit push origin :refs/tags/old_taggit push --tags</code></pre><p>删除远程分支</p><pre class=" language-sh"><code class="language-sh">git push origin --delete <branchName></code></pre><p>强制切换到 commit_id 这个记录</p><pre class=" language-sh"><code class="language-sh">git reset --hard commit_id</code></pre><p>强制提交到远程</p><pre class=" language-sh"><code class="language-sh">git push -f</code></pre><p>删除本地的远程不存在的分支</p><pre class=" language-sh"><code class="language-sh">git remote prune origin</code></pre><p><code>git commit</code>完之后，还没有执行<code>git push</code>，想修改/撤销这个<code>commit</code>，怎么办？<br>如果只是想修改注释，可以这样操作</p><pre class=" language-sh"><code class="language-sh">git commit --amend这个时候进入`vim`编辑，直接修改即可，修改完注释，退出`vim`编辑`:wq`保存已编辑的注释，重新`git push`即可</code></pre><p>要撤回commit</p><pre class=" language-sh"><code class="language-sh">git reset --soft HEAD^这样就能成功的撤回你刚刚的`commit`操作。HEAD^的意思是上一个版本，也可以写成HEAD~1如果你进行了2次commit，想都撤回，可以使用HEAD~2</code></pre><p><strong>注意，这个命令仅仅是撤回commit操作，写的代码仍然保留</strong></p><p>恢复本地未提交内容</p><pre class=" language-sh"><code class="language-sh">git checkout .</code></pre><pre class=" language-sh"><code class="language-sh">git reset HEAD  *# 回退到上一个版本git reset --hard HEAD^#回退到上上次版本git reset --hard HEAD^^git reset --hard HEAD^^^#回退到指定commitid的版本git reset --hard  commit_id</code></pre><p>恢复本地已提交内容</p><pre class=" language-sh"><code class="language-sh">git reset --hard</code></pre><p>恢复远程未提交内容</p><pre class=" language-sh"><code class="language-sh">git fetch origingit reset --hard origin/master</code></pre><h2 id="git-常见的错误处理"><a href="#git-常见的错误处理" class="headerlink" title="git 常见的错误处理"></a>git 常见的错误处理</h2><p>1、fatal: Not possible to fast-forward, aborting.</p><p>出现的原因：</p><p>两个分之同时改了同样的地方，造成冲突。一般的情况使用 merge  合并分支</p><pre class=" language-sh"><code class="language-sh">git checkout mastergit merge dev</code></pre><p>如果出现代码冲突的时候需要手动解决，但是有时候是无法合并成功的。</p><p>解决:</p><pre class=" language-sh"><code class="language-sh">git checkout mastergit rebase dev</code></pre><p>如果是一个分支，但是代码出现修改，也会出现改错误。</p><p>解决:</p><pre class=" language-sh"><code class="language-sh">git pull origin master --rebasegit pull origin development --rebasegit pull origin test --rebase</code></pre><p><strong>注意</strong> 修改冲突代码</p><p>在提交代码</p><pre class=" language-sh"><code class="language-sh">git push origin HEAD:develop     // develop 是分支</code></pre><p>在冲突解决完毕并且提交代码后，执行下面的命令：</p><pre class=" language-sh"><code class="language-sh">// 在终端也会有需要执行这个命令的提示git rebase --continue</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。&lt;/p&gt;
&lt;h2 id=&quot;Mac-install</summary>
      
    
    
    
    <category term="Tool" scheme="https://costalong.com/categories/Tool/"/>
    
    
    <category term="git" scheme="https://costalong.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://costalong.com/2023/01/28/hello-world/"/>
    <id>https://costalong.com/2023/01/28/hello-world/</id>
    <published>2023-01-28T03:18:12.000Z</published>
    <updated>2023-09-13T13:06:11.543Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="hexo" scheme="https://costalong.com/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://costalong.com/tags/hexo/"/>
    
  </entry>
  
</feed>
