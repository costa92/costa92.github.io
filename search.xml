<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git 回滚</title>
      <link href="/2024/11/19/git/git-rollback/"/>
      <url>/2024/11/19/git/git-rollback/</url>
      
        <content type="html"><![CDATA[<p>在 Git 中，<code>revert</code>、<code>reset</code> 和 <code>rebase</code> 都是用来修改提交记录或状态的，但它们的使用场景和效果各不相同。</p><hr><h2 id="恢复提交：git-revert"><a href="#恢复提交：git-revert" class="headerlink" title="恢复提交：git revert"></a><strong>恢复提交：<code>git revert</code></strong></h2><p><code>git revert</code> 命令的实际结果类似于 <code>reset</code>，但它的方法不同。<code>reset</code> 是通过移动分支指针撤销更改，而 <code>revert</code> 是通过添加一个新的提交取消更改。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> revert <span class="token operator">&lt;</span>commit-id<span class="token operator">></span></code></pre><p>例如，撤销最近一次提交：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> revert HEAD</code></pre><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>安全，不会修改历史记录。</li><li>适合用于团队协作和已推送到远程的分支。</li></ul><hr><h2 id="回退提交：git-reset"><a href="#回退提交：git-reset" class="headerlink" title="回退提交：git reset"></a><strong>回退提交：<code>git reset</code></strong></h2><p><code>git reset</code> 用于改变分支指针，并决定是否保留工作区和暂存区的更改。</p><h3 id="步骤-1：查看提交历史"><a href="#步骤-1：查看提交历史" class="headerlink" title="步骤 1：查看提交历史"></a><strong>步骤 1：查看提交历史</strong></h3><p>使用 <code>git log</code> 查询需要退回的提交 ID：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> log</code></pre><h3 id="步骤-2：选择回退模式"><a href="#步骤-2：选择回退模式" class="headerlink" title="步骤 2：选择回退模式"></a><strong>步骤 2：选择回退模式</strong></h3><ol><li><p><strong>软回退 (<code>--soft</code>)</strong><br>仅回退分支指针，保留暂存区和工作区的更改。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> reset --soft <span class="token operator">&lt;</span>commit-id<span class="token operator">></span></code></pre></li><li><p><strong>混合回退 (<code>--mixed</code>)</strong><br>回退分支指针，清除暂存区，保留工作区的更改。（这是默认模式）</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> reset --mixed <span class="token operator">&lt;</span>commit-id<span class="token operator">></span></code></pre></li><li><p><strong>硬回退 (<code>--hard</code>)</strong><br>回退分支指针，同时清除暂存区和工作区的所有更改。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> reset --hard <span class="token operator">&lt;</span>commit-id<span class="token operator">></span></code></pre></li></ol><h3 id="推送到远程"><a href="#推送到远程" class="headerlink" title="推送到远程"></a><strong>推送到远程</strong></h3><p>如果需要将本地的变更覆盖远程分支：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> push --force</code></pre><hr><h2 id="变基：git-rebase"><a href="#变基：git-rebase" class="headerlink" title="变基：git rebase"></a><strong>变基：<code>git rebase</code></strong></h2><p><code>git rebase</code> 用于重新整理提交历史，将当前分支的更改重新应用到另一个基础提交上。</p><h3 id="场景：分支变基"><a href="#场景：分支变基" class="headerlink" title="场景：分支变基"></a><strong>场景：分支变基</strong></h3><p>假设有以下分支：</p><ul><li><strong>master</strong>: <code>C4 -&gt; C2 -&gt; C1 -&gt; C0</code></li><li><strong>feature</strong>: <code>C5 -&gt; C3 -&gt; C2 -&gt; C1 -&gt; C0</code></li></ul><p>要将 <code>feature</code> 分支的提交重新基于 <code>master</code> 分支：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout feature<span class="token function">git</span> rebase master</code></pre><p>变基后的结果：</p><ul><li><strong>master</strong>: <code>C4 -&gt; C2 -&gt; C1 -&gt; C0</code></li><li><strong>feature</strong>: <code>C5' -&gt; C3' -&gt; C4 -&gt; C2 -&gt; C1 -&gt; C0</code></li></ul><h3 id="交互式变基"><a href="#交互式变基" class="headerlink" title="交互式变基"></a><strong>交互式变基</strong></h3><p>可以通过 <code>-i</code> 参数合并、修改或删除提交：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> rebase -i <span class="token operator">&lt;</span>base-branch<span class="token operator">></span></code></pre><p>编辑器中提供以下选项：</p><ul><li><code>pick</code>: 保留提交。</li><li><code>squash</code>: 合并当前提交到上一个提交。</li><li><code>edit</code>: 修改提交内容。</li></ul><hr><h2 id="恢复历史：git-reflog"><a href="#恢复历史：git-reflog" class="headerlink" title="恢复历史：git reflog"></a><strong>恢复历史：<code>git reflog</code></strong></h2><p><code>git reflog</code> 用于查看分支操作历史。它记录了所有分支指针的变动，帮助找回丢失的提交。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a><strong>用法</strong></h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> reflog</code></pre><p>示例输出：</p><pre class=" language-plaintext"><code class="language-plaintext">e309ee8 (HEAD -> master) HEAD@{0}: pull: Fast-forward30c0e5e HEAD@{1}: commit: fix: 优化代码9429f03 HEAD@{2}: commit: fix: 优化代码1bdcafe HEAD@{3}: commit: fix: 修改配置</code></pre><p>如果误操作（如 <code>git reset --hard</code>），可以通过 <code>git reflog</code> 找到目标提交并恢复：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> reset --hard <span class="token operator">&lt;</span>commit-id<span class="token operator">></span></code></pre><hr><h2 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a><strong>对比总结</strong></h2><table><thead><tr><th>功能</th><th><code>git revert</code></th><th><code>git reset</code></th><th><code>git rebase</code></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>撤销提交，创建新提交</td><td>改变提交历史</td><td>重组提交历史</td></tr><tr><td><strong>安全性</strong></td><td>安全，适合已推送分支</td><td>高风险，慎用于远程分支</td><td>高风险，慎用于远程分支</td></tr><tr><td><strong>适用场景</strong></td><td>团队协作，回滚指定提交</td><td>修改本地提交</td><td>清理历史、线性合并</td></tr></tbody></table><p>选择合适的工具，确保团队协作无缝进行！</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Commit</title>
      <link href="/2024/11/19/git/git-commit/"/>
      <url>/2024/11/19/git/git-commit/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-Commit-介绍"><a href="#Git-Commit-介绍" class="headerlink" title="Git Commit 介绍"></a><strong>Git Commit 介绍</strong></h2><p><code>git commit</code> 命令用于将工作区或暂存区的更改提交到版本库，形成可追踪的历史记录点。<br>它是 Git 工作流的核心操作，常用来保存代码的进展或完成阶段性开发。</p><hr><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将暂存区内容提交到版本库，进入编辑器填写提交信息</span><span class="token function">git</span> commit<span class="token comment" spellcheck="true"># 将特定文件提交到版本库（需已被跟踪）</span><span class="token function">git</span> commit <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 将暂存区内容提交到版本库，同时直接添加提交信息（无需打开编辑器）</span><span class="token function">git</span> commit -m <span class="token string">"&lt;message>"</span><span class="token comment" spellcheck="true"># 跳过 git add，将所有已跟踪文件的更改提交到版本库</span><span class="token function">git</span> commit -am <span class="token string">"&lt;message>"</span><span class="token comment" spellcheck="true"># 替代上一次提交：</span><span class="token comment" spellcheck="true"># - 若代码无更改，用于修改提交信息</span><span class="token comment" spellcheck="true"># - 若代码有更改，将其合并到上一次提交</span><span class="token function">git</span> commit --amend -m <span class="token string">"&lt;message>"</span></code></pre><hr><h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a><strong>常用选项</strong></h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-m &lt;message&gt;</code></td><td>指定提交信息，避免打开编辑器</td></tr><tr><td><code>-a</code></td><td>提交所有已修改或删除的文件（限已被 Git 跟踪的文件）</td></tr><tr><td><code>--amend</code></td><td>修改最近一次提交（包括内容或提交信息）</td></tr><tr><td><code>--no-edit</code></td><td>不修改提交信息，直接沿用上次的提交消息</td></tr></tbody></table><hr><h2 id="修改历史提交"><a href="#修改历史提交" class="headerlink" title="修改历史提交"></a><strong>修改历史提交</strong></h2><h3 id="修改最近一次提交"><a href="#修改最近一次提交" class="headerlink" title="修改最近一次提交"></a><strong>修改最近一次提交</strong></h3><p>如果需要修改最近一次提交的内容或提交信息：</p><ol><li>编辑文件，完成更改后添加到暂存区：<pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> add <span class="token operator">&lt;</span>file-name<span class="token operator">></span></code></pre></li><li>使用 <code>--amend</code> 更新提交：<pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> commit --amend</code></pre></li></ol><h3 id="修改更早的提交"><a href="#修改更早的提交" class="headerlink" title="修改更早的提交"></a><strong>修改更早的提交</strong></h3><p>通过交互式变基（<code>git rebase -i</code>）修改历史提交：</p><ol><li><p>启动交互式变基<br>例如，修改最近 3 次提交：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> rebase -i HEAD~3</code></pre></li><li><p>编辑器中显示提交历史：</p><pre class=" language-plaintext"><code class="language-plaintext">pick 1234567 feat: 添加新功能pick 89abcde fix: 修复启动问题pick def7890 docs: 更新文档</code></pre></li><li><p>将需要修改的提交改为 <code>edit</code>：</p><pre class=" language-plaintext"><code class="language-plaintext">pick 1234567 feat: 添加新功能edit 89abcde fix: 修复启动问题pick def7890 docs: 更新文档</code></pre></li><li><p>保存并退出。</p></li><li><p>修改文件并更新提交：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> add <span class="token operator">&lt;</span>file-name<span class="token operator">></span><span class="token function">git</span> commit --amend</code></pre></li><li><p>完成修改后继续变基：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> rebase --continue</code></pre></li></ol><hr><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h2><ol><li><p><strong>编写清晰的提交信息</strong><br>遵循 <a href="https://www.conventionalcommits.org/">Conventional Commits</a> 格式：</p><pre class=" language-plaintext"><code class="language-plaintext"><type>(<scope>): <subject><空行><body><空行><footer></code></pre><p><strong>示例：</strong></p><pre class=" language-plaintext"><code class="language-plaintext">feat(app): 添加用户登录功能实现用户登录和身份验证。解决了之前登录状态丢失的问题。Closes #123</code></pre></li><li><p><strong>保持提交单一职责</strong><br>每次提交只包含一种逻辑更改（例如，修复一个 bug 或实现一个功能），避免混合提交。</p></li><li><p><strong>修改已推送提交时的注意事项</strong></p><ul><li>若已推送到远程分支，需使用 <code>git push --force</code> 强制覆盖。</li><li>与团队协作时应谨慎，确保其他人未基于该提交工作。</li></ul></li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li><strong><code>git commit</code> 是 Git 的核心命令</strong>，通过合适的参数选项可以更高效地管理提交。</li><li>选择适合的用法（如 <code>--amend</code> 或 <code>rebase</code>）来优化历史提交，同时注意团队协作中的代码一致性。</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gomock进行单元测试</title>
      <link href="/2024/07/16/go/tests/gomock/"/>
      <url>/2024/07/16/go/tests/gomock/</url>
      
        <content type="html"><![CDATA[<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>在 mockgen 命令中,支持两种生成模式：</p><ol><li>source：从源文件生成 mock 接口（通过 -source 启用）</li></ol><pre class=" language-sh"><code class="language-sh">mockgen -source=foo.go [other options]</code></pre><ol start="2"><li>reflect：通过使用反射程序来生成 mock 接口.它通过传递两个非标志参数来启用：导入路径和逗号分隔的接口列表</li></ol><pre class=" language-sh"><code class="language-sh">mockgen database/sql/driver Conn,Driver</code></pre><p>两种方式生成的 mock 代码并没有什么区别.因此选择合适的就可以了</p><h2 id="写测试用例"><a href="#写测试用例" class="headerlink" title="写测试用例"></a>写测试用例</h2><p><strong>1. 步骤:</strong></p><ol><li>想清楚整体逻辑</li><li>定义想要（模拟）依赖项的 interface（接口）</li><li>使用 mockgen 命令对所需 mock 的 interface 生成 mock 文件</li><li>编写单元测试的逻辑,在测试中使用 mock</li><li>进行单元测试的验证</li></ol><p><strong>2. 目录：</strong></p><pre class=" language-yaml"><code class="language-yaml">├── mock├── person│   └── male.go└── user    ├── user.go    └── user_test.go</code></pre><p><strong>2. 编写：</strong></p><ol><li><p>定义 interface </p><p> 打开 person/male.go 文件,写入以下内容：</p></li></ol><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> person<span class="token keyword">type</span> Male <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">Get</span><span class="token punctuation">(</span>id <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token punctuation">}</span></code></pre><ol start="2"><li><p>调用方法</p><p>打开 user/user.go 文件,写入以下内容</p></li></ol><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> user<span class="token keyword">import</span> <span class="token string">"github.com/EDDYCJY/mockd/person"</span><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Person person<span class="token punctuation">.</span>Male<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">NewUser</span><span class="token punctuation">(</span>p person<span class="token punctuation">.</span>Male<span class="token punctuation">)</span> <span class="token operator">*</span>User <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>User<span class="token punctuation">{</span>Person<span class="token punctuation">:</span> p<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>u <span class="token operator">*</span>User<span class="token punctuation">)</span> <span class="token function">GetUserInfo</span><span class="token punctuation">(</span>id <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> u<span class="token punctuation">.</span>Person<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ol start="3"><li>生成 mock 文件</li></ol><p>回到 mockd/ 的根目录下,执行以下命令</p><pre class=" language-sh"><code class="language-sh">$ mockgen -source=./person/male.go -destination=./mock/male_mock.go -package=mock</code></pre><p>在执行完毕后,可以发现 mock/ 目录下多出了 male_mock.go 文件,这就是 mock 文件.那么命令中的指令又分别有什么用呢？如下：</p><pre><code>-source：设置需要模拟（mock）的接口文件-destination：设置 mock 文件输出的地方,若不设置则打印到标准输出中-package：设置 mock 文件的包名,若不设置则为 mock_ 前缀加上文件名（如本文的包名会为 mock_person）</code></pre><p>想了解更多的指令符,可参见 官方文档: <a href="https://github.com/golang/mock#running-mockgen">https://github.com/golang/mock#running-mockgen</a></p><p><strong>输出的 mock 文件</strong></p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Code generated by MockGen. DO NOT EDIT.</span><span class="token comment" spellcheck="true">// Source: ./person/male.go</span><span class="token comment" spellcheck="true">// Package mock is a generated GoMock package.</span><span class="token keyword">package</span> mock<span class="token keyword">import</span> <span class="token punctuation">(</span>    gomock <span class="token string">"github.com/golang/mock/gomock"</span>    reflect <span class="token string">"reflect"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// MockMale is a mock of Male interface</span><span class="token keyword">type</span> MockMale <span class="token keyword">struct</span> <span class="token punctuation">{</span>    ctrl     <span class="token operator">*</span>gomock<span class="token punctuation">.</span>Controller    recorder <span class="token operator">*</span>MockMaleMockRecorder<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// MockMaleMockRecorder is the mock recorder for MockMale</span><span class="token keyword">type</span> MockMaleMockRecorder <span class="token keyword">struct</span> <span class="token punctuation">{</span>    mock <span class="token operator">*</span>MockMale<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// NewMockMale creates a new mock instance</span><span class="token keyword">func</span> <span class="token function">NewMockMale</span><span class="token punctuation">(</span>ctrl <span class="token operator">*</span>gomock<span class="token punctuation">.</span>Controller<span class="token punctuation">)</span> <span class="token operator">*</span>MockMale <span class="token punctuation">{</span>    mock <span class="token operator">:=</span> <span class="token operator">&amp;</span>MockMale<span class="token punctuation">{</span>ctrl<span class="token punctuation">:</span> ctrl<span class="token punctuation">}</span>    mock<span class="token punctuation">.</span>recorder <span class="token operator">=</span> <span class="token operator">&amp;</span>MockMaleMockRecorder<span class="token punctuation">{</span>mock<span class="token punctuation">}</span>    <span class="token keyword">return</span> mock<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// EXPECT returns an object that allows the caller to indicate expected use</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>MockMale<span class="token punctuation">)</span> <span class="token function">EXPECT</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>MockMaleMockRecorder <span class="token punctuation">{</span>    <span class="token keyword">return</span> m<span class="token punctuation">.</span>recorder<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Get mocks base method</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>MockMale<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>id <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    ret <span class="token operator">:=</span> m<span class="token punctuation">.</span>ctrl<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token string">"Get"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span>    ret0<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> ret<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">error</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> ret0<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Get indicates an expected call of Get</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mr <span class="token operator">*</span>MockMaleMockRecorder<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>id <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">*</span>gomock<span class="token punctuation">.</span>Call <span class="token punctuation">{</span>    <span class="token keyword">return</span> mr<span class="token punctuation">.</span>mock<span class="token punctuation">.</span>ctrl<span class="token punctuation">.</span><span class="token function">RecordCallWithMethodType</span><span class="token punctuation">(</span>mr<span class="token punctuation">.</span>mock<span class="token punctuation">,</span> <span class="token string">"Get"</span><span class="token punctuation">,</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>MockMale<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Get<span class="token punctuation">)</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><strong>4. 测试用例</strong></p><p>打开 user/user_test.go 文件,写入以下内容：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> user<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"testing"</span>    <span class="token string">"github.com/EDDYCJY/mockd/mock"</span>    <span class="token string">"github.com/golang/mock/gomock"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">TestUser_GetUserInfo</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ctl <span class="token operator">:=</span> gomock<span class="token punctuation">.</span><span class="token function">NewController</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>    <span class="token keyword">defer</span> ctl<span class="token punctuation">.</span><span class="token function">Finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> id <span class="token builtin">int64</span> <span class="token operator">=</span> <span class="token number">1</span>    mockMale <span class="token operator">:=</span> mock<span class="token punctuation">.</span><span class="token function">NewMockMale</span><span class="token punctuation">(</span>ctl<span class="token punctuation">)</span>    gomock<span class="token punctuation">.</span><span class="token function">InOrder</span><span class="token punctuation">(</span>        mockMale<span class="token punctuation">.</span><span class="token function">EXPECT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Return</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span>    user <span class="token operator">:=</span> <span class="token function">NewUser</span><span class="token punctuation">(</span>mockMale<span class="token punctuation">)</span>    err <span class="token operator">:=</span> user<span class="token punctuation">.</span><span class="token function">GetUserInfo</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"user.GetUserInfo err: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol><li><p>gomock.NewController：返回 gomock.Controller,它代表 mock 生态系统中的顶级控件.定义了 mock 对象的范围,生命周期和期待值.另外它在多个 goroutine 中是安全的</p></li><li><p>mock.NewMockMale：创建一个新的 mock 实例</p></li><li><p>gomock.InOrder：声明给定的调用应按顺序进行（是对 gomock.After 的二次封装）</p></li><li><p>mockMale.EXPECT().Get(id).Return(nil)：这里有三个步骤,EXPECT()返回一个允许调用者设置期望和返回值的对象.Get(id) 是设置入参并调用 mock 实例中的方法.Return(nil) 是设置先前调用的方法出参.简单来说,就是设置入参并调用,最后设置返回值</p></li><li><p>NewUser(mockMale)：创建 User 实例,值得注意的是,在这里注入了 mock 对象,因此实际在随后的 user.GetUserInfo(id) 调用（入参：id 为 1）中.它调用的是我们事先模拟好的 mock 方法</p></li><li><p>ctl.Finish()：进行 mock 用例的期望值断言,一般会使用 defer 延迟执行,以防止我们忘记这一操作</p></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>回到 mockd/ 的根目录下,执行以下命令</p><pre class=" language-sh"><code class="language-sh">$ go test ./user</code></pre><p>看到这样的结果,就大功告成啦！您可以自己调整一下 Return() 的返回值,以此得到不一样的测试结果哦 </p><ol><li>测试覆盖率</li></ol><pre class=" language-sh"><code class="language-sh">go test -cover ./user</code></pre><p>可通过设置 -cover 标志符来开启覆盖率的统计,展示内容为 coverage: 100.0%.</p><ol start="2"><li>可视化界面</li></ol><p>生成测试覆盖率的 profile 文件</p><pre class=" language-sh"><code class="language-sh">go test ./... -coverprofile=cover.out</code></pre><p>利用 profile 文件生成可视化界面</p><pre class=" language-sh"><code class="language-sh">go tool cover -html=cover.out</code></pre><h2 id="常用-mock-方法"><a href="#常用-mock-方法" class="headerlink" title="常用 mock 方法"></a>常用 mock 方法</h2><ol><li><p>调用方法<br> Call.Do()：声明在匹配时要运行的操作</p><p> Call.DoAndReturn()：声明在匹配调用时要运行的操作,并且模拟返回该函数的返回值</p><p> Call.MaxTimes()：设置最大的调用次数为 n 次</p><p> Call.MinTimes()：设置最小的调用次数为 n 次</p><p> Call.AnyTimes()：允许调用次数为 0 次或更多次</p><p> Call.Times()：设置调用次数为 n 次</p></li><li><p>参数匹配</p><p> gomock.Any()：匹配任意值</p><p> gomock.Eq()：通过反射匹配到指定的类型值,而不需要手动设置<br> gomock.Nil()：返回 nil</p></li></ol><h2 id="生成多个-mock-文件"><a href="#生成多个-mock-文件" class="headerlink" title="生成多个 mock 文件"></a>生成多个 mock 文件</h2><p> 可能会想一条条命令生成 mock 文件,岂不得崩溃？</p><p>当然,官方提供了更方便的方式,我们可以利用 go:generate 来完成批量处理的功能</p><pre class=" language-sh"><code class="language-sh">go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]</code></pre><ol><li>修改 interface 方法</li></ol><p>打开 person/male.go 文件,修改为以下内容：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> person<span class="token comment" spellcheck="true">//go:generate mockgen -destination=../mock/male_mock.go -package=mock github.com/EDDYCJY/mockd/person Male</span><span class="token keyword">type</span> Male <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">Get</span><span class="token punctuation">(</span>id <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token punctuation">}</span></code></pre><p>关注到 go:generate 这条语句,可分为以下部分：</p><ol><li>声明 //go:generate （注意不要留空格）</li><li>使用 mockgen 命令</li><li>定义 -destination</li><li>定义 -package</li><li>定义 source,此处为 person 的包路径</li><li>定义 interfaces,此处为 Male</li></ol><p> <strong>注意:</strong> 上面注释中的mockgen命令因为在调用时其当前目录是person，所以在-destination参数中我们需要指定../mocks/作为mock生成代码的输出目录。</p><p>有了上面的go:generate注释，我们要生成所有mock只需在项目的根目录下运行下面这条命令即可，是不是非常方便？</p><pre class=" language-sh"><code class="language-sh">go generate ./...</code></pre><p><strong>注意:</strong> 注释中的//和go:generate之间不能有空格，这样go generate才可以把注释当做一条命令来处理。</p><p><strong>总结：</strong><br>在单元测试这一环,gomock 给我们提供了极大的便利.能够 mock 掉许许多多的依赖项,其中还有很多的使用方式和功能.您可以 mark 住后详细阅读下官方文档,记忆会更深刻 </p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>semaphore 信号量</title>
      <link href="/2024/07/16/go/package/semaphore/"/>
      <url>/2024/07/16/go/package/semaphore/</url>
      
        <content type="html"><![CDATA[<p>源代码:  golang.org/x/sync/semaphore</p><h1 id="semaphore-信号量"><a href="#semaphore-信号量" class="headerlink" title="semaphore  信号量"></a>semaphore  信号量</h1><p>源代码:  golang.org/x/sync/semaphore</p><ol><li>创建</li></ol><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// NewWeighted使用给定的值创建一个新的加权信号量</span><span class="token comment" spellcheck="true">// 并发访问的最大组合权重。</span><span class="token keyword">func</span> <span class="token function">NewWeighted</span><span class="token punctuation">(</span>n <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token operator">*</span>Weighted <span class="token punctuation">{</span>   w <span class="token operator">:=</span> <span class="token operator">&amp;</span>Weighted<span class="token punctuation">{</span>size<span class="token punctuation">:</span> n<span class="token punctuation">}</span>   <span class="token keyword">return</span> w<span class="token punctuation">}</span></code></pre><p>w 结构</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Weighted provides a way to bound concurrent access to a resource.</span><span class="token comment" spellcheck="true">// The callers can request access with a given weight.</span><span class="token comment" spellcheck="true">// NewWeighted使用给定的值创建一个新的加权信号量</span><span class="token comment" spellcheck="true">// 并发访问的最大组合权重。</span><span class="token keyword">type</span> Weighted <span class="token keyword">struct</span> <span class="token punctuation">{</span>    size    <span class="token builtin">int64</span>  <span class="token comment" spellcheck="true">//权重总数量</span>    cur     <span class="token builtin">int64</span> <span class="token comment" spellcheck="true">//当前权重数量</span>    mu      sync<span class="token punctuation">.</span>Mutex <span class="token comment" spellcheck="true">//全局互斥锁</span>    waiters list<span class="token punctuation">.</span>List <span class="token comment" spellcheck="true">//双向链表,存waiter</span><span class="token punctuation">}</span></code></pre><p>waiter 结构</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> waiter <span class="token keyword">struct</span> <span class="token punctuation">{</span>    n     <span class="token builtin">int64</span> <span class="token comment" spellcheck="true">//需要权重数量</span>    ready <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// Closed when semaphore acquired. //通信channel ,无缓冲</span><span class="token punctuation">}</span></code></pre><p>Acquire 方法:</p><p>阻塞的获取指定权种的资源，如果没有空闲的资源，会进去休眠等待。</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Acquire获取权重为n的信号量，阻塞直到资源可用或ctx完成。</span><span class="token comment" spellcheck="true">// 成功时，返回nil。失败时返回 ctx.Err（）并保持信号量不变。</span><span class="token comment" spellcheck="true">// 如果ctx已经完成，则Acquire仍然可以成功执行而不会阻塞</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Weighted<span class="token punctuation">)</span> <span class="token function">Acquire</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> n <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    s<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// fast path, 如果有足够的资源，都不考虑ctx.Done的状态，将cur加上n就返回</span>    <span class="token keyword">if</span> s<span class="token punctuation">.</span>size<span class="token operator">-</span>s<span class="token punctuation">.</span>cur <span class="token operator">>=</span> n <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span>waiters<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>      s<span class="token punctuation">.</span>cur <span class="token operator">+=</span> n      s<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">// 如果是不可能完成的任务，请求的资源数大于能提供的最大的资源数</span>    <span class="token keyword">if</span> n <span class="token operator">></span> s<span class="token punctuation">.</span>size <span class="token punctuation">{</span>      s<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 依赖ctx的状态返回，否则一直等待</span>      <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> ctx<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">// 否则就需要把调用者加入到等待队列中</span>        <span class="token comment" spellcheck="true">// 创建了一个ready chan,以便被通知唤醒</span>    ready <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 组装waiter</span>    w <span class="token operator">:=</span> waiter<span class="token punctuation">{</span>n<span class="token punctuation">:</span> n<span class="token punctuation">,</span> ready<span class="token punctuation">:</span> ready<span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 插入waiters中</span>    elem <span class="token operator">:=</span> s<span class="token punctuation">.</span>waiters<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span>    s<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// 等待</span>    <span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">// context的Done被关闭</span>      err <span class="token operator">:=</span> ctx<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      s<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">select</span> <span class="token punctuation">{</span>      <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ready<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">// 如果被唤醒了，忽略ctx的状态</span>        err <span class="token operator">=</span> <span class="token boolean">nil</span>      <span class="token keyword">default</span><span class="token punctuation">:</span> 通知waiter        isFront <span class="token operator">:=</span> s<span class="token punctuation">.</span>waiters<span class="token punctuation">.</span><span class="token function">Front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> elem        s<span class="token punctuation">.</span>waiters<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 通知其它的waiters,检查是否有足够的资源</span>        <span class="token keyword">if</span> isFront <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span>size <span class="token operator">></span> s<span class="token punctuation">.</span>cur <span class="token punctuation">{</span>          s<span class="token punctuation">.</span><span class="token function">notifyWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      s<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> err    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ready<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">// 被唤醒了</span>      <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><h4 id="TryAcquire"><a href="#TryAcquire" class="headerlink" title="TryAcquire"></a>TryAcquire</h4><p>非阻塞地获取指定权重的资源，如果当前没有空闲资源，会直接返回<code>false</code>。</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// TryAcquire获取权重为n的信号量而不阻塞。</span><span class="token comment" spellcheck="true">// 成功时返回true。 失败时，返回false并保持信号量不变。</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Weighted<span class="token punctuation">)</span> <span class="token function">TryAcquire</span><span class="token punctuation">(</span>n <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>    s<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    success <span class="token operator">:=</span> s<span class="token punctuation">.</span>size<span class="token operator">-</span>s<span class="token punctuation">.</span>cur <span class="token operator">>=</span> n <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span>waiters<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>    <span class="token keyword">if</span> success <span class="token punctuation">{</span>        s<span class="token punctuation">.</span>cur <span class="token operator">+=</span> n    <span class="token punctuation">}</span>    s<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> success<span class="token punctuation">}</span></code></pre><h4 id="Release-方法"><a href="#Release-方法" class="headerlink" title="Release 方法"></a>Release 方法</h4><p>用于释放指定权重的资源，如果有<code>waiters</code>则尝试去一一唤醒<code>waiter</code>。</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Release释放权值为n的信号量。</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Weighted<span class="token punctuation">)</span> <span class="token function">Release</span><span class="token punctuation">(</span>n <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    s<span class="token punctuation">.</span>cur <span class="token operator">-=</span> n    <span class="token comment" spellcheck="true">// cur的范围在[0 - size]</span>    <span class="token keyword">if</span> s<span class="token punctuation">.</span>cur <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>        s<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"semaphore: bad release"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    s<span class="token punctuation">.</span><span class="token function">notifyWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    s<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Weighted<span class="token punctuation">)</span> <span class="token function">notifyWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果有阻塞的waiters，尝试去进行一一唤醒 </span>    <span class="token comment" spellcheck="true">// 唤醒的时候，先进先出，避免被资源比较大的waiter被饿死</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        next <span class="token operator">:=</span> s<span class="token punctuation">.</span>waiters<span class="token punctuation">.</span><span class="token function">Front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 已经没有waiter了</span>        <span class="token keyword">if</span> next <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span>        <span class="token punctuation">}</span>        w <span class="token operator">:=</span> next<span class="token punctuation">.</span>Value<span class="token punctuation">.</span><span class="token punctuation">(</span>waiter<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// waiter需要的资源不足</span>        <span class="token keyword">if</span> s<span class="token punctuation">.</span>size<span class="token operator">-</span>s<span class="token punctuation">.</span>cur <span class="token operator">&lt;</span> w<span class="token punctuation">.</span>n <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 没有足够的令牌供下一个waiter使用。我们可以继续（尝试</span>            <span class="token comment" spellcheck="true">// 查找请求较小的waiter），但在负载下可能会导致</span>            <span class="token comment" spellcheck="true">// 饥饿的大型请求；相反，我们留下所有剩余的waiter阻塞</span>            <span class="token comment" spellcheck="true">//</span>            <span class="token comment" spellcheck="true">// 考虑一个用作读写锁的信号量，带有N个令牌，N个reader和一位writer</span>            <span class="token comment" spellcheck="true">// 每个reader都可以通过Acquire（1）获取读锁。</span>            <span class="token comment" spellcheck="true">// writer写入可以通过Acquire（N）获得写锁定，但不包括所有的reader。</span>            <span class="token comment" spellcheck="true">// 如果我们允许读者在队列中前进，writer将会饿死-总是有一个令牌可供每个读者。</span>            <span class="token keyword">break</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span>cur <span class="token operator">+=</span> w<span class="token punctuation">.</span>n        s<span class="token punctuation">.</span>waiters<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span>        <span class="token function">close</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>ready<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>notifyWaiters 方法</p><p>在<code>Acquire</code>和<code>Release</code>方法中都调用了<code>notifyWaiters</code></p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Weighted<span class="token punctuation">)</span> <span class="token function">notifyWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">for</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 获取等待调用者队列中的队员</span>  next <span class="token operator">:=</span> s<span class="token punctuation">.</span>waiters<span class="token punctuation">.</span><span class="token function">Front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 没有要通知的调用者了</span>  <span class="token keyword">if</span> next <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>   <span class="token keyword">break</span> <span class="token comment" spellcheck="true">// No more waiters blocked.</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 断言出waiter信息</span>  w <span class="token operator">:=</span> next<span class="token punctuation">.</span>Value<span class="token punctuation">.</span><span class="token punctuation">(</span>waiter<span class="token punctuation">)</span>  <span class="token keyword">if</span> s<span class="token punctuation">.</span>size<span class="token operator">-</span>s<span class="token punctuation">.</span>cur <span class="token operator">&lt;</span> w<span class="token punctuation">.</span>n <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 没有足够资源为下一个调用者使用时，继续阻塞该调用者，遵循先进先出的原则，</span>   <span class="token comment" spellcheck="true">// 避免需要资源数比较大的waiter被饿死</span>   <span class="token comment" spellcheck="true">//</span>   <span class="token comment" spellcheck="true">// 考虑一个场景，使用信号量作为读写锁，现有N个令牌，N个reader和一个writer</span>   <span class="token comment" spellcheck="true">// 每个reader都可以通过Acquire（1）获取读锁，writer写入可以通过Acquire（N）获得写锁定</span>   <span class="token comment" spellcheck="true">// 但不包括所有的reader，如果我们允许reader在队列中前进，writer将会饿死-总是有一个令牌可供每个reader</span>   <span class="token keyword">break</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 获取资源</span>  s<span class="token punctuation">.</span>cur <span class="token operator">+=</span> w<span class="token punctuation">.</span>n  <span class="token comment" spellcheck="true">// 从waiter列表中移除</span>  s<span class="token punctuation">.</span>waiters<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 使用channel的close机制唤醒waiter</span>  <span class="token function">close</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>ready<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>需要注意一个点：唤醒<code>waiter</code>采用先进先出的原则，避免需要资源数比较大的waiter被饿死。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>llama 安装</title>
      <link href="/2024/07/16/llama/llama-install/"/>
      <url>/2024/07/16/llama/llama-install/</url>
      
        <content type="html"><![CDATA[<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> add-apt-repository ppa:deadsnakes/ppa<span class="token function">sudo</span> apt update<span class="token function">sudo</span> apt <span class="token function">install</span> python3.11 python3.11-venv -y</code></pre><p>安装虚拟环境</p><pre class=" language-bash"><code class="language-bash">/usr/bin/python3.11 -m venv venv</code></pre><p>使用虚拟</p><pre class=" language-bash"><code class="language-bash"><span class="token function">source</span> venv/bin/activate<span class="token comment" spellcheck="true"># 如果使用的 fish</span><span class="token function">source</span> venv/bin/activate.fish</code></pre><p>安装 Install PyTorch:</p><pre class=" language-bash"><code class="language-bash"> pip <span class="token function">install</span> --pre torch torchvision --extra-index-url https://download.pytorch.org/whl/nightly/cpu</code></pre><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>1. 下载 llama.cp</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/ggerganov/llama.cpp.git </code></pre><ol><li>下载通义千问1.5-7B模型 或 1.5-32B 模型&amp;#x20;</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 使用 huggingface 仓库</span><span class="token function">git</span> clone https://huggingface.co/Qwen/Qwen1.5-7B-Chat<span class="token comment" spellcheck="true"># 或</span><span class="token function">git</span> clone https://huggingface.co/qwen/Qwen1.5-32B-Chat.git<span class="token comment" spellcheck="true"># 使用 modelscope 仓库</span><span class="token function">git</span> clone https://www.modelscope.cn/Qwen/Qwen1.5-7B-Chat<span class="token comment" spellcheck="true"># 或</span><span class="token function">git</span> clone https://www.modelscope.cn/qwen/Qwen1.5-32B-Chat.git</code></pre><h2 id="编译-llama-cp"><a href="#编译-llama-cp" class="headerlink" title="编译 llama.cp"></a>编译 llama.cp</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> llama.cpp <span class="token function">make</span></code></pre><h3 id="安装llama-依赖"><a href="#安装llama-依赖" class="headerlink" title="安装llama 依赖"></a>安装llama 依赖</h3><pre class=" language-bash"><code class="language-bash">python3 -m  pip <span class="token function">install</span> -r requirements.txt</code></pre><h3 id="转换-Qwen-模型为-GGUF"><a href="#转换-Qwen-模型为-GGUF" class="headerlink" title="转换 Qwen 模型为 GGUF"></a>转换 Qwen 模型为 GGUF</h3><p>什么是 GGUF? GGUF是一种用于存储用于GGML推断和基于GGML的执行器的模型的文件格式。GGUF是一种二进制格式，旨在快速加载和保存模型，并易于阅读。传统上，模型是使用PyTorch或其他框架开发的，然后转换为GGUF以在GGML中使用。</p><p>GGUF是GGML、GGMF和GGJT的后继文件格式，旨在通过包含加载模型所需的所有信息来消除歧义。它还设计为可扩展的，因此可以向模型添加新信息而不会破坏兼容性，更多信息访问<a href="https://github.com/ggerganov/ggml/blob/master/docs/gguf.md" title="官方说明文档">官方说明文档</a>。</p><p>查看文件结构</p><pre class=" language-bash"><code class="language-bash">$ tree -L 1<span class="token keyword">.</span>├── llama.cpp  ├── Qwen1.5-32B-Chat└── venv</code></pre><p>执行这转换命令</p><pre class=" language-bash"><code class="language-bash">python3 convert-hf-to-gguf.py  <span class="token punctuation">..</span>/Qwen1.5-32B-Chat<span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">..</span><span class="token punctuation">..</span>.INFO:hf-to-gguf:Model successfully exported to <span class="token string">'../Qwen1.5-32B-Chat/ggml-model-f16.gguf'</span></code></pre><p>最后的结果表示已经转为 F16 的 gguf 格式的模型了</p><h3 id="量化模型"><a href="#量化模型" class="headerlink" title="量化模型"></a>量化模型</h3><p>将gguf 的模型量化到INT4&amp;#x20;</p><pre class=" language-bash"><code class="language-bash">./llama-quantize  <span class="token punctuation">..</span>/Qwen1.5-32B-Chat/ggml-model-f16.gguf  ./models/qwen1.5-chat-ggml-model-Q4_K_M.gguf Q4_K_M<span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">[</span> 767/ 771<span class="token punctuation">]</span>                   blk.63.attn_q.bias - <span class="token punctuation">[</span> 5120,     1,     1,     1<span class="token punctuation">]</span>, <span class="token function">type</span> <span class="token operator">=</span>    f32, size <span class="token operator">=</span>    0.020 MB<span class="token punctuation">[</span> 768/ 771<span class="token punctuation">]</span>                 blk.63.attn_q.weight - <span class="token punctuation">[</span> 5120,  5120,     1,     1<span class="token punctuation">]</span>, <span class="token function">type</span> <span class="token operator">=</span>    f16, converting to q4_K <span class="token punctuation">..</span> size <span class="token operator">=</span>    50.00 MiB -<span class="token operator">></span>    14.06 MiB<span class="token punctuation">[</span> 769/ 771<span class="token punctuation">]</span>                   blk.63.attn_v.bias - <span class="token punctuation">[</span> 1024,     1,     1,     1<span class="token punctuation">]</span>, <span class="token function">type</span> <span class="token operator">=</span>    f32, size <span class="token operator">=</span>    0.004 MB<span class="token punctuation">[</span> 770/ 771<span class="token punctuation">]</span>                 blk.63.attn_v.weight - <span class="token punctuation">[</span> 5120,  1024,     1,     1<span class="token punctuation">]</span>, <span class="token function">type</span> <span class="token operator">=</span>    f16, converting to q6_K <span class="token punctuation">..</span> size <span class="token operator">=</span>    10.00 MiB -<span class="token operator">></span>     4.10 MiB<span class="token punctuation">[</span> 771/ 771<span class="token punctuation">]</span>                   output_norm.weight - <span class="token punctuation">[</span> 5120,     1,     1,     1<span class="token punctuation">]</span>, <span class="token function">type</span> <span class="token operator">=</span>    f32, size <span class="token operator">=</span>    0.020 MBllama_model_quantize_internal: model size  <span class="token operator">=</span> 62014.27 MBllama_model_quantize_internal: quant size  <span class="token operator">=</span> 18780.70 MBmain: quantize <span class="token function">time</span> <span class="token operator">=</span> 421046.36 msmain:    total <span class="token function">time</span> <span class="token operator">=</span> 421046.36 ms</code></pre><p>../Qwen1.5-32B-Chat/ggml-model-f16.gguf   是转换的源文件路径</p><p>./models/qwen1.5-chat-ggml-model-Q4_K_M.gguf   是转换成功生成的文件路径</p><p>Q4_K_M 是量化方法</p><p>新版量化方法包括：</p><ul><li>Q2_K</li><li>Q3_K_S, Q3_K_M, Q3_K_L</li><li>Q4_K_S, Q4_K_M</li><li>Q5_K_S, Q5_K_M</li><li>Q6_K</li></ul><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><pre class=" language-bash"><code class="language-bash">./llama-cli -m ./models/qwen1.5-chat-ggml-model-Q4_K_M.gguf -n 128<span class="token operator">=</span><span class="token operator">></span> 1<span class="token punctuation">)</span> 甲乙丙丁四地中，最可能出现水土流失的是A. 甲B0 乙C0 丙D0 丁答案：C关键点：中国分区地理，水土流失及治理，区域农业生产的条件、布局特点、问题llama_print_timings:        load <span class="token function">time</span> <span class="token operator">=</span>   17027.80 msllama_print_timings:      sample <span class="token function">time</span> <span class="token operator">=</span>      22.98 ms /   128 runs   <span class="token punctuation">(</span>    0.18 ms per token,  5571.27 tokens per second<span class="token punctuation">)</span>llama_print_timings: prompt <span class="token function">eval</span> <span class="token function">time</span> <span class="token operator">=</span>       0.00 ms /     0 tokens <span class="token punctuation">(</span>    -nan ms per token,     -nan tokens per second<span class="token punctuation">)</span>llama_print_timings:        <span class="token function">eval</span> <span class="token function">time</span> <span class="token operator">=</span>  867086.12 ms /   128 runs   <span class="token punctuation">(</span> 6774.11 ms per token,     0.15 tokens per second<span class="token punctuation">)</span>llama_print_timings:       total <span class="token function">time</span> <span class="token operator">=</span>  867381.32 ms /   128 tokensLog end</code></pre><p>注意： 这个运行等待的时间比较长</p><p>接下来我们进入对话模型。如何启动呢？我们这里查看 examples/chat.sh的启动方式，来编写启动 Qwen 模型命令。</p><pre class=" language-bash"><code class="language-bash">./llama-cli -m ./models/qwen1.5-chat-ggml-model-Q4_K_M.gguf  -n 256 --grammar-file grammars/json.gbnf -p <span class="token string">'Request: schedule a call at 8pm; Command:'</span></code></pre><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><ol><li>通义千问safetensors_rust.SafetensorError: Error while deserializing header: HeaderTooLarge解决方法</li></ol><p>安装 gi-lfs</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> git-lfs</code></pre><p>进入 Qwen1.5-32B-Chat  执行 git lfs pull</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> Qwen1.5-32B-Chat <span class="token operator">&amp;&amp;</span> <span class="token function">git</span> lfs pull</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> llama </tag>
            
            <tag> ggml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 网络工具 netstat</title>
      <link href="/2024/07/16/linux/netstat/"/>
      <url>/2024/07/16/linux/netstat/</url>
      
        <content type="html"><![CDATA[<h1 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h1><h2 id="1-netstat-命令"><a href="#1-netstat-命令" class="headerlink" title="1. netstat 命令"></a>1. netstat 命令</h2><p>netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre class=" language-sh"><code class="language-sh">netstat [-acCeFghilMnNoprstuvVwx][-A<网络类型>][--ip]</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><pre class=" language-sh"><code class="language-sh">-a或--all 显示所有连线中的Socket。-A<网络类型>或--<网络类型> 列出该网络类型连线中的相关地址。-c或--continuous 持续列出网络状态。-C或--cache 显示路由器配置的快取信息。-e或--extend 显示网络其他相关信息。-F或--fib 显示路由缓存。-g或--groups 显示多重广播功能群组组员名单。-h或--help 在线帮助。-i或--interfaces 显示网络界面信息表单。-l或--listening 显示监控中的服务器的Socket。-M或--masquerade 显示伪装的网络连线。-n或--numeric 直接使用IP地址，而不通过域名服务器。-N或--netlink或--symbolic 显示网络硬件外围设备的符号连接名称。-o或--timers 显示计时器。-p或--programs 显示正在使用Socket的程序识别码和程序名称。-r或--route 显示Routing Table。-s或--statistics 显示网络工作信息统计表。-t或--tcp 显示TCP传输协议的连线状况。-u或--udp 显示UDP传输协议的连线状况。-v或--verbose 显示指令执行过程。-V或--version 显示版本信息。-w或--raw 显示RAW传输协议的连线状况。-x或--unix 此参数的效果和指定"-A unix"参数相同。--ip或--inet 此参数的效果和指定"-A inet"参数相同。</code></pre><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="1-显示网络状态"><a href="#1-显示网络状态" class="headerlink" title="1. 显示网络状态"></a>1. 显示网络状态</h4><pre class=" language-sh"><code class="language-sh">netstat -a</code></pre><p>结果：</p><pre class=" language-sh"><code class="language-sh">Proto Recv-Q Send-Q Local Address           Foreign Address         Statetcp        0      0 192.168.122.1:domain    0.0.0.0:*               LISTENtcp        0      0 localhost:ipp           0.0.0.0:*               LISTENtcp        0      0 localhost:35600         0.0.0.0:*               LISTENtcp        0      0 127.0.0.54:domain       0.0.0.0:*               LISTENtcp        0      0 localhost:31080         0.0.0.0:*               LISTENtcp        0      0 localhost:31055         0.0.0.0:*               LISTENtcp        0      0 hellotalk:domain        0.0.0.0:*               LISTENtcp        0      0 127.0.0.53:domain       0.0.0.0:*               LISTENtcp        0      0 172.16.0.112:50006      113.240.72.111:https    TIME_WAITtcp        0      0 10.100.100.164:56010    10.40.2.11:27017        ESTABLISHEDtcp        0      0 10.100.100.164:43846    10.40.2.5:27017         ESTABLISHED</code></pre><p>字段说明：</p><p>1.Proto：传输层协议 TCP 或 UDP</p><p>2.Recv-Q：接收队列</p><p>3.Send-Q：发送队列</p><p>4.Local Address：本地地址</p><p>5.Foreign Address：远程地址</p><p>6.State：状态 LISTEN：侦听，ESTABLISHED：已建立，TIME_WAIT：关闭</p><h4 id="2-显示当前户籍-UDP-连接状况"><a href="#2-显示当前户籍-UDP-连接状况" class="headerlink" title="2. 显示当前户籍 UDP 连接状况"></a>2. 显示当前户籍 UDP 连接状况</h4><pre class=" language-sh"><code class="language-sh">netstat -nu</code></pre><p>结果：</p><pre class=" language-sh"><code class="language-sh">激活Internet连接 (w/o 服务器)Proto Recv-Q Send-Q Local Address           Foreign Address         Stateudp        0      0 127.0.0.1:56871         127.0.1.1:53            ESTABLISHEDudp        0      0 172.16.0.112:42799      106.38.222.156:443      ESTABLISHEDudp        0      0 172.16.0.112:68         172.16.0.1:67           ESTABLISHED</code></pre><h4 id="3-显示当前户籍-TCP-连接状况"><a href="#3-显示当前户籍-TCP-连接状况" class="headerlink" title="3. 显示当前户籍 TCP 连接状况"></a>3. 显示当前户籍 TCP 连接状况</h4><pre class=" language-sh"><code class="language-sh">netstat -nt</code></pre><p>结果：</p><pre class=" language-sh"><code class="language-sh">激活Internet连接 (w/o 服务器)Proto Recv-Q Send-Q Local Address           Foreign Address         Statetcp        0      0 10.100.100.164:56010    10.40.2.11:27017        ESTABLISHEDtcp        0      0 10.100.100.164:43846    10.40.2.5:27017         ESTABLISHEDtcp        0      0 172.16.0.112:60087      43.159.193.150:8002     TIME_WAITtcp        0      0 172.16.0.112:57712      113.240.72.99:443       TIME_WAITtcp        0      0 10.100.100.164:55986    10.40.2.11:27017        ESTABLISHEDtcp        0      0 10.100.100.164:43722    10.40.2.5:27017         ESTABLISHED</code></pre><h4 id="4-显示当前系统中所有正在监听的-TCP-端口、相关的进程以及其状态"><a href="#4-显示当前系统中所有正在监听的-TCP-端口、相关的进程以及其状态" class="headerlink" title="4. 显示当前系统中所有正在监听的 TCP 端口、相关的进程以及其状态"></a>4. 显示当前系统中所有正在监听的 TCP 端口、相关的进程以及其状态</h4><pre class=" language-sh"><code class="language-sh">netstat -ntlp</code></pre><p>结果：</p><pre class=" language-sh"><code class="language-sh">Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program nametcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      1234/nginxtcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN      2345/mysqldtcp6       0      0 :::22                   :::*                    LISTEN      3456/sshd</code></pre><p>字段解析：</p><ol><li><p>Proto：协议</p><ul><li>tcp：表示 TCP 协议。</li><li>tcp6：表示 IPv6 的 TCP 协议。</li></ul></li><li><p>Recv-Q 和 Send-Q：</p><ul><li>Recv-Q：表示接收队列</li><li>Send-Q：表示发送队列</li></ul></li><li><p>Local Address：本地地址</p><ul><li>0.0.0.0:80：本地地址和端口号，0.0.0.0 表示监听所有接口的 IP 地址，80 是端口号。</li><li>127.0.0.1:3306：本地环回地址（localhost）上的端口 3306。</li><li>:::22：IPv6 地址的端口 22。</li></ul></li><li><p>Foreign Address：远程地址</p><ul><li>0.0.0.0:* 和 :::*：表示监听所有外部地址。</li></ul></li><li><p>State：状态</p><ul><li>LISTEN：表示服务器正在监听 TCP 连接请求。</li><li>ESTABLISHED：表示连接已经建立。</li><li>TIME_WAIT：表示主动关闭连接的一方在关闭连接后，等待 2MSL 后依然没有收到对方的 FIN 报文，处于等待关闭状态。</li><li>CLOSE_WAIT：表示被动关闭连接的一方在收到对方的 FIN 报文后，等待应用进程关闭连接。</li><li>LAST_ACK：表示被动关闭连接的一方在发送完 FIN 报文后，等待对方的 ACK 报文，如果收到 ACK 报文，则处于 CLOSED 状态，否则处于 TIME_WAIT 状态。</li><li>CLOSED：表示连接已经关闭。</li><li>SYN_RECV：表示正在等待处理的请求数目。</li><li>SYN_SENT：表示正在等待远程连接请求。</li><li>CLOSING：表示正在等待远程连接关闭请求。</li><li>UNKNOWN：表示未知状态。</li><li>LISTENING：表示正在等待远程连接请求。</li><li>IDLE：表示连接处于空闲状态。</li><li>BOUND：表示正在等待远程连接请求。</li><li>FIN_WAIT1: 套接字已经发出了一个 FIN 请求，表示它已经完成了发送数据，正在等待对方的 ACK 响应。</li><li>FIN_WAIT2: 套接字收到了对 FIN 请求的 ACK 响应，正在等待对方发出 FIN 请求。</li></ul></li><li><p>PID/Program name：进程 ID 和进程名称</p><ul><li>1234/nginx：进程 ID 为 1234 的 nginx 进程正在监听 80 端口。</li><li>2345/mysqld：进程 ID 为 2345 的 mysqld 进程正在监听 3306 端口。</li><li>3456/sshd：进程 ID 为 3456 的 sshd 进程正在监听 22 端口。</li></ul></li></ol><h4 id="5-显示网卡列表"><a href="#5-显示网卡列表" class="headerlink" title="5. 显示网卡列表"></a>5. 显示网卡列表</h4><pre class=" language-sh"><code class="language-sh"> netstat -i</code></pre><p>结果：</p><pre class=" language-sh"><code class="language-sh">Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flgbr-717e070443f8  1500        0      0      0 0             0      0      0      0 BMUbr-7f56e5476213  1500        0      0      0 0             0      0      0      0 BMUdocker0          1500        0      0      0 0             0      0      0      0 BMUeno1             1500  3838424      0      0 0       3615697      0      0      0 BMRUlo              65536  1115368      0      0 0       1115368      0      0      0 LRUutun             1400  2667684      0      0 0       2598307      0      0      0 MOPRUvirbr0           1500        0      0      0 0             0      0      0      0 BMU</code></pre><p>字段解析：</p><ol><li>Iface：网卡名称</li><li>MTU：最大传输单元</li><li>RX-OK：接收数据包总数</li><li>RX-ERR：接收数据包错误总数</li><li>RX-DRP：接收数据包丢弃总数</li><li>RX-OVR：接收数据包溢出总数</li><li>TX-OK：发送数据包总数</li><li>TX-ERR：发送数据包错误总数</li><li>TX-DRP：发送数据包丢弃总数</li><li>TX-OVR：发送数据包溢出总数</li><li>Flg：标志</li></ol><ul><li>BMU：广播地址</li><li>BMRU：广播地址和多播地址</li><li>MOPRU：多播地址</li><li>LRU：本地地址</li><li>MPRU：多播地址和本地地址</li><li>OPRU：多播地址和本地地址和广播地址</li><li>ALL：所有地址</li></ul><p>###＃ 6. 显示组播组的关系</p><pre class=" language-sh"><code class="language-sh">netstat -g</code></pre><p>结果：</p><pre class=" language-sh"><code class="language-sh">IPv6/IPv4 Group MembershipsInterface       RefCnt Group--------------- ------ ---------------------lo              1      mdns.mcast.netlo              1      all-systems.mcast.net</code></pre><p>字段解析：</p><ol><li>Interface：网卡名称</li><li>RefCnt：引用计数</li><li>Group：组播组</li></ol><p>###＃ 7. 显示网络统计信息</p><pre class=" language-sh"><code class="language-sh">netstat -s</code></pre><p>结果：</p><pre class=" language-sh"><code class="language-sh">Ip:    Forwarding: 1    7269919 total packets received    0 forwarded    0 incoming packets discarded    7265662 incoming packets delivered    7078118 requests sent out    28 outgoing packets dropped    7895 dropped because of missing route    8416 reassemblies required    4208 packets reassembled ok    6 outgoing packets failed fragmentation    OutTransmits: 7078115Icmp:    2022 ICMP messages received    6 input ICMP message failed    ICMP接收历史        destination unreachable: 2020        echo requests: 2    2176 ICMP messages sent    0 ICMP messages failed    OutRateLimitHost: 253    ICMP发出历史        destination unreachable: 2174        echo replies: 2IcmpMsg:        InType3: 2020        InType8: 2        OutType0: 2        OutType3: 2174Tcp:    202192 active connection openings    10375 passive connection openings    120686 failed connection attempts    3047 connection resets received    77 connections established    6857878 segments received    7083293 segments sent out    16799 segments retransmitted    1119 bad segments received    131681 resets sentUdp:    1456958 packets received    2421 packets to unknown port received    32 packet receive errors    556388 packets sent    0 receive buffer errors    8 send buffer errors    InCsumErrors: 32    IgnoredMulti: 12191UdpLite:TcpExt:    3 ICMP packets dropped because they were out-of-window    30122 TCP sockets finished time wait in fast timer    1 packets rejected in established connections because of timestamp    119999 delayed acks sent    39 delayed acks further delayed because of locked socket    Quick ack mode was activated 34511 times    1065795 packet headers predicted    687289 acknowledgments not containing data payload received    1455607 predicted acknowledgments    TCPSackRecovery: 327    Detected reordering 676 times using SACK    TCPDSACKUndo: 97    87 congestion windows recovered without slow start after partial ack    TCPLostRetransmit: 8875    TCPSackFailures: 8    3 timeouts in loss state    466 fast retransmits    133 retransmits in slow start    TCPTimeouts: 11823    TCPLossProbes: 5420    TCPLossProbeRecovery: 82    TCPSackRecoveryFail: 10    TCPBacklogCoalesce: 2369    TCPDSACKOldSent: 34608    TCPDSACKOfoSent: 51    TCPDSACKRecv: 1827    TCPDSACKOfoRecv: 16    1537 connections reset due to unexpected data    2171 connections reset due to early user close    484 connections aborted due to timeout    10 times unable to send RST due to no memory    TCPSACKDiscard: 2    TCPDSACKIgnoredOld: 7    TCPDSACKIgnoredNoUndo: 815    TCPSackShifted: 26    TCPSackMerged: 342    TCPSackShiftFallback: 1984    IPReversePathFilter: 22    TCPRcvCoalesce: 203651    TCPOFOQueue: 50737    TCPOFOMerge: 54    TCPChallengeACK: 879    TCPSYNChallenge: 1140    TCPSpuriousRtxHostQueues: 18    TCPAutoCorking: 458417    TCPFromZeroWindowAdv: 35    TCPToZeroWindowAdv: 35    TCPWantZeroWindowAdv: 167    TCPSynRetrans: 7312    TCPOrigDataSent: 3398432    TCPHystartTrainDetect: 22    TCPHystartTrainCwnd: 1073    TCPHystartDelayDetect: 42    TCPHystartDelayCwnd: 1831    TCPACKSkippedSeq: 286    TCPACKSkippedChallenge: 265    TCPKeepAlive: 97079    TCPDelivered: 3475194    TCPAckCompressed: 14499    TcpTimeoutRehash: 11471    TCPDSACKRecvSegs: 1841    TCPDSACKIgnoredDubious: 2IpExt:    InNoRoutes: 17    InMcastPkts: 118643    OutMcastPkts: 8410    InBcastPkts: 17704    OutBcastPkts: 1960    InOctets: 3807905209    OutOctets: 1523626052    InMcastOctets: 53391437    OutMcastOctets: 1586713    InBcastOctets: 9013152    OutBcastOctets: 152880    InNoECTPkts: 7512863    InECT0Pkts: 18MPTcpExt:</code></pre><h4 id="显示监听的套接口"><a href="#显示监听的套接口" class="headerlink" title="显示监听的套接口"></a>显示监听的套接口</h4><pre class=" language-sh"><code class="language-sh">netstat -l</code></pre><pre class=" language-sh"><code class="language-sh">激活Internet连接 (仅服务器)Proto Recv-Q Send-Q Local Address           Foreign Address         State      tcp        0      0 hellotalk:domain        0.0.0.0:*               LISTEN     tcp6       0      0 [::]:3100               [::]:*                  LISTEN     udp        0      0 0.0.0.0:45010           0.0.0.0:*                                            udp        0      0 0.0.0.0:mdns            0.0.0.0:*                          udp6       0      0 [::]:49287              [::]:*                                           7          活跃的UNIX域套接字 (仅服务器)Proto RefCnt Flags       Type       State         I-Node   路径unix  2      [ ACC ]     流        LISTENING     1010159  /tmp/.java_pid169241.tmp</code></pre><p>字段解析：</p><ul><li>Proto：协议名，如tcp、udp、unix等</li><li>Recv-Q：接收队列，即收到的但未处理的数据包数</li><li>Send-Q：发送队列，即发送但未确认的数据包数</li><li>Local Address：本地地址</li><li>Foreign Address：远程地址</li><li>State：套接字状态，如LISTEN、ESTABLISHED等</li><li>I-Node：套接字inode号</li><li>路径：unix域套接字路径</li><li>RefCnt：引用计数</li><li>Flags：套接字标志，如S表示套接字是被动打开的，即服务器端，而A表示套接字是主动打开的，即客户端</li><li>Type：套接字类型，如流套接字、数据报套接字等</li><li>路径：unix域套接字路径</li></ul><h4 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h4><pre class=" language-sh"><code class="language-sh">netstat -r</code></pre><pre class=" language-sh"><code class="language-sh">内核 IP 路由表Destination     Gateway         Genmask         Flags   MSS Window  irtt Ifacedefault         172.16.0.1      0.0.0.0         UG        0 0          0 eno1one.one.one.one 0.0.0.0         255.255.255.255 UH        0 0          0 utun10.10.0.0       0.0.0.0         255.255.0.0     U         0 0          0 utun10.40.0.0       0.0.0.0         255.255.0.0     U         0 0          0 utun10.100.100.0    0.0.0.0         255.255.255.0   U         0 0          0 utun30.100.0.0      0.0.0.0         255.252.0.0     U         0 0          0 utunfeilian.hellota 172.16.0.1      255.255.255.255 UGH       0 0          0 eno1link-local      0.0.0.0         255.255.0.0     U         0 0          0 utun172.16.0.0      0.0.0.0         255.255.254.0   U         0 0          0 eno1172.16.6.20     172.16.0.1      255.255.255.255 UGH       0 0          0 eno1172.17.0.0      0.0.0.0         255.255.0.0     U         0 0          0 docker0192.168.49.0    0.0.0.0         255.255.255.0   U         0 0          0 br-717e070443f8192.168.58.0    0.0.0.0         255.255.255.0   U         0 0          0 br-7f56e5476213192.168.122.0   0.0.0.0         255.255.255.0   U         0 0          0 virbr0</code></pre><p>字段解析：</p><ul><li>Destination：目的网络或目的主机</li><li>Gateway：指定用于转发包的网关。</li><li>Genmask：子网掩码</li><li>Flags：路由标志，如U表示路由是活动的，H表示目的地址是一个主机，G表示使用网关</li><li>MSS：最大分段大小</li><li>Window：TCP窗口大小</li><li>irtt：初始RTT</li><li>Iface：路由接口</li></ul><h4 id="只列出监听中的连接"><a href="#只列出监听中的连接" class="headerlink" title="只列出监听中的连接"></a>只列出监听中的连接</h4><pre class=" language-sh"><code class="language-sh">netstat -tnl</code></pre><pre class=" language-sh"><code class="language-sh">激活Internet连接 (仅服务器)Proto Recv-Q Send-Q Local Address           Foreign Address         State      tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN     tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN     tcp        0      0 127.0.0.1:35600         0.0.0.0:*               LISTEN     tcp        0      0 127.0.0.54:53           0.0.0.0:*               LISTEN     tcp        0      0 127.0.0.1:31080         0.0.0.0:*               LISTEN     tcp        0      0 127.0.0.1:31055         0.0.0.0:*               LISTEN     tcp        0      0 127.0.1.1:53            0.0.0.0:*               LISTEN     tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN     tcp6       0      0 :::41499                :::*                    LISTEN     tcp6       0      0 127.0.0.1:52829         :::*                    LISTEN     tcp6       0      0 127.0.0.1:35955         :::*                    LISTEN     tcp6       0      0 127.0.0.1:63343         :::*                    LISTEN     tcp6       0      0 127.0.0.1:63342         :::*                    LISTEN     </code></pre><h4 id="获取进程名、进程号以及用户-ID"><a href="#获取进程名、进程号以及用户-ID" class="headerlink" title="获取进程名、进程号以及用户 ID"></a>获取进程名、进程号以及用户 ID</h4><pre class=" language-sh"><code class="language-sh">netstat -tunlp</code></pre><pre class=" language-sh"><code class="language-sh">Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program nametcp        0      0 127.0.1.1:53            0.0.0.0:*               LISTEN      1144/dnsmasq    tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      661/cupsd       tcp6       0      0 ::1:631                 :::*                    LISTEN      661/cupsd</code></pre><h4 id="查看进程的拥有者会更有用。使用-ep-选项可以同时查看进程名和用户名"><a href="#查看进程的拥有者会更有用。使用-ep-选项可以同时查看进程名和用户名" class="headerlink" title="查看进程的拥有者会更有用。使用 -ep 选项可以同时查看进程名和用户名"></a>查看进程的拥有者会更有用。使用 -ep 选项可以同时查看进程名和用户名</h4><pre class=" language-sh"><code class="language-sh">netstat -tunlep</code></pre><pre class=" language-sh"><code class="language-sh">Proto Recv-Q Send-Q Local Address           Foreign Address         State       User       Inode      PID/Program name    tcp        0      0 192.168.122.1:domain    0.0.0.0:*               LISTEN      root       14887      1567/dnsmasq        tcp        0      0 localhost:ipp           0.0.0.0:*               LISTEN      root       1946474    310640/cupsd     </code></pre><p>参考：<br><a href="https://docs.oracle.com/cd/E26926_01/html/E25874/ipconfig-142.html">https://docs.oracle.com/cd/E26926_01/html/E25874/ipconfig-142.html</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在 Git 提交中禁止包含敏感信息</title>
      <link href="/2024/07/11/git/no-sensitive/"/>
      <url>/2024/07/11/git/no-sensitive/</url>
      
        <content type="html"><![CDATA[<p>为了防止在 Git 提交中包含敏感信息（如数据库密码），可以采取以下几种方法：</p><h2 id="1-使用-gitignore"><a href="#1-使用-gitignore" class="headerlink" title="1. 使用 .gitignore"></a>1. 使用 .gitignore</h2><p>将包含敏感信息的文件添加到 <code>.gitignore</code> 文件中，这样 Git 就不会跟踪这些文件。例如，如果你的敏感信息存储在 <code>config.json</code> 文件中，你可以在 <code>.gitignore</code> 中添加：</p><pre><code>config.json</code></pre><h2 id="2-使用环境变量"><a href="#2-使用环境变量" class="headerlink" title="2. 使用环境变量"></a>2. 使用环境变量</h2><p>将敏感信息存储在环境变量中，而不是直接在代码中。例如，在代码中读取环境变量：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> osdb_password <span class="token operator">=</span> os<span class="token punctuation">.</span>getenv<span class="token punctuation">(</span><span class="token string">'DB_PASSWORD'</span><span class="token punctuation">)</span></code></pre><p>在运行应用程序之前，设置环境变量：</p><pre class=" language-sh"><code class="language-sh">export DB_PASSWORD="your_database_password"</code></pre><h2 id="3-使用-Git-钩子（pre-commit-钩子）"><a href="#3-使用-Git-钩子（pre-commit-钩子）" class="headerlink" title="3. 使用 Git 钩子（pre-commit 钩子）"></a>3. 使用 Git 钩子（pre-commit 钩子）</h2><p>可以编写一个 Git pre-commit 钩子，在每次提交之前检查提交内容中是否包含敏感信息。如果包含，则拒绝提交。</p><h3 id="方法1：手动编写-pre-commit-钩子"><a href="#方法1：手动编写-pre-commit-钩子" class="headerlink" title="方法1：手动编写 pre-commit 钩子"></a>方法1：手动编写 pre-commit 钩子</h3><p>首先，创建一个 pre-commit 钩子脚本：</p><pre class=" language-sh"><code class="language-sh">#!/bin/sh# 定义敏感信息模式SENSITIVE_PATTERNS=("your_database_password" "another_sensitive_pattern")# 获取已暂存的文件STAGED_FILES=$(git diff --cached --name-only)for FILE in $STAGED_FILES; do  for PATTERN in "${SENSITIVE_PATTERNS[@]}"; do    if git grep -q "$PATTERN" "$FILE"; then      echo "Error: Sensitive information found in $FILE"      exit 1    fi  donedoneexit 0</code></pre><p>将这个脚本保存到 <code>.git/hooks/pre-commit</code> 文件中，并确保它具有可执行权限：</p><pre class=" language-sh"><code class="language-sh">chmod +x .git/hooks/pre-commit</code></pre><h3 id="方法2：使用-pre-commit-工具-禁止已经提交的文件"><a href="#方法2：使用-pre-commit-工具-禁止已经提交的文件" class="headerlink" title="方法2：使用 pre-commit 工具 禁止已经提交的文件"></a>方法2：使用 pre-commit 工具 禁止已经提交的文件</h3><ol><li>安装 pre-commit</li></ol><pre class=" language-sh"><code class="language-sh">pip install pre-commit</code></pre><p>或者</p><pre class=" language-sh"><code class="language-sh">brew install pre-commit   # mac apt install pre-commit    # linux</code></pre><ol start="2"><li>添加默认配置文件</li></ol><pre class=" language-sh"><code class="language-sh">pre-commit sample-config > .pre-commit-config.yaml</code></pre><p>在项目根目录下生成文件 <code>.pre-commit-config.yaml</code>，内容如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># See https://pre-commit.com for more information</span><span class="token comment" spellcheck="true"># See https://pre-commit.com/hooks.html for more hooks</span><span class="token key atrule">repos</span><span class="token punctuation">:</span><span class="token punctuation">-</span>   <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/pre<span class="token punctuation">-</span>commit/pre<span class="token punctuation">-</span>commit<span class="token punctuation">-</span>hooks    <span class="token key atrule">rev</span><span class="token punctuation">:</span> v3.2.0    <span class="token key atrule">hooks</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span>   <span class="token key atrule">id</span><span class="token punctuation">:</span> trailing<span class="token punctuation">-</span>whitespace    <span class="token punctuation">-</span>   <span class="token key atrule">id</span><span class="token punctuation">:</span> end<span class="token punctuation">-</span>of<span class="token punctuation">-</span>file<span class="token punctuation">-</span>fixer    <span class="token punctuation">-</span>   <span class="token key atrule">id</span><span class="token punctuation">:</span> check<span class="token punctuation">-</span>yaml    <span class="token punctuation">-</span>   <span class="token key atrule">id</span><span class="token punctuation">:</span> check<span class="token punctuation">-</span>added<span class="token punctuation">-</span>large<span class="token punctuation">-</span>files</code></pre><ol start="3"><li>配置 pre-commit 钩子：</li></ol><p>在 <code>.pre-commit-config.yaml</code> 文件中添加一个自定义钩子来检查指定文件是否被修改。例如，假设你想保护文件 <code>protected_file.txt</code>，可以这样配置：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">repos</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">repo</span><span class="token punctuation">:</span> local    <span class="token key atrule">hooks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> protect<span class="token punctuation">-</span>protected<span class="token punctuation">-</span>file        <span class="token key atrule">name</span><span class="token punctuation">:</span> Protect protected_file.txt        <span class="token key atrule">entry</span><span class="token punctuation">:</span> bash protect<span class="token punctuation">-</span>protected<span class="token punctuation">-</span>file.sh        <span class="token key atrule">language</span><span class="token punctuation">:</span> system        <span class="token key atrule">stages</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>commit<span class="token punctuation">]</span></code></pre><ol start="4"><li>创建自定义钩子脚本</li></ol><pre class=" language-sh"><code class="language-sh">#!/bin/sh# 要保护的文件列表PROTECTED_FILES=(    "protected_file.txt" )# 检查是否有文件被修改for FILE in "${PROTECTED_FILES[@]}"; do  if git diff --cached --name-only | grep -q "^$FILE$"; then    echo "Error: You are trying to modify $FILE, which is protected."    exit 1  fidone# 允许提交exit 0</code></pre><ol start="5"><li>使脚本可执行：</li></ol><pre class=" language-sh"><code class="language-sh">chmod +x protect-protected-file.sh</code></pre><ol start="6"><li>安装 pre-commit 钩子：</li></ol><pre class=" language-sh"><code class="language-sh">pre-commit install</code></pre><h2 id="4-使用工具（如-git-secrets）"><a href="#4-使用工具（如-git-secrets）" class="headerlink" title="4. 使用工具（如 git-secrets）"></a>4. 使用工具（如 git-secrets）</h2><p><code>git-secrets</code> 是一个专门用于防止在 Git 仓库中提交敏感信息的工具。它可以在提交之前扫描提交内容，并阻止包含敏感信息的提交。</p><h3 id="安装-git-secrets"><a href="#安装-git-secrets" class="headerlink" title="安装 git-secrets"></a>安装 git-secrets</h3><h4 id="对于-macOS"><a href="#对于-macOS" class="headerlink" title="对于 macOS"></a>对于 macOS</h4><pre class=" language-sh"><code class="language-sh">brew install git-secrets</code></pre><h4 id="对于-Linux"><a href="#对于-Linux" class="headerlink" title="对于 Linux"></a>对于 Linux</h4><pre class=" language-sh"><code class="language-sh">git clone https://github.com/awslabs/git-secrets.gitcd git-secretssudo make install</code></pre><p>然后在你的 Git 仓库中初始化 git-secrets 并添加敏感信息模式：</p><pre class=" language-sh"><code class="language-sh">cd your-repogit secrets --installgit secrets --add 'your_database_password'git secrets --add 'another_sensitive_pattern'</code></pre><p>这样，每次提交时，git-secrets 都会扫描提交内容并阻止包含敏感信息的提交。</p><h2 id="5-使用-Secret-Scanning-服务"><a href="#5-使用-Secret-Scanning-服务" class="headerlink" title="5. 使用 Secret Scanning 服务"></a>5. 使用 Secret Scanning 服务</h2><p>一些代码托管平台（如 GitHub）提供了 Secret Scanning 服务，可以自动扫描仓库中的敏感信息，并在发现敏感信息时发出警告。</p><p>通过以上方法，可以有效防止在 Git 提交中包含敏感信息，保护你的代码库安全。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu24.04 微信客户端</title>
      <link href="/2024/07/03/linux/wechat/"/>
      <url>/2024/07/03/linux/wechat/</url>
      
        <content type="html"><![CDATA[<h2 id="使用终端命令行安装铜豌豆软件源。注意需要用到sudo权限"><a href="#使用终端命令行安装铜豌豆软件源。注意需要用到sudo权限" class="headerlink" title="使用终端命令行安装铜豌豆软件源。注意需要用到sudo权限"></a>使用终端命令行安装铜豌豆软件源。注意需要用到sudo权限</h2><pre class=" language-sh"><code class="language-sh">wget -c -O atzlinux-v12-archive-keyring_lastest_all.deb https://www.atzlinux.com/atzlinux/pool/main/a/atzlinux-archive-keyring/atzlinux-v12-archive-keyring_lastest_all.debsudo apt -y install ./atzlinux-v12-archive-keyring_lastest_all.deb</code></pre><h2 id="使用终端命令行安装微信原生版本。注意需要用到sudo权限"><a href="#使用终端命令行安装微信原生版本。注意需要用到sudo权限" class="headerlink" title="使用终端命令行安装微信原生版本。注意需要用到sudo权限"></a>使用终端命令行安装微信原生版本。注意需要用到sudo权限</h2><pre class=" language-sh"><code class="language-sh">sudo apt updatesudo cp /etc/lsb-release /etc/lsb-release.Ubuntusudo apt -y install electronic-wechat-icons-atzlinuxsudo apt -y install com.tencent.wechatsudo cp /etc/lsb-release /etc/lsb-release.wechat</code></pre><h2 id="登录微信并使用"><a href="#登录微信并使用" class="headerlink" title="登录微信并使用"></a>登录微信并使用</h2><pre class=" language-sh"><code class="language-sh">wechat</code></pre><p>登录成功以后，下次就可以直接在终端使用wechat启动微信，或者在显示应用程序里面找到微信linux原生版图标启动了。本次安装的微信版本号：1.0.0.241</p><p><img src="/medias/loading.gif" data-original="/images/linux/wechat/image.png" alt="start wechat"></p><p><a href="https://link.zhihu.com/?target=https://www.atzlinux.com/">铜豌豆 Linux</a>是个开源网站</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk 常用的命令</title>
      <link href="/2024/07/01/linux/awk/"/>
      <url>/2024/07/01/linux/awk/</url>
      
        <content type="html"><![CDATA[<h2 id="处理字符串"><a href="#处理字符串" class="headerlink" title="处理字符串"></a>处理字符串</h2><p><strong>提取字符串第三字符串</strong></p><pre class=" language-sh"><code class="language-sh">echo 'this is a test' |awk '{print $3}'</code></pre><p><strong>替换 字符串中一个</strong></p><pre class=" language-sh"><code class="language-sh"> echo "Hello Tom" | awk '{$2="Adam"; print $0}'</code></pre><p>输出：</p><pre class=" language-sh"><code class="language-sh">Hello Adam</code></pre><h3 id="利用变量-菜鸟"><a href="#利用变量-菜鸟" class="headerlink" title="利用变量    菜鸟"></a>利用变量    <a href="https://www.runoob.com/w3cnote/8-awesome-awk-built-in-variables.html">菜鸟</a></h3><ol><li><p>$NF  表示当前行有多少个字段，</p><p>因此<code>$NF</code>就代表最后一个字段。</p></li></ol><pre class=" language-sh"><code class="language-sh">echo 'this is a test' | awk '{print $NF}'</code></pre><p>输出：</p><pre class=" language-sh"><code class="language-sh">test</code></pre><p>​     <code>$(NF-1)</code>代表倒数第二个字段</p><pre class=" language-sh"><code class="language-sh">echo 'this is a test' | awk '{print $(NF-1)}'</code></pre><p>输出：</p><pre class=" language-sh"><code class="language-sh">a</code></pre><p>   2 .变量<code>NR</code>表示当前处理的是第几行。</p><h2 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h2><p>处理文件 logs.txt , 文件内容:</p><pre class=" language-sh"><code class="language-sh">07.46.199.184 [28/Sep/2010:04:08:20] "GET /robots.txt HTTP/1.1" 200 0 "msnbot"123.125.71.19 [28/Sep/2010:04:20:11] "GET / HTTP/1.1" 304 - "Baiduspider"</code></pre><p> <strong>获取第一列数据</strong></p><pre class=" language-sh"><code class="language-sh">awk '{print $1}' logs.txt</code></pre><p>输出：</p><pre class=" language-sh"><code class="language-sh">07.46.199.184123.125.71.19</code></pre><p><strong>这个文件的字段分隔符是冒号（<code>:</code>），所以要用<code>-F</code>参数指定分隔符为冒号。然后，才能提取到它的第一个字段。</strong></p><pre class=" language-sh"><code class="language-sh">awk -F ':' '{print $1}' logs.txt</code></pre><p>输出：</p><pre class=" language-sh"><code class="language-sh">07.46.199.184 [28/Sep/2010123.125.71.19 [28/Sep/2010</code></pre><p><strong>提取log 的时间</strong></p><pre class=" language-sh"><code class="language-sh">awk '{print $2}' logs.txt | awk 'BEGIN{FS=":"}{print $1}' | sed 's/\[//'</code></pre><p>输出:</p><pre class=" language-sh"><code class="language-sh">28/Sep/201028/Sep/2010</code></pre><p>**统计某一个字段的相加 ** </p><p>每次都大于结果</p><pre class=" language-sh"><code class="language-sh">awk '{a+=$(NF-2); print "Total so far:", a}' logs.txt</code></pre><pre class=" language-sh"><code class="language-sh">Total so far: 200Total so far: 504</code></pre><p>执行完后在打印结果</p><pre class=" language-sh"><code class="language-sh">awk '{a+=$(NF-2)}END{print "Total:", a}' logs.txt</code></pre><p>输出：</p><pre class=" language-sh"><code class="language-sh">Total: 504</code></pre><h3 id="利用变量"><a href="#利用变量" class="headerlink" title="利用变量"></a>利用变量</h3><ol><li><strong>OFS: 输出字段分隔符变量</strong></li></ol><p><strong>OFS</strong>(Output Field Separator) 相当与输出上的 <strong>FS</strong>, 默认是以一个空格字符作为输出分隔符的，下面是一个 <strong>OFS</strong> 的例子:</p><p>正常空格命令：</p><pre class=" language-sh"><code class="language-sh">awk  '{print $1, $3;}' logs.txt</code></pre><p>输出结果：</p><pre class=" language-sh"><code class="language-sh">07.46.199.184 "GET123.125.71.19 "GET</code></pre><p>注意命令中的 print 语句的, 表示的使用一个空格连接两个参数，也就是默认的OFS的值。因此 <strong>OFS</strong> 可以像下面那样插入到输出的字段之间:</p><pre class=" language-sh"><code class="language-sh">awk 'BEGIN{OFS="=>";}{print $1, $3;}' logs.txt</code></pre><p>输出：</p><pre class=" language-sh"><code class="language-sh">07.46.199.184=>"GET123.125.71.19=>"GET</code></pre><p>注意： GET 前面多一个双引号，我们需要去掉</p><pre class=" language-sh"><code class="language-sh">awk  '{print $1, $3;}' logs.txt |sed 's/\"//'awk 'BEGIN{OFS="=>";}{print $1, $3;}' logs.txt |sed 's/\"//'</code></pre><p>输出：</p><pre class=" language-sh"><code class="language-sh">07.46.199.184 GET123.125.71.19 GET07.46.199.184=>GET123.125.71.19=>GET</code></pre><ol start="2"><li><strong>变量<code>NR</code>表示当前处理的是第几行。</strong></li></ol><pre class=" language-sh"><code class="language-sh">awk '{print NR") "$1}' logs.txt</code></pre><p>输出:</p><pre class=" language-sh"><code class="language-sh">1) 07.46.199.1842) 123.125.71.19</code></pre><ol start="3"><li><p>变量 NF  表示一列的最后一个字段 </p><p>$(NF-2) 表示倒数第三个字段    </p><p>利用 if 判断倒数第三个字段 是否 等于  200</p><pre class=" language-sh"><code class="language-sh"> awk '条件 动作' 文件名</code></pre></li></ol><pre class=" language-sh"><code class="language-sh">awk '{if ($(NF-2) == "200") {print $0}}' logs.txt</code></pre><p>输出：</p><pre class=" language-sh"><code class="language-sh">07.46.199.184 [28/Sep/2010:04:08:20] "GET /robots.txt HTTP/1.1" 200 0 "msnbot"</code></pre><h2 id="处理进程"><a href="#处理进程" class="headerlink" title="处理进程"></a>处理进程</h2><ol><li>根据 lsof 命令获取进程 PID</li></ol><pre class=" language-sh"><code class="language-sh">lsof -i:3100|awk 'NR>1' |awk '{print $2}' </code></pre><p>  kill  -9 进程</p><pre class=" language-sh"><code class="language-sh">lsof -i:3100|awk 'NR>1' |awk '{print $2}'  | xargs kill -9</code></pre><p>NR  大于  1 表示从第二行开始</p><p>输出：</p><pre class=" language-sh"><code class="language-sh">2299757229975722997572299757229975722997572299757229975722997572410946</code></pre><h2 id="统计文件中的数量"><a href="#统计文件中的数量" class="headerlink" title="统计文件中的数量"></a>统计文件中的数量</h2><p>查询 file 文件中 haha 的数量</p><pre class=" language-sh"><code class="language-sh">awk -v RS='haha' 'END {print --NR}' file  </code></pre><p>或者使用 grep </p><pre class=" language-sh"><code class="language-sh">grep -o 'haha' file | wc -l</code></pre><h2 id="查询使用端口"><a href="#查询使用端口" class="headerlink" title="查询使用端口"></a>查询使用端口</h2><pre class=" language-bash"><code class="language-bash">ss -nutlp <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$1</span>,<span class="token variable">$5</span>}'</span> <span class="token operator">|</span> <span class="token function">awk</span> -F<span class="token string">"[: ]"</span> <span class="token string">'{print "协议:"<span class="token variable">$1</span>, "端口号:"<span class="token variable">$NF</span>}'</span><span class="token operator">|</span><span class="token function">grep</span> <span class="token string">"[0-9]"</span><span class="token operator">|</span><span class="token function">uniq</span></code></pre><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://gregable.com/2010/09/why-you-should-know-just-little-awk.html">Awk Example</a></p><p><a href="https://www.runoob.com/linux/linux-comm-awk.html">菜鸟</a></p><p><a href="https://www.ruanyifeng.com/blog/2018/11/awk.html">awk 入门教程</a></p><p><a href="https://likegeeks.com/awk-command/">30 Examples for Awk Command in Text Processing</a></p><p><a href="https://zhuanlan.zhihu.com/p/34946663">查找grep、提取awk、sed、重定向</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> awk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcpdump 常用命令</title>
      <link href="/2024/07/01/linux/tcpdump/"/>
      <url>/2024/07/01/linux/tcpdump/</url>
      
        <content type="html"><![CDATA[<p>tcpdump 支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息</p><h2 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h2><pre class=" language-sh"><code class="language-sh">tcpdump [ -DenNqvX ] [ -c count ] [ -F file ] [ -i interface ] [ -r file ]        [ -s snaplen ] [ -w file ] [ expression ]</code></pre><p>抓包选项：<br>-c：指定要抓取的包数量。</p><p>-i interface：指定tcpdump需要监听的接口。默认会抓取第一个网络接口</p><p>-n：对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。</p><p>-nn：除了-n的作用外，还把端口显示为数值，否则显示端口服务名。</p><p>-P：指定要抓取的包是流入还是流出的包。可以给定的值为”in”、”out”和”inout”，默认为”inout”。</p><p>-s len：设置tcpdump的数据包抓取长度为len，如果不设置默认将会是65535字节。对于要抓取的数据包较大时，长度设置不够可能会产生包截断，若出现包截断，<br>：输出行中会出现”[|proto]”的标志(proto实际会显示为协议名)。但是抓取len越长，包的处理时间越长，并且会减少tcpdump可缓存的数据包的数量，<br>：从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好。</p><p>输出选项：<br>-e：输出的每行中都将包括数据链路层头部信息，例如源MAC和目标MAC。</p><p>-q：快速打印输出。即打印很少的协议相关信息，从而输出行都比较简短。</p><p>-X：输出包的头部数据，会以16进制和ASCII两种方式同时输出。</p><p>-XX：输出包的头部数据，会以16进制和ASCII两种方式同时输出，更详细。</p><p>-v：当分析和打印的时候，产生详细的输出。</p><p>-vv：产生比-v更详细的输出。<br>-vvv：产生比-vv更详细的输出。</p><h2 id="tcpdump示例"><a href="#tcpdump示例" class="headerlink" title="tcpdump示例"></a>tcpdump示例</h2><p>==**tcpdump只能抓取流经本机的数据包 **==</p><ol><li>默认启动</li></ol><pre class=" language-sh"><code class="language-sh">tcpdump</code></pre><p>默认情况下，直接启动tcpdump将监视第一个网络接口(非lo口)上所有流通的数据包。这样抓取的结果会非常多，滚动非常快。</p><p>2 . 监视指定网络接口的数据包</p><pre class=" language-sh"><code class="language-sh">tcpdump -i ens33</code></pre><ol start="3"><li>监视指定主机的数据包，例如所有进入或离开node1的数据包</li></ol><pre class=" language-sh"><code class="language-sh">tcpdump -i ens33  host node1</code></pre><ol start="4"><li>打印node1&lt;–&gt;node2或node1&lt;–&gt;node3之间通信的数据包</li></ol><pre class=" language-sh"><code class="language-sh">tcpdump -i ens33 host node1 and \(node2 or node3\)</code></pre><ol start="5"><li>打印node1与任何其他主机之间通信的IP数据包,但不包括与node4之间的数据包</li></ol><pre class=" language-sh"><code class="language-sh">tcpdump -i ens33 host node1 and not node4</code></pre><ol start="6"><li>截获主机node1 发送的所有数据</li></ol><pre class=" language-sh"><code class="language-sh">tcpdump -i ens33 src host node1</code></pre><ol start="7"><li>监视所有发送到主机node1 的数据包</li></ol><pre class=" language-sh"><code class="language-sh">tcpdump -i ens33 dst host node1</code></pre><ol start="8"><li>监视指定主机和端口的数据包</li></ol><pre class=" language-sh"><code class="language-sh">tcpdump -i ens33 port 8080 and host node1</code></pre><ol start="9"><li>监视指定网络的数据包，如本机与192.168网段通信的数据包，”-c 10”表示只抓取10个包</li></ol><pre class=" language-sh"><code class="language-sh">tcpdump -i ens33 -c 10 net 192.168</code></pre><ol start="10"><li>打印所有通过网关snup的ftp数据包</li></ol><pre class=" language-sh"><code class="language-sh">tcpdump 'gateway snup and (port ftp or ftp-data)'</code></pre><p>注意,表达式被单引号括起来了,这可以防止shell对其中的括号进行错误解析</p><ol start="11"><li>抓取ping包</li></ol><pre class=" language-sh"><code class="language-sh">tcpdump -c 5 -nn -i ens33 </code></pre><p>==指定主机抓ping包==</p><pre class=" language-sh"><code class="language-sh">tcpdump -c 5 -nn -i eth0 icmp and src 192.168.100.62</code></pre><ol start="12"><li>抓取到本机22端口包</li></ol><pre class=" language-sh"><code class="language-sh">tcpdump -c 10 -nn -i ens33 tcp dst port 22</code></pre><ol start="13"><li>解析包数据</li></ol><pre class=" language-sh"><code class="language-sh">tcpdump -c 2 -q -XX -vvv -nn -i ens33 tcp dst port 22</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tcpdump </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux date 命令</title>
      <link href="/2024/07/01/linux/date/"/>
      <url>/2024/07/01/linux/date/</url>
      
        <content type="html"><![CDATA[<h2 id="date-命令参数说明"><a href="#date-命令参数说明" class="headerlink" title="date 命令参数说明"></a>date 命令参数说明</h2><!-- 转换表格 --><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>%%</td><td>一个文字的 %</td></tr><tr><td>%a</td><td>当前locale 的星期名缩写(例如： 日，代表星期日)</td></tr><tr><td>%A</td><td>当前locale 的星期名全称 (如：星期日)</td></tr><tr><td>%b</td><td>当前locale 的月名缩写 (如：一，代表一月)</td></tr><tr><td>%B</td><td>当前locale 的月名全称 (如：一月)</td></tr><tr><td>%c</td><td>当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25)</td></tr><tr><td>%C</td><td>世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20)</td></tr><tr><td>%Y</td><td>年</td></tr><tr><td>%y</td><td>年份后两位  (00..99)</td></tr><tr><td>%m</td><td>月</td></tr><tr><td>%d</td><td>日</td></tr><tr><td>%D</td><td>按月计的日期；等于%m/%d/%y</td></tr><tr><td>%e</td><td>按月计的日期，添加空格，等于%_d</td></tr><tr><td>%F</td><td>完整日期格式，等价于 %Y-%m-%d</td></tr><tr><td>%H</td><td>小时 24 小时制  hour (00..23)</td></tr><tr><td>%I</td><td>小时 12 小时制   hour (01..12)</td></tr><tr><td>%M</td><td>分钟</td></tr><tr><td>%S</td><td>秒钟</td></tr><tr><td>%s</td><td>当前时间秒数</td></tr><tr><td>%T</td><td>时钟 等于 %H:%M:%S</td></tr><tr><td>%c</td><td>本地时间和日期</td></tr><tr><td>%j</td><td>一年中的第几天</td></tr><tr><td>%W</td><td>一年中的第几周 星期一为一周的第一天</td></tr><tr><td>%w</td><td>星期几  week(0..6) ; 0 是星期天</td></tr><tr><td>%u</td><td>星期几  week(1..7) ; 1 是星期一</td></tr><tr><td>%U</td><td>一年中的第几周  星期日为一周的第一天</td></tr><tr><td>%V</td><td>ISO 周数  星期一为一周的第一天, ISO 周编号</td></tr><tr><td>%x</td><td>日期   (e.g., 12/31/99)</td></tr><tr><td>%X</td><td>时间  (e.g., 23:13:48)</td></tr><tr><td>%z</td><td>时区  数字格式  (e.g., +0800)</td></tr><tr><td>%:z</td><td>时区 +08:00</td></tr><tr><td>%::z</td><td>时区 +08:00:00</td></tr><tr><td>%:::z</td><td>时区 +08</td></tr><tr><td>%Z</td><td>时区缩写  CST</td></tr><tr><td>%n</td><td>换行</td></tr><tr><td>%N</td><td>纳秒(000000000-999999999)</td></tr></tbody></table><h2 id="时间戳与时间互转"><a href="#时间戳与时间互转" class="headerlink" title="时间戳与时间互转"></a>时间戳与时间互转</h2><ol><li>时间戳转换成时间格式</li></ol><pre class=" language-Bash"><code class="language-Bash">date -d @1718866413  "+%Y-%m-%d %H:%M:%S"=> 2024-06-20 14:53:33</code></pre><ol><li>获取当前时间戳</li></ol><pre class=" language-Bash"><code class="language-Bash"> date +%s => 1718869999</code></pre><ol><li>获取当天的时钟</li></ol><pre class=" language-Bash"><code class="language-Bash">date +%T  => 15:54:22</code></pre><ol><li>获取某个时间节点对应的时间戳</li></ol><pre class=" language-Bash"><code class="language-Bash">date -d "2021-12-20"  +%s=> 1639929600date -d "2021-12-20 20:20:10"  +%s=> 1640002810</code></pre><ol><li>获取当前时间或指定时间是全年的第几天</li></ol><pre class=" language-Bash"><code class="language-Bash"># 当前时间date  +%j=> 172 # 指定时间date -d "2021-12-20 20:20:10"  +%j=> 354</code></pre><ol start="2"><li>当前时间是第几周</li></ol><pre class=" language-Bash"><code class="language-Bash">date +%W=> 25</code></pre><ol><li>查看当前时间日前与时间</li></ol><pre class=" language-Bash"><code class="language-Bash"># date  "+%x %X"=> 06/20/2024 04:09:04 PM</code></pre><ol><li>查看当前时区</li></ol><pre class=" language-Bash"><code class="language-Bash">date +%z=> +0800</code></pre><ol><li>设置时区获取时间</li></ol><pre class=" language-Bash"><code class="language-Bash"># 当前时间戳转换TZ='America/Los_Angeles' date "+%Y-%m-%d %H:%M:%S"=> 2024-06-20 01:22:26TZ="Asia/Shanghai" date "+%Y-%m-%d %H:%M:%S"=> 2024-06-20 16:26:38# 指定时间戳转换TZ='America/Los_Angeles'  date -d @1718866413 "+%Y-%m-%d %H:%M:%S"=> 2024-06-19 23:53:33TZ="Asia/Shanghai" date -d @1718866413 "+%Y-%m-%d %H:%M:%S"=> 2024-06-20 14:53:33</code></pre><p>参考时区表 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a></p><p>通过 <code>timedatectl list-timezones</code> 列出可用的时区</p><pre class=" language-Bash"><code class="language-Bash">timedatectl list-timezones=>Africa/AbidjanAfrica/AccraAfrica/Addis_AbabaAfrica/AlgiersAfrica/AsmaraAfrica/AsmeraAfrica/BamakoAfrica/BanguiAfrica/BanjulAfrica/BissauAfrica/Blantyre...</code></pre><h2 id="设置系统日期和时间"><a href="#设置系统日期和时间" class="headerlink" title="设置系统日期和时间"></a>设置系统日期和时间</h2><pre class=" language-Bash"><code class="language-Bash"> date –set="20140125 09:17:00"</code></pre><p>通过 <code>man date</code>  查看 date 更多参数</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> date </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile 打印变量</title>
      <link href="/2024/06/18/makefile/print-variable/"/>
      <url>/2024/06/18/makefile/print-variable/</url>
      
        <content type="html"><![CDATA[<p>在编写Makefile时，调试信息的输出对于查找和解决问题至关重要。Makefile提供了几种不同的方式来输出调试信息，包括<code>info</code>、<code>warning</code>、<code>error</code>以及<code>echo</code>命令。下面我们将详细介绍这些工具的使用方法以及它们之间的区别。</p><p>makefile 打印变量方式有两种情况</p><ol><li>使用info/warning/error增加调试信息<ol><li>打印字符串</li></ol></li></ol><pre class=" language-Makefile"><code class="language-Makefile">$(info xxx-msg)  # 输出字符串xxxx-msg，不需要加""，info后加空格=>  xxxx-msg </code></pre><pre><code>2. 打印变量</code></pre><pre class=" language-Makefile"><code class="language-Makefile">$(info $(GOPATH)) #打印变量GOPATH，变量名用$())=> /home/user/code/go</code></pre><pre><code>3. 字符串、变量混合打印</code></pre><pre class=" language-Makefile"><code class="language-Makefile">$(info GOPATH: $(GOPATH))=> GOPATH: /home/hellotalk/code/go</code></pre><pre><code>4. info/warning/error之间区别      info只输出信息：</code></pre><pre class=" language-Makefile"><code class="language-Makefile">$(info GOPATH is: $(GOPATH)) => GOPATH is: /home/hellotalk/code/go</code></pre><pre><code>    warning输出信息和对应的行号：</code></pre><pre class=" language-Makefile"><code class="language-Makefile">  $(warning ***** $(shell date))  => scripts/make-rules/common.mk:99: ***** Tue Jun 18 05:27:20 PM CST 2024</code></pre><pre><code>    error输出信息和对应的行号，并停止makefile的编译：</code></pre><pre class=" language-Makefile"><code class="language-Makefile">$(error GOPATH: $(GOPATH))=> scripts/make-rules/golang.mk:12: *** GOPATH: /home/hellotalk/code/go。 停止。</code></pre><ol start="2"><li>使用echo增加调试信息（echo只能在target：后面的语句中使用，且前面是个TAB）</li></ol><pre class=" language-Makefile"><code class="language-Makefile"># 假设我们有一个变量  MY_VARIABLE := Hello, Makefile!    # 定义一个目标（target）  all:    # 注意这里有一个制表符（Tab），而不是空格    @echo "开始构建..."    @echo "MY_VARIABLE 的值是: $(MY_VARIABLE)"    # 假设这里有一些其他的构建命令...    @echo "构建完成!"    # 如果你还有其他的目标（target），也可以在这里定义  clean:    # 同样是制表符（Tab）开头    @echo "开始清理..."    # 这里应该有清理构建产物的命令，比如 rm -f ...    @echo "清理完成!"</code></pre><pre><code>执行测试命令</code></pre><pre class=" language-Bash"><code class="language-Bash">make -n all</code></pre><pre><code>这将会显示`all`目标下的所有命令，但由于`@`前缀的存在，它们不会显示`echo`命令的内容。如果你想要看到`echo`的内容，你需要移除`@`前缀或者不使用`-n`选项。</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang 协程互斥锁</title>
      <link href="/2023/10/14/go/mutex/"/>
      <url>/2023/10/14/go/mutex/</url>
      
        <content type="html"><![CDATA[<p>golang 在多协程的情况下，如果多个协程同时操作一个变量，会出现数据不一致的情况，这个时候就需要使用互斥锁来解决这个问题。</p><h2 id="互斥锁-sync-Mutex"><a href="#互斥锁-sync-Mutex" class="headerlink" title="互斥锁 (sync.Mutex)"></a>互斥锁 (sync.Mutex)</h2><p>互斥即不可同时运行。即使用了互斥锁的两个代码片段互相排斥，只有其中一个代码片段执行完成后，另一个才能执行。</p><p>Go 标准库中提供了 sync.Mutex 互斥锁类型及其两个方法：</p><blockquote><p>Lock 加锁<br>Unlock 释放锁</p></blockquote><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><p>下面是没有使用锁一个例子情况：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> setMap <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">printOnce</span><span class="token punctuation">(</span>num <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> exist <span class="token operator">:=</span> setMap<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>exist <span class="token punctuation">{</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">}</span> setMap<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>  <span class="token keyword">go</span> <span class="token function">printOnce</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>运行 go run main.go 会发生什么情况呢？</p><pre class=" language-sh"><code class="language-sh">go run main.go100100</code></pre><p>多运行几次打印不同的结果, 有时候打印7次，有时候打印10次，有时候还触发 panic，是因为对同一个数据结构的访问冲突了。解决的方法使用 <code>Lock()</code> 与 <code>UnLock()</code> 的方法解决问题</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> m sync<span class="token punctuation">.</span>Mutex<span class="token keyword">var</span> setMap <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">printOnce</span><span class="token punctuation">(</span>num <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> exist <span class="token operator">:=</span> setMap<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>exist <span class="token punctuation">{</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">}</span> setMap<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span> m<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>  <span class="token keyword">go</span> <span class="token function">printOnce</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>运行 go run main.go</p><pre class=" language-sh"><code class="language-sh">go run main.go100</code></pre><p><strong>注意</strong>:</p><blockquote><p>一个互斥锁只能同时被一个 goroutine 锁定，其它 goroutine 就算调用 Lock() 方法也会等待锁的释放。</p></blockquote><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">var</span> m sync<span class="token punctuation">.</span>Mutex <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">defer</span> m<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"goroutine1: 大概锁定 2s"</span><span class="token punctuation">)</span>  time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"goroutine1: 锁定结束，准备退出"</span><span class="token punctuation">)</span>  ch <span class="token operator">&lt;-</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"goroutine2: 等待解锁"</span><span class="token punctuation">)</span>  m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">defer</span> m<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"goroutine2: 锁定结束"</span><span class="token punctuation">)</span>  ch <span class="token operator">&lt;-</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 等待 goroutine 执行结束</span> <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>  <span class="token operator">&lt;-</span>ch <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行 go run main.go</p><pre class=" language-sh"><code class="language-sh"> go run main.gogoroutine1: 大概锁定 2sgoroutine2: 等待解锁goroutine1: 锁定结束，准备退出goroutine2: 锁定结束</code></pre><h2 id="sync-Map-Go-1-9"><a href="#sync-Map-Go-1-9" class="headerlink" title="sync.Map (Go 1.9+)"></a>sync.Map (Go 1.9+)</h2><p>Go 1.9 标准库提供了内置并发安全的 map，可以安全地被多个 goroutine 并发使用，无需额外的加锁或协调。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"sync"</span><span class="token keyword">var</span> sm sync<span class="token punctuation">.</span>Map  <span class="token comment" spellcheck="true">// 直接声明即可使用</span><span class="token comment" spellcheck="true">// 存储</span>sm<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 读取</span><span class="token keyword">if</span> value <span class="token punctuation">,</span>ok <span class="token operator">:=</span> sm<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ok <span class="token punctuation">{</span>  fmt<span class="token punctuation">.</span><span class="token function">PrintLn</span><span class="token punctuation">(</span><span class="token string">"Loaded value"</span><span class="token punctuation">,</span>value<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 注意类型断言</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 读取或存储</span>actual<span class="token punctuation">,</span> loaded <span class="token operator">:=</span> sm<span class="token punctuation">.</span><span class="token function">LoadOrStore</span><span class="token punctuation">(</span><span class="token string">"key2"</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"LoadOrStore"</span><span class="token punctuation">,</span>actual<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"loaded?"</span><span class="token punctuation">,</span>loaded<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 删除</span>sm<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 遍历(注意 Range 的函数签名)</span>sm<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>key <span class="token punctuation">,</span> value any<span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">{</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Range:"</span><span class="token punctuation">,</span>key<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">,</span>value<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// 返回 true 继续遍历 ， false 停止</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pods 优雅终止</title>
      <link href="/2023/09/14/k8s/pod-elegant-stop/"/>
      <url>/2023/09/14/k8s/pod-elegant-stop/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Pod 销毁时，会停止容器内的进程，通常在停止的过程中我们需要执行一些善后逻辑，比如等待存量请求处理完以避免连接中断，或通知相关依赖进行清理等，从而实现优雅终止目的。本文介绍在 Kubernetes 场景下，实现容器优雅终止的最佳实践。</p><h2 id="当-Kubernetes-杀死一个-pod-时，会发生以下-5-个步骤："><a href="#当-Kubernetes-杀死一个-pod-时，会发生以下-5-个步骤：" class="headerlink" title="当 Kubernetes 杀死一个 pod 时，会发生以下 5 个步骤："></a>当 Kubernetes 杀死一个 pod 时，会发生以下 5 个步骤：</h2><ol><li>Pod 切换到终止状态并停止接收任何新流量，容器仍在 pod 内运行。</li><li>preStop 钩子是一个特殊的命令或 HTTP 请求被执行，并被发送到 pod 内的容器。</li><li>SIGTERM 信号被发送到 pod，容器意识到它将很快关闭。</li><li>Kubernetes 等待宽限期 (terminationGracePeriodSeconds)。此等待与 preStop hook 和 SIGTERM 信号执行并行（默认 30 秒）。因此，Kubernetes 不会等待这些完成。如果这段时间结束，则直接进入下一步。正确设置宽限期的值非常重要。</li><li>向 pod 发送 SIGKILL 信号，然后移除 pod。如果容器在宽限期后仍在运行，则 Pod 被 SIGKILL 强行移除，终止完成。</li></ol><p>总结下大致分为两步，第一步定义 preStop，一般情况下可以休眠 30s，用于处理残余流量；第二步发送 SIGTERM 信号，服务收到信号后进行服务的收尾工作处理。比如：关闭连接、通知第三方注册中心服务关闭…..</p><h2 id="Pods-生命周期的状态"><a href="#Pods-生命周期的状态" class="headerlink" title="Pods 生命周期的状态"></a>Pods 生命周期的状态</h2><p>phase表示一个Pod处于其生命周期的哪个阶段，一共有以下5个可能的取值：</p><ol><li>Pending：Pod已经被k8s系统接受，但Pod中还有容器没有被创建。Pod被调度前和下载容器镜像的时候都处于这个阶段</li><li>Running：Pod已经被调度到Node上，所有的容器都已经被创建，并且至少有一个容器还在运行中（正在启动或重启中的容器也算）</li><li>Succeeded：Pod中的所有容器都成功停止，并且不会再次重启</li><li>Failed：Pod中的所有容器都已经停止，并且至少有一个容器是以失败停止的（以非0状态退出或被系统强制停止）</li><li>Unknown：由于某种原因无法获得Pod的状态，一般是和Pod所在的Host出现通信问题导致</li></ol><p>Pod phase的查看方式：</p><pre class=" language-shell"><code class="language-shell">kubectl get pods whoami-78c854646d-nhgl9 -o yaml |grep 'phase:'</code></pre><p>输出：</p><pre class=" language-shell"><code class="language-shell"> phase: Running</code></pre><h2 id="k8s-lifecycle-用法"><a href="#k8s-lifecycle-用法" class="headerlink" title="k8s lifecycle 用法"></a>k8s lifecycle 用法</h2><p>lifecycle 周期有两个hook钩子 postStart 与 preStop  </p><ol><li>PostStart hook是在容器创建(created)之后立马被调用，并且PostStart跟容器的ENTRYPOINT是异步执行的，无法保证它们之间的顺序.</li><li>PreStop hook是容器处于Terminated状态时立马被调用(也就是说要是Job任务的话，执行完之后其状态为completed，所以不会触发PreStop的钩子)，同时PreStop是同步阻塞的，PreStop执行完才会执行删除Pod的操作</li></ol><p>注意:<br>PostStart 会阻塞容器成为Running状态,PreStop 会阻塞容器的删除，但是过了 terminationGracePeriodSeconds时间后，容器会被强制删除,<br>如果PreStop或者PostStart失败的话, 容器会被杀死;</p><h3 id="钩子的回调函数支持三种方式定义动作："><a href="#钩子的回调函数支持三种方式定义动作：" class="headerlink" title="钩子的回调函数支持三种方式定义动作："></a>钩子的回调函数支持三种方式定义动作：</h3><ol><li>exec：在容器内执行命令，如果命令的退出状态码是 0 表示执行成功，否则表示失败</li></ol><pre class=" language-yaml"><code class="language-yaml">  lifecycle：    <span class="token key atrule">postStart</span><span class="token punctuation">:</span>      <span class="token key atrule">exec</span><span class="token punctuation">:</span>        <span class="token key atrule">command</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> cat        <span class="token punctuation">-</span> /tmp/healthy</code></pre><ol start="2"><li>httpGet：向指定 URL 发起 GET 请求，如果返回的 HTTP 状态码在 [200, 400) 之间表示请求成功，否则表示失败</li></ol><pre class=" language-yaml"><code class="language-yaml">lifecycle：    <span class="token key atrule">postStart</span><span class="token punctuation">:</span>      <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>        <span class="token key atrule">path</span><span class="token punctuation">:</span> /login   <span class="token comment" spellcheck="true"># URI地址</span>        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80  </span><span class="token comment" spellcheck="true"># 端口号</span>        <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.126.100 <span class="token comment" spellcheck="true"># 主机地址</span>        <span class="token key atrule">scheme</span><span class="token punctuation">:</span> HTTP   <span class="token comment" spellcheck="true"># 支持的协议，http或https</span><span class="token comment" spellcheck="true"># http://192.168.126.100:80/login</span></code></pre><ol start="3"><li>TCPSocket：在容器尝试访问指定的socket</li></ol><pre class=" language-yaml"><code class="language-yaml">  lifecycle：    <span class="token key atrule">postStart</span><span class="token punctuation">:</span>      <span class="token key atrule">tcpSocket</span><span class="token punctuation">:</span>        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span></code></pre><p>Example:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">creationTimestamp</span><span class="token punctuation">:</span> <span class="token null important">null</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">strategy</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">creationTimestamp</span><span class="token punctuation">:</span> <span class="token null important">null</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx          <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx          <span class="token key atrule">resources</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>          <span class="token key atrule">lifecycle</span><span class="token punctuation">:</span>            <span class="token key atrule">postStart</span><span class="token punctuation">:</span>              <span class="token key atrule">exec</span><span class="token punctuation">:</span>                <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">,</span><span class="token string">"echo 11 >> /usr/share/nginx/html/index.html"</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 启动容器应用之后执行</span>            <span class="token key atrule">preStop</span><span class="token punctuation">:</span>              <span class="token key atrule">exec</span><span class="token punctuation">:</span>                <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">,</span><span class="token string">"echo 'Hello from the preStop handler' >> /var/log/nginx/message"</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">## 删除pod 完成之前执行</span><span class="token key atrule">status</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> pods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu 安装 nfs</title>
      <link href="/2023/09/13/linux/ubuntu-install-nfs-server/"/>
      <url>/2023/09/13/linux/ubuntu-install-nfs-server/</url>
      
        <content type="html"><![CDATA[<ol><li>安装nfs服务</li></ol><pre class=" language-sh"><code class="language-sh">sudo apt install nfs-kernel-server</code></pre><ol start="2"><li>编辑配置文件</li></ol><pre class=" language-sh"><code class="language-sh">sudo vim /etc/exports# Example for NFSv4:# /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)# /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)#/data/nfs-share *(rw,sync,no_subtree_check,no_root_squash) </code></pre><ol start="3"><li>创建共享目录</li></ol><pre class=" language-sh"><code class="language-sh">sudo mkdir -p /data/nfs-share</code></pre><ol start="4"><li>重启nfs服务</li></ol><pre class=" language-sh"><code class="language-sh">sudo service nfs-kernel-server restart</code></pre><ol start="5"><li><p>常用命令工具</p><p>已经安装的nfs无需安装客户端</p></li></ol><pre class=" language-sh"><code class="language-sh"># 显示已经mount到本机上sudo showmount -e localhost# 将配置文件中的目录全部重新 Export一次，无需重启sudo exportfs -rv# 查看nfs的运行状态sudo nfsstat#查看rpc执行信息，可以用于检测rpc运行情况sudo rpcinfo#查看网络端口，NFS默认是使用111端口。sudo netstat -tu -4</code></pre><ol start="6"><li>客户端的命令</li></ol><pre class=" language-sh"><code class="language-sh"># 安装客户端命令sudo apt install nfs-common</code></pre><ol start="7"><li>显示指定的（192.168.2.167）NFS服务器上export出来的目录</li></ol><pre class=" language-sh"><code class="language-sh">sudo showmount -e 192.168.2.167</code></pre><ol start="8"><li>创建本地挂载目录</li></ol><pre class=" language-sh"><code class="language-sh">sudo mkdir -p /mnt/data</code></pre><ol start="9"><li>挂载共享目录</li></ol><pre class=" language-sh"><code class="language-sh">sudo mount -t nfs 192.168.3.167:/data/nfs-share /mnt/data</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nfs实现k8s持久化</title>
      <link href="/2023/09/13/k8s/k8s-install-nfs/"/>
      <url>/2023/09/13/k8s/k8s-install-nfs/</url>
      
        <content type="html"><![CDATA[<h3 id="1-部署nfs服务端"><a href="#1-部署nfs服务端" class="headerlink" title="1. 部署nfs服务端"></a>1. 部署nfs服务端</h3><p>在任意一台服务器上安装</p><p>（1）安装nfs服务:</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y nfs-utils rpcbindvim /etc/exports/nfsdata *<span class="token punctuation">(</span>rw,no_root_squash,no_all_squash,sync<span class="token punctuation">)</span></code></pre><p>（2）保存配置文件后，执行如下操作：<br>在服务端创建对应的目录和赋予权限：</p><pre class=" language-bash"><code class="language-bash"> <span class="token function">mkdir</span> /nfsdata <span class="token function">chmod</span> 777 /nfsdata</code></pre><p>（3） 启动rpcbind和nfs服务：</p><pre class=" language-bash"><code class="language-bash">systemctl start rpcbind <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> rpcbindsystemctl start nfs <span class="token operator">&amp;&amp;</span> systemctl <span class="token function">enable</span> nfs</code></pre><p>（4）每个node安装nfs工具</p><pre class=" language-bash"><code class="language-bash"> yum <span class="token function">install</span> -y nfs-utils </code></pre><p>（5） 每个node查询NFS服务器</p><pre class=" language-bash"><code class="language-bash">showmount -e nfs-ipshowmount -e 192.168.11.101</code></pre><h4 id="NFS-PersistentVolume"><a href="#NFS-PersistentVolume" class="headerlink" title="NFS PersistentVolume"></a>NFS PersistentVolume</h4><p>（1）下面创建一个 PV mypv1，配置文件 nfs-pv1.yml 如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mypv1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Recycle  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /data/NFS/k8s/pv1    <span class="token key atrule">server</span><span class="token punctuation">:</span> 192.168.11.101</code></pre><p>① capacity 指定 PV 的容量为 1G。</p><p>② accessModes 指定访问模式为 ReadWriteOnce，支持的访问模式有：</p><p>ReadWriteOnce – PV 能以 read-write 模式 mount 到单个节点。</p><p>ReadOnlyMany – PV 能以 read-only 模式 mount 到多个节点。</p><p>ReadWriteMany – PV 能以 read-write 模式 mount 到多个节点。</p><p>③ persistentVolumeReclaimPolicy 指定当 PV 的回收策略为 Recycle，支持的策略有：</p><p>Retain – 需要管理员手工回收。</p><p>Recycle – 清除 PV 中的数据，效果相当于执行 rm -rf /thevolume/*。</p><p>Delete – 删除 Storage Provider 上的对应存储资源，例如 AWS EBS、GCE PD、Azure Disk、OpenStack Cinder Volume 等。</p><p>④ storageClassName 指定 PV 的 class 为 nfs。相当于为 PV 设置了一个分类，PVC 可以指定 class 申请相应 class 的 PV。</p><p>⑤ 指定 PV 在 NFS 服务器上对应的目录。</p><p>注意要做storage-provider段要提前建好文件夹</p><p>注意要做storage-provider段要提前建好文件夹</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>dev@rediscom k8s<span class="token punctuation">]</span>$ <span class="token function">ls</span>pv1</code></pre><p>（2）创建 mypv1：</p><pre class=" language-bash"><code class="language-bash">kubectl apply -f nfs-pv1.yaml</code></pre><p>（3）查看 mypv1：</p><pre class=" language-bash"><code class="language-bash">kubectl get <span class="token function">pv</span></code></pre><p><img src="/medias/loading.gif" data-original="/images/k8s/nfs/16373020145856.jpg" alt="pv"></p><p>STATUS 为 Available，表示 mypv1 就绪，可以被 PVC 申请。</p><h4 id="创建-PVC"><a href="#创建-PVC" class="headerlink" title="创建 PVC"></a>创建 PVC</h4><p>(1）接下来创建 PVC mypvc1，配置文件 nfs-pvc1.yml 如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mypvc1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">resources</span><span class="token punctuation">:</span>    <span class="token key atrule">requests</span><span class="token punctuation">:</span>      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs</code></pre><p>PVC 就很简单了，只需要指定 PV 的容量，访问模式和 class。</p><p>（2）创建 mypvc1：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl apply -f nfs-pvc1.yml</span>persistentvolumeclaim/mypvc1 created<span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pvc</span>NAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGEmypvc1   Bound    mypv1    1Gi        RWO            nfs            11s</code></pre><p>从 kubectl get pvc 和 kubectl get pv 的输出可以看到 mypvc1 已经 Bound 到 mypv1，申请成功。</p><h3 id="2-Pod使用pvc"><a href="#2-Pod使用pvc" class="headerlink" title="2 Pod使用pvc"></a>2 Pod使用pvc</h3><p>（1）接下来就可以在 Pod 中使用存储了，Pod 配置文件 pod1.yml 如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mypod1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mypod1      <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox      <span class="token key atrule">args</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> /bin/sh      <span class="token punctuation">-</span> <span class="token punctuation">-</span>c      <span class="token punctuation">-</span> sleep 30000      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"mydata"</span>        <span class="token key atrule">name</span><span class="token punctuation">:</span> mydata  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mydata      <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>        <span class="token key atrule">claimName</span><span class="token punctuation">:</span> mypvc1</code></pre><p>与使用普通 Volume 的格式类似，在 volumes 中过 persistentVolumeClaim 指定使用 mypvc1 申请的 Volume。</p><p>（2）创建 mypod1：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master pod<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl apply -f pod1.yaml</span>pod/mypod1 created<span class="token punctuation">[</span>root@k8s-master pod<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -o wide</span>NAME                     READY   STATUS              RESTARTS   AGE     IP              NODE        NOMINATED NODE   READINESS GATESmypod1                   0/1     ContainerCreating   0          20s     <span class="token operator">&lt;</span>none<span class="token operator">></span>          k8s-node4   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>nginx-58dcb77688-h8c5x   1/1     Running             0          3d23h   172.31.156.68   k8s-node1   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span></code></pre><p>（3）验证 PV 是否可用：</p><pre class=" language-bash"><code class="language-bash">kubectl <span class="token function">exec</span> mypod1 <span class="token function">touch</span> /mydata/hello</code></pre><p>查看生成文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@rediscom ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /data/NFS/k8s/pv1/</span><span class="token punctuation">[</span>root@rediscom pv1<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>hello</code></pre><p>可见，在 Pod 中创建的文件 /mydata/hello 确实已经保存到了 NFS 服务器目录 /nfsdata/pv1 中。</p><p>如果不再需要使用 PV，可用删除 PVC 回收 PV。</p><h3 id="3-回收-PV"><a href="#3-回收-PV" class="headerlink" title="3. 回收 PV"></a>3. 回收 PV</h3><p>通过pvc回收pv<br>（1）当 PV 不再需要时，可通过删除 PVC 回收。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pvc</span>NAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGEmypvc1   Bound    mypv1    1Gi        RWO            nfs            22m<span class="token comment" spellcheck="true"># 删除pvc</span><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl delete pvc mypvc1</span>persistentvolumeclaim <span class="token string">"mypvc1"</span> deleted</code></pre><p>当 PVC mypvc1 被删除后，发现 Kubernetes 启动了一个新 Pod，这个 Pod 的作用就是清除 PV mypv1 的数据。这个时候再看 NFS 服务器目录 /data/NFS/k8s/pv1/ 中已经没有数据了</p><p><img src="/medias/loading.gif" data-original="/images/k8s/nfs/16373060619523.jpg" alt="data1"></p><p><strong>注意:</strong> 删除 mypvc1 时之前要停止与它相关的 pod ，不然 mypvc1一直处于 Terminating 状态</p><p>（2）当数据清除完毕，mypv1 的状态重新变为 Available，此时则可以被新的 PVC 申请。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pv</span>NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGEmypv1   1Gi        RWO            Recycle          Available           nfs                     67m</code></pre><p>（3）因为 PV 的回收策略设置为 Recycle，所以数据会被清除，但这可能不是我们想要的结果。如果我们希望保留数据，可以将策略设置为 Retain。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mypv1<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Retain  <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> nfs  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /data/NFS/k8s/pv1    <span class="token key atrule">server</span><span class="token punctuation">:</span> 192.168.11.101</code></pre><p>（4）通过 kubectl apply 更新 PV：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master pv<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl apply -f nfs-pv1.yaml</span>persistentvolume/mypv1 configured<span class="token punctuation">[</span>root@k8s-master pv<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pv</span>NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGEmypv1   1Gi        RWO            Retain           Available           nfs                     81m<span class="token punctuation">[</span>root@k8s-master pv<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#</span></code></pre><p>（5）回收策略已经变为 Retain，通过下面步骤验证其效果：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl exec mypod1 touch /mydata/hello</span>kubectl exec <span class="token punctuation">[</span>POD<span class="token punctuation">]</span> <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> is DEPRECATED and will be removed in a future version. Use kubectl exec <span class="token punctuation">[</span>POD<span class="token punctuation">]</span> <span class="token punctuation">-</span><span class="token punctuation">-</span> <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> instead.<span class="token key atrule">error</span><span class="token punctuation">:</span> unable to upgrade connection<span class="token punctuation">:</span> container not found ("mypod1")<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod</span>NAME                     READY   STATUS    RESTARTS   AGEmypod1                   1/1     Running   0          27snginx<span class="token punctuation">-</span>58dcb77688<span class="token punctuation">-</span>h8c5x   1/1     Running   0          4d<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl exec mypod1 touch /mydata/hello</span>kubectl exec <span class="token punctuation">[</span>POD<span class="token punctuation">]</span> <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> is DEPRECATED and will be removed in a future version. Use kubectl exec <span class="token punctuation">[</span>POD<span class="token punctuation">]</span> <span class="token punctuation">-</span><span class="token punctuation">-</span> <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> instead.<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl delete -f ../pod/pod1.yaml</span>pod "mypod1" deleted<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pvc</span>NAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGEmypvc1   Bound    mypv1    1Gi        RWO            nfs            3m48s<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl delete pvc mypvc1</span>persistentvolumeclaim "mypvc1" deleted<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pvc</span>No resources found in default namespace.<span class="token punctuation">[</span>root@k8s<span class="token punctuation">-</span>master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#</span></code></pre><p>（6）我们再看 NFS 服务器目录 /nfsdata/pv1 中数据还保留。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@rediscom pv1<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>hello<span class="token punctuation">[</span>root@rediscom pv1<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#</span></code></pre><p>（7）虽然 mypv1 中的数据得到了保留，但其 PV 状态会一直处于 Released，不能被其他 PVC 申请。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pv</span>NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS     CLAIM            STORAGECLASS   REASON   AGEmypv1   1Gi        RWO            Retain           Released   default/mypvc1   nfs                     89m</code></pre><p>8）为了重新使用存储资源，可以删除并重新创建 mypv1。删除操作只是删除了 PV 对象，存储空间中的数据并不会被删除。</p><p>新建的 mypv1 状态为 Available，已经可以被 PVC 申请。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl delete pv mypv1</span><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ubectl apply -f nfs-pv1.yaml</span><span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pv</span>NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGEmypv1   1Gi        RWO            Retain           Available           nfs                     2s<span class="token punctuation">[</span>root@k8s-master pvc<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#</span></code></pre><p>PV 还支持 Delete 的回收策略，会删除 PV 在 Storage Provider 上对应存储空间。NFS 的 PV 不支持 Delete，支持 Delete 的 Provider 有 AWS EBS、GCE PD、Azure Disk、OpenStack Cinder Volume 等</p><h3 id="4-PV的动态供给"><a href="#4-PV的动态供给" class="headerlink" title="4.  PV的动态供给"></a>4.  PV的动态供给</h3><p>pv的供给方式</p><p>前面的例子中，我们提前创建了 PV，然后通过 PVC 申请 PV 并在 Pod 中使用，这种方式叫做静态供给（Static Provision）。</p><p>与之对应的是动态供给（Dynamical Provision），即如果没有满足 PVC 条件的 PV，会动态创建 PV。相比静态供给，动态供给有明显的优势：不需要提前创建 PV，减少了管理员的工作量，效率高。</p><p>动态供给是通过 StorageClass 实现的，StorageClass 定义了如何创建 PV</p><p>pv动态供给举例<br>StorageClass standard：</p><p><img src="/medias/loading.gif" data-original="/images/k8s/nfs/16373075330215.jpg" alt="standard"></p><p>StorageClass slow：</p><p><img src="/medias/loading.gif" data-original="/images/k8s/nfs/16373075453270.jpg" alt="slow"></p><p>这两个 StorageClass 都会动态创建 AWS EBS，不同在于 standard 创建的是 gp2 类型的 EBS，而 slow 创建的是 io1 类型的 EBS。不同类型的 EBS 支持的参数可参考 AWS 官方文档。</p><p>StorageClass 支持 Delete 和 Retain 两种 reclaimPolicy，默认是 Delete。</p><p>与之前一样，PVC 在申请 PV 时，只需要指定 StorageClass 和容量以及访问模式，比如：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mypvc1<span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>   <span class="token punctuation">-</span> ReadWriteOnce <span class="token key atrule">resources</span><span class="token punctuation">:</span>   <span class="token key atrule">requests</span><span class="token punctuation">:</span>     <span class="token key atrule">storage</span><span class="token punctuation">:</span> 1Gi <span class="token key atrule">storageClassName</span><span class="token punctuation">:</span> standard</code></pre><p>除了 AWS EBS，Kubernetes 支持其他多种动态供给 PV 的 Provisioner，完整列表请参考 <a href="https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner">https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> nfs </tag>
            
            <tag> storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>traefik 简介</title>
      <link href="/2023/09/13/traefik/treafik-introduce/"/>
      <url>/2023/09/13/traefik/treafik-introduce/</url>
      
        <content type="html"><![CDATA[<h3 id="1-官方文档"><a href="#1-官方文档" class="headerlink" title="1. 官方文档"></a>1. 官方文档</h3><p><a href="https://doc.traefik.io/traefik/">https://doc.traefik.io/traefik/</a></p><h3 id="2-简介"><a href="#2-简介" class="headerlink" title="2. 简介"></a>2. 简介</h3><p>traefik是一个使你把微服务暴露出来变的更容易的http反向代理和负载均衡软件。traefik支持K8S、docker swarm、mesos、consul、etcd、zookeeper等基础设施组件，动态的应用它的配置文件设置。</p><h3 id="3-流量示意图"><a href="#3-流量示意图" class="headerlink" title="3. 流量示意图"></a>3. 流量示意图</h3><p><img src="/medias/loading.gif" data-original="http://file.longqiuhong.com/uploads/picgo/treafik-flow.png" alt="treafik-flow"></p><p>代理入口</p><p><img src="/medias/loading.gif" data-original="https://file.longqiuhong.com/uploads/picgo/route-flow.png" alt="route-flow"></p><p>路由：</p><p><img src="/medias/loading.gif" data-original="http://file.longqiuhong.com/uploads/picgo/routers.png" alt="routers"></p><h3 id="4-核心概念"><a href="#4-核心概念" class="headerlink" title="4. 核心概念"></a>4. 核心概念</h3><p>当启动Traefik时，需要定义<code>entrypoints</code>，然后通过entrypoints的路由来分析传入的请求，来查看他们是否是一组规则匹配，如果匹配，则路由可能将请求通过一系列的转换过来在发送到服务上去。</p><p><img src="/medias/loading.gif" data-original="https://file.longqiuhong.com/uploads/picgo/agence.png" alt="agence"></p><ul><li><code>Providers</code> 是基础组件，traefik的配置发现是通过它来实现，它可以是协调器，容器引擎，云提供商或键值存储，通过查询 Providers 的API来查询路由的相关信息，一旦检查变化，就会动态更新路由</li><li><code>Entrypoints</code>监听传入的流量，是网络的入口点，定义了接受请求的端口(HTTP或者TCP)</li><li><code>Routers</code>分析请求(host,path,headers,SSL等)，负责将传入的请求连接到可以处理这些请求的服务上去</li><li><code>Service</code>将请求转发给应用，负责配置如何最终将处理传入请求的实际服务</li><li><code>Middlewares</code>中间件，用来修改请求或者根据请求来做出判断，中间件被附件到路由上，是一种在请求发送到服务之前调整请求的一种方法</li></ul><h3 id="5-路由规则"><a href="#5-路由规则" class="headerlink" title="5. 路由规则"></a>5. 路由规则</h3><p>路由类型分为三种，分别为：<code>http</code>、<code>tcp</code>、<code>udp</code></p><p>路由规则是指，Traefik接收到的请求，根据给定规则路由到不同的服务中。</p><table><thead><tr><th>Rule</th><th>Description</th></tr></thead><tbody><tr><td>Headers(<code>key</code>, <code>value</code>)</td><td>Check if there is a key keydefined in the headers, with the value value</td></tr><tr><td>HeadersRegexp(<code>key</code>, <code>regexp</code>)</td><td>Check if there is a key keydefined in the headers, with a value that matches the regular expression regexp</td></tr><tr><td>Host(<code>example.com</code>, …)</td><td>Check if the request domain (host header value) targets one of the given domains.</td></tr><tr><td>HostHeader(<code>example.com</code>, …)</td><td>Check if the request domain (host header value) targets one of the given domains.</td></tr><tr><td>HostRegexp(<code>example.com</code>, <code>{subdomain:[a-z]+}.example.com</code>, …)</td><td>Check if the request domain matches the given regexp.</td></tr><tr><td>Method(<code>GET</code>, …)</td><td>Check if the request method is one of the given methods (GET, POST, PUT, DELETE, PATCH, HEAD)</td></tr><tr><td>Path(<code>/path</code>, <code>/articles/{cat:[a-z]+}/{id:[0-9]+}</code>, …)</td><td>Match exact request path. It accepts a sequence of literal and regular expression paths.</td></tr><tr><td>PathPrefix(<code>/products/</code>, <code>/articles/{cat:[a-z]+}/{id:[0-9]+}</code>)</td><td>Match request prefix path. It accepts a sequence of literal and regular expression prefix paths.</td></tr><tr><td>Query(<code>foo=bar</code>, <code>bar=baz</code>)</td><td>Match Query String parameters. It accepts a sequence of key=value pairs.</td></tr><tr><td>ClientIP(<code>10.0.0.0/16</code>, <code>::1</code>)</td><td>Match if the request client IP is one of the given IP/CIDR. It accepts IPv4, IPv6 and CIDR formats</td></tr></tbody></table><p>这个正则配起来稍微有点小坑</p><p>为了对<code>Host</code>和<code>Path</code>使用正则表达式，需要声明一个任意命名的变量，然后跟上用冒号分隔的正则表达式，所有这些都用花括号括起来。</p><pre class=" language-yaml"><code class="language-yaml">HostRegexp(`grafana.<span class="token punctuation">{</span>domain<span class="token punctuation">:</span>.*<span class="token punctuation">}</span>`)</code></pre><h3 id="6-服务"><a href="#6-服务" class="headerlink" title="6. 服务"></a>6. 服务</h3><p><img src="/medias/loading.gif" data-original="https://file.longqiuhong.com/uploads/picgo/services.png" alt="services"></p><p>服务负责配置如何到达实际的服务，最终将处理传入的请求。使用<code>service</code>定义：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">http</span><span class="token punctuation">:</span>  <span class="token key atrule">services</span><span class="token punctuation">:</span>    <span class="token key atrule">traefik</span><span class="token punctuation">:</span>      <span class="token key atrule">loadBalancer</span><span class="token punctuation">:</span>        <span class="token key atrule">servers</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">url</span><span class="token punctuation">:</span> <span class="token string">"http://127.0.0.1:10000"</span></code></pre><p>​更多配置，可以参考：<a href="https://doc.traefik.io/traefik/routing/services/">官网介绍</a></p><h3 id="7-中间件"><a href="#7-中间件" class="headerlink" title="7. 中间件"></a>7. 中间件</h3><p><img src="/medias/loading.gif" data-original="http://file.longqiuhong.com/uploads/picgo/middleware.png" alt="middleware"></p><p>从图中基本可以明白中间件的作用，也可以理解成拦截器。<br>Traefik中有几种可用的中间件：一些可以修改请求、请求头，一些负责重定向，一些可以添加身份验证等等。</p><p>下面是一个官网给出的示例：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># As YAML Configuration File</span><span class="token key atrule">http</span><span class="token punctuation">:</span>  <span class="token key atrule">routers</span><span class="token punctuation">:</span>    <span class="token key atrule">router1</span><span class="token punctuation">:</span>      <span class="token key atrule">service</span><span class="token punctuation">:</span> myService      <span class="token key atrule">middlewares</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token string">"foo-add-prefix"</span>      <span class="token key atrule">rule</span><span class="token punctuation">:</span> <span class="token string">"Host(`example.com`)"</span>  <span class="token key atrule">middlewares</span><span class="token punctuation">:</span>    <span class="token key atrule">foo-add-prefix</span><span class="token punctuation">:</span>      <span class="token key atrule">addPrefix</span><span class="token punctuation">:</span>        <span class="token key atrule">prefix</span><span class="token punctuation">:</span> <span class="token string">"/foo"</span>  <span class="token key atrule">services</span><span class="token punctuation">:</span>    <span class="token key atrule">service1</span><span class="token punctuation">:</span>      <span class="token key atrule">loadBalancer</span><span class="token punctuation">:</span>        <span class="token key atrule">servers</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">url</span><span class="token punctuation">:</span> <span class="token string">"http://127.0.0.1:80"</span></code></pre><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><ul><li><a href="https://github.com/traefik/traefik">Traefik源码仓库</a></li><li><a href="https://traefik.io/">Traefik官网</a></li><li><a href="https://doc.traefik.io/traefik/reference/static-configuration/file/">Traefik静态配置项-File provider</a></li><li><a href="https://letsencrypt.org/">Let’s Encrypt</a></li><li><a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">Systemd文档</a></li><li><a href="https://ormissia.github.io/posts/deployment/3003-linux-traefik/">ormissia blog</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> traefik </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> traefik </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InitContainers模式</title>
      <link href="/2023/09/09/k8s/initcontainers-mo-shi/"/>
      <url>/2023/09/09/k8s/initcontainers-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="initContainer使用"><a href="#initContainer使用" class="headerlink" title="initContainer使用"></a>initContainer使用</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>init容器是在同一个Pod中的其他容器之前启动和执行的容器。它的目的是<strong>为Pod上托管的主应用程序执行初始化逻辑</strong>。例如，创建必要的用户帐户、执行数据库迁移、创建数据库模式等等。</p><h2 id="Init-Containers-注意事项"><a href="#Init-Containers-注意事项" class="headerlink" title="Init Containers 注意事项"></a>Init Containers 注意事项</h2><p>在创建 init 容器时，应该考虑一些注意事项：</p><ol><li><p>它们总是在 Pod 中的其他容器之前执行。因此，它们不应包含需要很长时间才能完成的复杂逻辑。启动脚本通常小而简洁。如果您发现向 init 容器添加了太多逻辑，则应考虑将其中的一部分移至应用程序容器本身。</p></li><li><p>init 容器按顺序启动和执行。除非成功完成其前任容器，否则不会调用 init 容器。因此，如果启动任务很长，您可以考虑将其分解为多个步骤，每个步骤由一个 init 容器处理，以便您知道哪些步骤失败。</p></li><li><p>如果任何 init 容器失败，整个 Pod 将重新启动（除非您将 restartPolicy 设置为 Never）。重新启动 Pod 意味着再次重新执行所有容器，包括任何 init 容器。因此，您可能需要确保启动逻辑可以容忍多次执行而不会导致重复。例如，如果数据库迁移已经完成，再次执行迁移命令应该被忽略。</p></li><li><p>init 容器是延迟应用程序初始化直到一个或多个依赖项可用的良好候选者。例如，如果您的应用程序依赖于强加 API 请求速率限制的 API，您可能需要等待特定时间段才能接收来自该 API 的响应。在应用程序容器中实现这个逻辑可能很复杂；因为它需要与健康和准备探测器相结合。一个更简单的方法是创建一个 init 容器，它会等待 API 准备就绪后再成功退出。只有在 init 容器成功完成其工作后，应用程序容器才会启动。</p></li><li><p>Init 容器不能像应用程序容器那样使用健康和就绪探测。原因是它们旨在成功启动和退出，就像 Jobs 和 CronJobs 的行为方式一样。</p></li><li><p>同一个 Pod 上的所有容器共享相同的 Volumes 和网络。您可以利用此功能在应用程序及其初始化容器之间共享数据。</p></li></ol><h2 id="Init容器“Request”和“Limits”行为"><a href="#Init容器“Request”和“Limits”行为" class="headerlink" title="Init容器“Request”和“Limits”行为"></a>Init容器“Request”和“Limits”行为</h2><p>init 容器总是在同一个 Pod 上的其他应用程序容器之前启动。因此，调度程序对 init 容器的资源和限制给予更高的优先级。必须彻底考虑此类行为，因为它可能会导致不希望的结果。例如，如果你有一个 init 容器和一个应用程序容器，并且你将 init 容器的资源和限制设置为高于应用程序容器的资源和限制，那么只有在有一个满足 init 的可用节点时，整个 Pod 才会被调度容器要求。换句话说，即使有一个未使用的节点可以运行应用程序容器，如果 init 容器具有该节点可以处理的更高资源先决条件，Pod 也不会部署到该节点。因此，在定义 init 容器的请求和限制时，您应该尽可能严格。作为最佳实践，除非绝对需要，否则不要将这些参数设置为高于应用程序容器的值</p><h5 id="应用场景01：为数据库做种"><a href="#应用场景01：为数据库做种" class="headerlink" title="应用场景01：为数据库做种"></a>应用场景01：为数据库做种</h5><p>在这个场景中，我们为 MySQL 数据库提供服务。该数据库用于测试应用程序。它不必包含真实数据，但必须填充足够的数据，以便我们可以测试应用程序的查询速度。我们使用 init 容器来处理 SQL 转储文件的下载并将其恢复到托管在另一个容器中的数据库。</p><p>定义文件可能如下所示：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mydb  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> db<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">initContainers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> fetch      <span class="token key atrule">image</span><span class="token punctuation">:</span> mwendler/wget      <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"wget"</span><span class="token punctuation">,</span><span class="token string">"--no-check-certificate"</span><span class="token punctuation">,</span><span class="token string">"https://sample-videos.com/sql/Sample-SQL-File-1000rows.sql"</span><span class="token punctuation">,</span><span class="token string">"-O"</span><span class="token punctuation">,</span><span class="token string">"/docker-entrypoint-initdb.d/dump.sql"</span><span class="token punctuation">]</span>      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /docker<span class="token punctuation">-</span>entrypoint<span class="token punctuation">-</span>initdb.d          <span class="token key atrule">name</span><span class="token punctuation">:</span> dump  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mysql      <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql      <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> MYSQL_ROOT_PASSWORD          <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"example"</span>      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /docker<span class="token punctuation">-</span>entrypoint<span class="token punctuation">-</span>initdb.d          <span class="token key atrule">name</span><span class="token punctuation">:</span> dump  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> dump</code></pre><p>上面的定义创建了一个 Pod，它托管着两个容器：init 容器和应用程序容器。让我们来看看这个定义的有趣方面：</p><ol><li>init 容器负责下载包含数据库转储的 SQL 文件。我们使用 mwendler/wget 镜像，因为我们只需要 wget 命令。</li><li>下载的 SQL 的目标目录是 MySQL 镜像用来执行 SQL 文件的目录（/docker-entrypoint-initdb.d）。此行为内置于我们在应用程序容器中使用的 MySQL 镜像中。</li><li>init 容器将/docker-entrypoint-initdb.d挂载到emptyDir卷。因为两个容器都托管在同一个 Pod 上，所以它们共享相同的卷。因此，数据库容器可以访问放置在 emptyDir 卷上的 SQL 文件。</li></ol><h5 id="如果没有使用-InitContainers会发生什么？"><a href="#如果没有使用-InitContainers会发生什么？" class="headerlink" title="如果没有使用 InitContainers会发生什么？"></a>如果没有使用 InitContainers会发生什么？</h5><p>在这个例子中，我们使用初始化模式来建立关注点分离的最佳实践。如果我们在不使用 init 模式的情况下实现相同的逻辑，我们必须基于 mysql 基础镜像创建一个新镜像，安装 wget，并使用它来下载 SQL 文件。这种方法的缺点是：</p><p>如果我们需要对下载逻辑进行任何更改，我们需要创建一个新镜像，推送它并更改其在定义文件中的引用。这增加了必须维护自定义镜像的负担。</p><p>它在 DB 容器与其启动逻辑之间创建了紧密耦合的关系，这使得应用程序更难管理并增加了引入错误和错误的可能性。</p><h2 id="场景-02：延迟应用程序启动，直到依赖项准备就绪"><a href="#场景-02：延迟应用程序启动，直到依赖项准备就绪" class="headerlink" title="场景 02：延迟应用程序启动，直到依赖项准备就绪"></a>场景 02：延迟应用程序启动，直到依赖项准备就绪</h2><p>init 容器的另一个常见用例是当您需要应用程序等待另一个服务完全运行（响应请求）时。以下定义演示了这种情况：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp<span class="token punctuation">-</span>pod  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> myapp<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">initContainers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> init<span class="token punctuation">-</span>myservice    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox<span class="token punctuation">:</span><span class="token number">1.28</span>    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'sh'</span><span class="token punctuation">,</span> <span class="token string">'-c'</span><span class="token punctuation">,</span> <span class="token string">'until nslookup myservice; do echo waiting for myservice; sleep 2; done;'</span><span class="token punctuation">]</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp<span class="token punctuation">-</span>container    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox<span class="token punctuation">:</span><span class="token number">1.28</span>    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'sh'</span><span class="token punctuation">,</span> <span class="token string">'-c'</span><span class="token punctuation">,</span> <span class="token string">'echo The app is running! &amp;&amp; sleep 3600'</span><span class="token punctuation">]</span></code></pre><p>因此，假设我们的应用程序在 myapp-container 上运行时无法正常运行，除非 myservice 应用程序正在运行。我们需要延迟 myapp 启动，直到 myservice 准备就绪。为此，我们使用一个简单的 nslookup 命令（第 11 行）不断检查“myservice”的名称解析是否成功。如果 nslookup 能够解析“myservice”，则服务将启动。使用成功退出代码，init 容器终止，让应用程序容器启动。否则，容器在再次尝试之前会休眠两秒钟，从而延迟应用程序容器的启动。</p><p>为了完整起见，这是 myservice 的定义文件：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> myservice<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">9376</span></code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>初始化模式是设计需要启动逻辑的应用程序时要遵循的重要实践。</p><p>Kubernetes 提供 init 容器作为将应用程序逻辑与其启动过程分离的一种手段。</p><p>将应用程序初始化逻辑放在 init 容器中具有许多优点：</p><ol><li><p>您将强加关注点分离原则。一个应用程序可以有它的工程师团队，而它的初始化逻辑是由另一个团队编写的。</p></li><li><p>当涉及到授权和访问控制时，拥有一个单独的团队来处理应用程序的初始化步骤可以使公司更加灵活。例如，如果启动应用程序需要使用需要安全许可的资源（例如，修改防火墙规则），则可以由具有合适凭据的人员完成。应用团队不参与操作。</p></li><li><p>如果涉及的初始化步骤太多，可以将它们分解成多个 init 容器依次执行。如果一个步骤失败，init 容器会报告错误，这可以让您更好地了解逻辑的哪一部分不成功。</p></li></ol><p>使用 init 容器时应考虑以下几点：</p><ol><li><p>初始化容器在失败时重新启动。因此，他们的代码必须是幂等的。</p></li><li><p>初始化容器是请求和限制首先由调度程序检查。不正确的值可能会对调度程序关于放置整个 Pod（包括应用程序容器）的位置的决定产生负面影响。</p></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSI--容器储存接口</title>
      <link href="/2023/09/03/k8s/csi-fen-xi-rong-qi-chu-cun-jie-kou/"/>
      <url>/2023/09/03/k8s/csi-fen-xi-rong-qi-chu-cun-jie-kou/</url>
      
        <content type="html"><![CDATA[<h2 id="1-CSI简介–-储存接口"><a href="#1-CSI简介–-储存接口" class="headerlink" title="1. CSI简介– 储存接口"></a>1. CSI简介– 储存接口</h2><p>  k8s 的设计理念是支持可插拔架构，从而有利用扩展k8s 的功能。在次思想下，k8s 提供了 3 个特定功能得到接口，分别是：容器网络接口（CNI）、容器运行时接口（CRI）、容器储存接口（CSI）。本文主要介绍容器储存接口（CSI）。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-redis 教程</title>
      <link href="/2023/01/30/go-redis-jiao-cheng/"/>
      <url>/2023/01/30/go-redis-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="安装go-redis包"><a href="#安装go-redis包" class="headerlink" title="安装go-redis包"></a>安装go-redis包</h2><pre class=" language-bash"><code class="language-bash">go get github.com/redis/go-redis/v9</code></pre><h2 id="连接-redis-服务"><a href="#连接-redis-服务" class="headerlink" title="连接 redis 服务"></a>连接 redis 服务</h2><ol><li>使用 options 方式</li></ol><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/redis/go-redis/v9"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    rdb <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">NewClient</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>redis<span class="token punctuation">.</span>Options<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span>  <span class="token string">"localhost:6379"</span><span class="token punctuation">,</span>        Password<span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// no password set</span>        DB<span class="token punctuation">:</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// use default DB</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    res<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Ping</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>使用 dns 字符串方式</li></ol><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/redis/go-redis/v9"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注意 redis 是没有用户的，所以user 设置为空 </span>    opt<span class="token punctuation">,</span> err <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">ParseURL</span><span class="token punctuation">(</span><span class="token string">"redis://&lt;user>:&lt;pass>@localhost:6379/&lt;db>"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    rdb <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">NewClient</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span>    res<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Ping</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ol start="3"><li>连接 redis 服务设置连接名字</li></ol><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/redis/go-redis/v9"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注意 redis 是没有用户的，所以user 设置为空 </span>    opt<span class="token punctuation">,</span> err <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">ParseURL</span><span class="token punctuation">(</span><span class="token string">"redis://&lt;user>:&lt;pass>@localhost:6379/&lt;db>"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    rdb <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">NewClient</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span>    res<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Ping</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="redis-数据类型"><a href="#redis-数据类型" class="headerlink" title="redis 数据类型"></a>redis 数据类型</h2><p>redis 的数据类型有五种，分别为: 字符串(string)、列表(list)、集合(set)、哈希(hash)、有序集合(zset)</p><h3 id="操作字符串-string"><a href="#操作字符串-string" class="headerlink" title="操作字符串 (string)"></a>操作字符串 (string)</h3><ol><li>获取字符串内容执行命令</li></ol><p>redis 命令</p><pre class=" language-redis"><code class="language-redis">get mykey</code></pre><p>直接返回结果</p><pre class=" language-go"><code class="language-go">key <span class="token operator">:=</span> <span class="token string">"mykey"</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>val<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span></code></pre><p>保存命令并稍后分别访问值与错误</p><pre class=" language-go"><code class="language-go">key <span class="token operator">:=</span> <span class="token string">"mykey"</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>get <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> key<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>get<span class="token punctuation">.</span><span class="token function">Val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>执行go-redis包不支持的命令</p><pre class=" language-go"><code class="language-go">key <span class="token operator">:=</span> <span class="token string">"mykey"</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>val<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token string">"get"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> redis<span class="token punctuation">.</span>Nil <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"key dose not exists"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span></code></pre><pre class=" language-go"><code class="language-go">key <span class="token operator">:=</span> <span class="token string">"mykey"</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>val<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token string">"get"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> err<span class="token punctuation">)</span></code></pre><p>帮助函数完整列表:</p><pre class=" language-go"><code class="language-go">s<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span>flag<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Int</span><span class="token punctuation">(</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Int64</span><span class="token punctuation">(</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Uint64</span><span class="token punctuation">(</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Float32</span><span class="token punctuation">(</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Float64</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ss<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">StringSlice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ns<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Int64Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ns<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Uint64Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fs<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Float32Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fs<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Float64Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>bs<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">BoolSlice</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ol start="2"><li>设置字符串数据</li></ol><p>redis 命令</p><pre class=" language-redis"><code class="language-redis">set mykey "ddd" EX 10 </code></pre><p>go-redis </p><pre class=" language-go"><code class="language-go">key <span class="token operator">:=</span> <span class="token string">"mykey"</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>cmd <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token string">"ddd"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>   fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>cmd<span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>设置key到期的时间</p><pre class=" language-go"><code class="language-go">expireAt <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">AddDate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>args <span class="token operator">:=</span> redis<span class="token punctuation">.</span>SetArgs<span class="token punctuation">{</span>    ExpireAt<span class="token punctuation">:</span> expireAt<span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">SetArgs</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token string">"key"</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-redis 教程</title>
      <link href="/2023/01/30/traefik/go-redis-jiao-cheng/"/>
      <url>/2023/01/30/traefik/go-redis-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="安装go-redis包"><a href="#安装go-redis包" class="headerlink" title="安装go-redis包"></a>安装go-redis包</h2><pre class=" language-bash"><code class="language-bash">go get github.com/redis/go-redis/v9</code></pre><h2 id="连接-redis-服务"><a href="#连接-redis-服务" class="headerlink" title="连接 redis 服务"></a>连接 redis 服务</h2><ol><li>使用 options 方式</li></ol><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/redis/go-redis/v9"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    rdb <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">NewClient</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>redis<span class="token punctuation">.</span>Options<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span>  <span class="token string">"localhost:6379"</span><span class="token punctuation">,</span>        Password<span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// no password set</span>        DB<span class="token punctuation">:</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// use default DB</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    res<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Ping</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>使用 dns 字符串方式</li></ol><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/redis/go-redis/v9"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注意 redis 是没有用户的，所以user 设置为空 </span>    opt<span class="token punctuation">,</span> err <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">ParseURL</span><span class="token punctuation">(</span><span class="token string">"redis://&lt;user>:&lt;pass>@localhost:6379/&lt;db>"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    rdb <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">NewClient</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span>    res<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Ping</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ol start="3"><li>连接 redis 服务设置连接名字</li></ol><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/redis/go-redis/v9"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注意 redis 是没有用户的，所以user 设置为空 </span>    opt<span class="token punctuation">,</span> err <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">ParseURL</span><span class="token punctuation">(</span><span class="token string">"redis://&lt;user>:&lt;pass>@localhost:6379/&lt;db>"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    rdb <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">NewClient</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span>    res<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Ping</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="redis-数据类型"><a href="#redis-数据类型" class="headerlink" title="redis 数据类型"></a>redis 数据类型</h2><p>redis 的数据类型有五种，分别为: 字符串(string)、列表(list)、集合(set)、哈希(hash)、有序集合(zset)</p><h3 id="操作字符串-string"><a href="#操作字符串-string" class="headerlink" title="操作字符串 (string)"></a>操作字符串 (string)</h3><ol><li>获取字符串内容执行命令</li></ol><p>redis 命令</p><pre class=" language-redis"><code class="language-redis">get mykey</code></pre><p>直接返回结果</p><pre class=" language-go"><code class="language-go">key <span class="token operator">:=</span> <span class="token string">"mykey"</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>val<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span></code></pre><p>保存命令并稍后分别访问值与错误</p><pre class=" language-go"><code class="language-go">key <span class="token operator">:=</span> <span class="token string">"mykey"</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>get <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> key<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>get<span class="token punctuation">.</span><span class="token function">Val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>执行go-redis包不支持的命令</p><pre class=" language-go"><code class="language-go">key <span class="token operator">:=</span> <span class="token string">"mykey"</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>val<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token string">"get"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> redis<span class="token punctuation">.</span>Nil <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"key dose not exists"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span></code></pre><pre class=" language-go"><code class="language-go">key <span class="token operator">:=</span> <span class="token string">"mykey"</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>val<span class="token punctuation">,</span> err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token string">"get"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> err<span class="token punctuation">)</span></code></pre><p>帮助函数完整列表:</p><pre class=" language-go"><code class="language-go">s<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span>flag<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Int</span><span class="token punctuation">(</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Int64</span><span class="token punctuation">(</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Uint64</span><span class="token punctuation">(</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Float32</span><span class="token punctuation">(</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Float64</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ss<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">StringSlice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ns<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Int64Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ns<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Uint64Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fs<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Float32Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fs<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">Float64Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>bs<span class="token punctuation">,</span> err <span class="token operator">:=</span> cmd<span class="token punctuation">.</span><span class="token function">BoolSlice</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ol start="2"><li>设置字符串数据</li></ol><p>redis 命令</p><pre class=" language-redis"><code class="language-redis">set mykey "ddd" EX 10 </code></pre><p>go-redis </p><pre class=" language-go"><code class="language-go">key <span class="token operator">:=</span> <span class="token string">"mykey"</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>cmd <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token string">"ddd"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>   fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>cmd<span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>设置key到期的时间</p><pre class=" language-go"><code class="language-go">expireAt <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">AddDate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>args <span class="token operator">:=</span> redis<span class="token punctuation">.</span>SetArgs<span class="token punctuation">{</span>    ExpireAt<span class="token punctuation">:</span> expireAt<span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span>err <span class="token operator">:=</span> rdb<span class="token punctuation">.</span><span class="token function">SetArgs</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token string">"key"</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/28/hello-world/"/>
      <url>/2023/01/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 安装</title>
      <link href="/2023/01/28/git/git/"/>
      <url>/2023/01/28/git/git/</url>
      
        <content type="html"><![CDATA[<p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p><h2 id="Mac-install"><a href="#Mac-install" class="headerlink" title="Mac install"></a>Mac install</h2><pre class=" language-bash"><code class="language-bash">brew <span class="token function">install</span> <span class="token function">git</span></code></pre><h2 id="Ubuntu-install"><a href="#Ubuntu-install" class="headerlink" title="Ubuntu install"></a>Ubuntu install</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> <span class="token function">git</span></code></pre><h2 id="git-提交标准"><a href="#git-提交标准" class="headerlink" title="git 提交标准"></a>git 提交标准</h2><p><img src="/medias/loading.gif" data-original="http://file.longqiuhong.com/uploads/picgo/16315958305196.jpg" alt="git 提交标准"></p><h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><p><img src="/medias/loading.gif" data-original="https://file.longqiuhong.com/uploads/picgo/04453ab5aed44227919c808b392b48d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="git 常用的命令"></p><p>查看代码版本：</p><pre class=" language-sh"><code class="language-sh">git describe --always --tags --abbrev=0 --match 'v*' --exclude '*/*' | tr -d "[\r\n]"</code></pre><p>删除tag</p><pre class=" language-sh"><code class="language-sh">git tag --delete  tag name  // v本地git push origin :refs/tags/v1.0.0  // 删除远程 v1.0.0</code></pre><p>修改tag 名称</p><pre class=" language-sh"><code class="language-sh">git tag new_tag old_taggit tag -d old_taggit push origin :refs/tags/old_taggit push --tags</code></pre><p>删除远程分支</p><pre class=" language-sh"><code class="language-sh">git push origin --delete <branchName></code></pre><p>强制切换到 commit_id 这个记录</p><pre class=" language-sh"><code class="language-sh">git reset --hard commit_id</code></pre><p>强制提交到远程</p><pre class=" language-sh"><code class="language-sh">git push -f</code></pre><p>删除本地的远程不存在的分支</p><pre class=" language-sh"><code class="language-sh">git remote prune origin</code></pre><p><code>git commit</code>完之后，还没有执行<code>git push</code>，想修改/撤销这个<code>commit</code>，怎么办？<br>如果只是想修改注释，可以这样操作</p><pre class=" language-sh"><code class="language-sh">git commit --amend这个时候进入`vim`编辑，直接修改即可，修改完注释，退出`vim`编辑`:wq`保存已编辑的注释，重新`git push`即可</code></pre><p>要撤回commit</p><pre class=" language-sh"><code class="language-sh">git reset --soft HEAD^这样就能成功的撤回你刚刚的`commit`操作。HEAD^的意思是上一个版本，也可以写成HEAD~1如果你进行了2次commit，想都撤回，可以使用HEAD~2</code></pre><p><strong>注意，这个命令仅仅是撤回commit操作，写的代码仍然保留</strong></p><p>恢复本地未提交内容</p><pre class=" language-sh"><code class="language-sh">git checkout .</code></pre><pre class=" language-sh"><code class="language-sh">git reset HEAD  *# 回退到上一个版本git reset --hard HEAD^#回退到上上次版本git reset --hard HEAD^^git reset --hard HEAD^^^#回退到指定commitid的版本git reset --hard  commit_id</code></pre><p>恢复本地已提交内容</p><pre class=" language-sh"><code class="language-sh">git reset --hard</code></pre><p>恢复远程未提交内容</p><pre class=" language-sh"><code class="language-sh">git fetch origingit reset --hard origin/master</code></pre><h2 id="git-常见的错误处理"><a href="#git-常见的错误处理" class="headerlink" title="git 常见的错误处理"></a>git 常见的错误处理</h2><p>1、fatal: Not possible to fast-forward, aborting.</p><p>出现的原因：</p><p>两个分之同时改了同样的地方，造成冲突。一般的情况使用 merge  合并分支</p><pre class=" language-sh"><code class="language-sh">git checkout mastergit merge dev</code></pre><p>如果出现代码冲突的时候需要手动解决，但是有时候是无法合并成功的。</p><p>解决:</p><pre class=" language-sh"><code class="language-sh">git checkout mastergit rebase dev</code></pre><p>如果是一个分支，但是代码出现修改，也会出现改错误。</p><p>解决:</p><pre class=" language-sh"><code class="language-sh">git pull origin master --rebasegit pull origin development --rebasegit pull origin test --rebase</code></pre><p><strong>注意</strong> 修改冲突代码</p><p>在提交代码</p><pre class=" language-sh"><code class="language-sh">git push origin HEAD:develop     // develop 是分支</code></pre><p>在冲突解决完毕并且提交代码后，执行下面的命令：</p><pre class=" language-sh"><code class="language-sh">// 在终端也会有需要执行这个命令的提示git rebase --continue</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/28/traefik/hello-world/"/>
      <url>/2023/01/28/traefik/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
