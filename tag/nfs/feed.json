{
    "version": "https://jsonfeed.org/version/1",
    "title": "翼舞成梦",
    "subtitle": "翼舞成梦",
    "icon": "https://costalong.com/images/favicon.ico",
    "description": "",
    "home_page_url": "https://costalong.com",
    "items": [
        {
            "id": "https://costalong.com/2023/09/13/linux/ubuntu-install-nfs-server/",
            "url": "https://costalong.com/2023/09/13/linux/ubuntu-install-nfs-server/",
            "title": "ubuntu 安装 nfs",
            "date_published": "2023-09-13T10:49:02.000Z",
            "content_html": "<ol>\n<li>安装nfs服务</li>\n</ol>\n<pre class=\" language-sh\"><code class=\"language-sh\">sudo apt install nfs-kernel-server\n</code></pre>\n<ol start=\"2\">\n<li>编辑配置文件</li>\n</ol>\n<pre class=\" language-sh\"><code class=\"language-sh\">sudo vim /etc/exports\n\n# Example for NFSv4:\n# /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)\n# /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)\n#\n/data/nfs-share *(rw,sync,no_subtree_check,no_root_squash) \n</code></pre>\n<ol start=\"3\">\n<li>创建共享目录</li>\n</ol>\n<pre class=\" language-sh\"><code class=\"language-sh\">sudo mkdir -p /data/nfs-share\n</code></pre>\n<ol start=\"4\">\n<li>重启nfs服务</li>\n</ol>\n<pre class=\" language-sh\"><code class=\"language-sh\">sudo service nfs-kernel-server restart\n</code></pre>\n<ol start=\"5\">\n<li><p>常用命令工具</p>\n<p>已经安装的nfs无需安装客户端</p>\n</li>\n</ol>\n<pre class=\" language-sh\"><code class=\"language-sh\"># 显示已经mount到本机上\nsudo showmount -e localhost\n# 将配置文件中的目录全部重新 Export一次，无需重启\nsudo exportfs -rv\n# 查看nfs的运行状态\nsudo nfsstat\n#查看rpc执行信息，可以用于检测rpc运行情况\nsudo rpcinfo\n\n#查看网络端口，NFS默认是使用111端口。\nsudo netstat -tu -4\n</code></pre>\n<ol start=\"6\">\n<li>客户端的命令</li>\n</ol>\n<pre class=\" language-sh\"><code class=\"language-sh\"># 安装客户端命令\nsudo apt install nfs-common\n</code></pre>\n<ol start=\"7\">\n<li>显示指定的（192.168.2.167）NFS服务器上export出来的目录</li>\n</ol>\n<pre class=\" language-sh\"><code class=\"language-sh\">sudo showmount -e 192.168.2.167\n</code></pre>\n<ol start=\"8\">\n<li>创建本地挂载目录</li>\n</ol>\n<pre class=\" language-sh\"><code class=\"language-sh\">sudo mkdir -p /mnt/data\n</code></pre>\n<ol start=\"9\">\n<li>挂载共享目录</li>\n</ol>\n<pre class=\" language-sh\"><code class=\"language-sh\">sudo mount -t nfs 192.168.3.167:/data/nfs-share /mnt/data\n</code></pre>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "linux",
                "nfs",
                "storage"
            ]
        },
        {
            "id": "https://costalong.com/2023/09/13/k8s/k8s-install-nfs/",
            "url": "https://costalong.com/2023/09/13/k8s/k8s-install-nfs/",
            "title": "nfs实现k8s持久化",
            "date_published": "2023-09-13T10:37:51.000Z",
            "content_html": "<h3 id=\"1-部署nfs服务端\"><a href=\"#1-部署nfs服务端\" class=\"headerlink\" title=\"1. 部署nfs服务端\"></a>1. 部署nfs服务端</h3><p>在任意一台服务器上安装</p>\n<p>（1）安装nfs服务:</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">yum <span class=\"token function\">install</span> -y nfs-utils rpcbind\nvim /etc/exports\n/nfsdata *<span class=\"token punctuation\">(</span>rw,no_root_squash,no_all_squash,sync<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>（2）保存配置文件后，执行如下操作：<br>在服务端创建对应的目录和赋予权限：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"> <span class=\"token function\">mkdir</span> /nfsdata\n <span class=\"token function\">chmod</span> 777 /nfsdata\n</code></pre>\n<p>（3） 启动rpcbind和nfs服务：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">systemctl start rpcbind <span class=\"token operator\">&amp;&amp;</span> systemctl <span class=\"token function\">enable</span> rpcbind\nsystemctl start nfs <span class=\"token operator\">&amp;&amp;</span> systemctl <span class=\"token function\">enable</span> nfs\n</code></pre>\n<p>（4）每个node安装nfs工具</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"> yum <span class=\"token function\">install</span> -y nfs-utils \n</code></pre>\n<p>（5） 每个node查询NFS服务器</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">showmount -e nfs-ip\nshowmount -e 192.168.11.101\n</code></pre>\n<h4 id=\"NFS-PersistentVolume\"><a href=\"#NFS-PersistentVolume\" class=\"headerlink\" title=\"NFS PersistentVolume\"></a>NFS PersistentVolume</h4><p>（1）下面创建一个 PV mypv1，配置文件 nfs-pv1.yml 如下：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> PersistentVolume\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypv1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">capacity</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> 1Gi\n  <span class=\"token key atrule\">accessModes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> ReadWriteOnce\n  <span class=\"token key atrule\">persistentVolumeReclaimPolicy</span><span class=\"token punctuation\">:</span> Recycle\n  <span class=\"token key atrule\">storageClassName</span><span class=\"token punctuation\">:</span> nfs\n  <span class=\"token key atrule\">nfs</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">path</span><span class=\"token punctuation\">:</span> /data/NFS/k8s/pv1\n    <span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span> 192.168.11.101\n</code></pre>\n<p>① capacity 指定 PV 的容量为 1G。</p>\n<p>② accessModes 指定访问模式为 ReadWriteOnce，支持的访问模式有：</p>\n<p>ReadWriteOnce – PV 能以 read-write 模式 mount 到单个节点。</p>\n<p>ReadOnlyMany – PV 能以 read-only 模式 mount 到多个节点。</p>\n<p>ReadWriteMany – PV 能以 read-write 模式 mount 到多个节点。</p>\n<p>③ persistentVolumeReclaimPolicy 指定当 PV 的回收策略为 Recycle，支持的策略有：</p>\n<p>Retain – 需要管理员手工回收。</p>\n<p>Recycle – 清除 PV 中的数据，效果相当于执行 rm -rf /thevolume/*。</p>\n<p>Delete – 删除 Storage Provider 上的对应存储资源，例如 AWS EBS、GCE PD、Azure Disk、OpenStack Cinder Volume 等。</p>\n<p>④ storageClassName 指定 PV 的 class 为 nfs。相当于为 PV 设置了一个分类，PVC 可以指定 class 申请相应 class 的 PV。</p>\n<p>⑤ 指定 PV 在 NFS 服务器上对应的目录。</p>\n<p>注意要做storage-provider段要提前建好文件夹</p>\n<p>注意要做storage-provider段要提前建好文件夹</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>dev@rediscom k8s<span class=\"token punctuation\">]</span>$ <span class=\"token function\">ls</span>\npv1\n</code></pre>\n<p>（2）创建 mypv1：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">kubectl apply -f nfs-pv1.yaml\n</code></pre>\n<p>（3）查看 mypv1：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">kubectl get <span class=\"token function\">pv</span>\n</code></pre>\n<p><img src=\"/medias/loading.gif\" data-original=\"/images/k8s/nfs/16373020145856.jpg\" alt=\"pv\"></p>\n<p>STATUS 为 Available，表示 mypv1 就绪，可以被 PVC 申请。</p>\n<h4 id=\"创建-PVC\"><a href=\"#创建-PVC\" class=\"headerlink\" title=\"创建 PVC\"></a>创建 PVC</h4><p>(1）接下来创建 PVC mypvc1，配置文件 nfs-pvc1.yml 如下：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> PersistentVolumeClaim\n<span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypvc1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">accessModes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> ReadWriteOnce\n  <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">requests</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> 1Gi\n  <span class=\"token key atrule\">storageClassName</span><span class=\"token punctuation\">:</span> nfs\n</code></pre>\n<p>PVC 就很简单了，只需要指定 PV 的容量，访问模式和 class。</p>\n<p>（2）创建 mypvc1：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl apply -f nfs-pvc1.yml</span>\npersistentvolumeclaim/mypvc1 created\n<span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pvc</span>\nNAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE\nmypvc1   Bound    mypv1    1Gi        RWO            nfs            11s\n</code></pre>\n<p>从 kubectl get pvc 和 kubectl get pv 的输出可以看到 mypvc1 已经 Bound 到 mypv1，申请成功。</p>\n<h3 id=\"2-Pod使用pvc\"><a href=\"#2-Pod使用pvc\" class=\"headerlink\" title=\"2 Pod使用pvc\"></a>2 Pod使用pvc</h3><p>（1）接下来就可以在 Pod 中使用存储了，Pod 配置文件 pod1.yml 如下：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Pod\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypod1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypod1\n      <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> busybox\n      <span class=\"token key atrule\">args</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> /bin/sh\n      <span class=\"token punctuation\">-</span> <span class=\"token punctuation\">-</span>c\n      <span class=\"token punctuation\">-</span> sleep 30000\n      <span class=\"token key atrule\">volumeMounts</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">mountPath</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"mydata\"</span>\n        <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mydata\n  <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mydata\n      <span class=\"token key atrule\">persistentVolumeClaim</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">claimName</span><span class=\"token punctuation\">:</span> mypvc1\n</code></pre>\n<p>与使用普通 Volume 的格式类似，在 volumes 中过 persistentVolumeClaim 指定使用 mypvc1 申请的 Volume。</p>\n<p>（2）创建 mypod1：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pod<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl apply -f pod1.yaml</span>\npod/mypod1 created\n<span class=\"token punctuation\">[</span>root@k8s-master pod<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pod -o wide</span>\nNAME                     READY   STATUS              RESTARTS   AGE     IP              NODE        NOMINATED NODE   READINESS GATES\nmypod1                   0/1     ContainerCreating   0          20s     <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>          k8s-node4   <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>           <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>\nnginx-58dcb77688-h8c5x   1/1     Running             0          3d23h   172.31.156.68   k8s-node1   <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>           <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>\n</code></pre>\n<p>（3）验证 PV 是否可用：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">kubectl <span class=\"token function\">exec</span> mypod1 <span class=\"token function\">touch</span> /mydata/hello\n</code></pre>\n<p>查看生成文件</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@rediscom ~<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># cd /data/NFS/k8s/pv1/</span>\n<span class=\"token punctuation\">[</span>root@rediscom pv1<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># ls</span>\nhello\n</code></pre>\n<p>可见，在 Pod 中创建的文件 /mydata/hello 确实已经保存到了 NFS 服务器目录 /nfsdata/pv1 中。</p>\n<p>如果不再需要使用 PV，可用删除 PVC 回收 PV。</p>\n<h3 id=\"3-回收-PV\"><a href=\"#3-回收-PV\" class=\"headerlink\" title=\"3. 回收 PV\"></a>3. 回收 PV</h3><p>通过pvc回收pv<br>（1）当 PV 不再需要时，可通过删除 PVC 回收。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pvc</span>\nNAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE\nmypvc1   Bound    mypv1    1Gi        RWO            nfs            22m\n<span class=\"token comment\" spellcheck=\"true\"># 删除pvc</span>\n<span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl delete pvc mypvc1</span>\npersistentvolumeclaim <span class=\"token string\">\"mypvc1\"</span> deleted\n</code></pre>\n<p>当 PVC mypvc1 被删除后，发现 Kubernetes 启动了一个新 Pod，这个 Pod 的作用就是清除 PV mypv1 的数据。这个时候再看 NFS 服务器目录 /data/NFS/k8s/pv1/ 中已经没有数据了</p>\n<p><img src=\"/medias/loading.gif\" data-original=\"/images/k8s/nfs/16373060619523.jpg\" alt=\"data1\"></p>\n<p><strong>注意:</strong> 删除 mypvc1 时之前要停止与它相关的 pod ，不然 mypvc1一直处于 Terminating 状态</p>\n<p>（2）当数据清除完毕，mypv1 的状态重新变为 Available，此时则可以被新的 PVC 申请。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pv</span>\nNAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE\nmypv1   1Gi        RWO            Recycle          Available           nfs                     67m\n</code></pre>\n<p>（3）因为 PV 的回收策略设置为 Recycle，所以数据会被清除，但这可能不是我们想要的结果。如果我们希望保留数据，可以将策略设置为 Retain。</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> PersistentVolume\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypv1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">capacity</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> 1Gi\n  <span class=\"token key atrule\">accessModes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> ReadWriteOnce\n  <span class=\"token key atrule\">persistentVolumeReclaimPolicy</span><span class=\"token punctuation\">:</span> Retain\n  <span class=\"token key atrule\">storageClassName</span><span class=\"token punctuation\">:</span> nfs\n  <span class=\"token key atrule\">nfs</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">path</span><span class=\"token punctuation\">:</span> /data/NFS/k8s/pv1\n    <span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span> 192.168.11.101\n</code></pre>\n<p>（4）通过 kubectl apply 更新 PV：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pv<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl apply -f nfs-pv1.yaml</span>\npersistentvolume/mypv1 configured\n<span class=\"token punctuation\">[</span>root@k8s-master pv<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pv</span>\nNAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE\nmypv1   1Gi        RWO            Retain           Available           nfs                     81m\n<span class=\"token punctuation\">[</span>root@k8s-master pv<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\">#</span>\n</code></pre>\n<p>（5）回收策略已经变为 Retain，通过下面步骤验证其效果：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl exec mypod1 touch /mydata/hello</span>\nkubectl exec <span class=\"token punctuation\">[</span>POD<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> is DEPRECATED and will be removed in a future version. Use kubectl exec <span class=\"token punctuation\">[</span>POD<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span> <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> instead.\n<span class=\"token key atrule\">error</span><span class=\"token punctuation\">:</span> unable to upgrade connection<span class=\"token punctuation\">:</span> container not found (\"mypod1\")\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pod</span>\nNAME                     READY   STATUS    RESTARTS   AGE\nmypod1                   1/1     Running   0          27s\nnginx<span class=\"token punctuation\">-</span>58dcb77688<span class=\"token punctuation\">-</span>h8c5x   1/1     Running   0          4d\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl exec mypod1 touch /mydata/hello</span>\nkubectl exec <span class=\"token punctuation\">[</span>POD<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> is DEPRECATED and will be removed in a future version. Use kubectl exec <span class=\"token punctuation\">[</span>POD<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span> <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> instead.\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl delete -f ../pod/pod1.yaml</span>\npod \"mypod1\" deleted\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pvc</span>\nNAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE\nmypvc1   Bound    mypv1    1Gi        RWO            nfs            3m48s\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl delete pvc mypvc1</span>\npersistentvolumeclaim \"mypvc1\" deleted\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pvc</span>\nNo resources found in default namespace.\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\">#</span>\n</code></pre>\n<p>（6）我们再看 NFS 服务器目录 /nfsdata/pv1 中数据还保留。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@rediscom pv1<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># ls</span>\nhello\n<span class=\"token punctuation\">[</span>root@rediscom pv1<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\">#</span>\n</code></pre>\n<p>（7）虽然 mypv1 中的数据得到了保留，但其 PV 状态会一直处于 Released，不能被其他 PVC 申请。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pv</span>\nNAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS     CLAIM            STORAGECLASS   REASON   AGE\nmypv1   1Gi        RWO            Retain           Released   default/mypvc1   nfs                     89m\n</code></pre>\n<p>8）为了重新使用存储资源，可以删除并重新创建 mypv1。删除操作只是删除了 PV 对象，存储空间中的数据并不会被删除。</p>\n<p>新建的 mypv1 状态为 Available，已经可以被 PVC 申请。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl delete pv mypv1</span>\n<span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># ubectl apply -f nfs-pv1.yaml</span>\n<span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pv</span>\nNAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE\nmypv1   1Gi        RWO            Retain           Available           nfs                     2s\n<span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\">#</span>\n</code></pre>\n<p>PV 还支持 Delete 的回收策略，会删除 PV 在 Storage Provider 上对应存储空间。NFS 的 PV 不支持 Delete，支持 Delete 的 Provider 有 AWS EBS、GCE PD、Azure Disk、OpenStack Cinder Volume 等</p>\n<h3 id=\"4-PV的动态供给\"><a href=\"#4-PV的动态供给\" class=\"headerlink\" title=\"4.  PV的动态供给\"></a>4.  PV的动态供给</h3><p>pv的供给方式</p>\n<p>前面的例子中，我们提前创建了 PV，然后通过 PVC 申请 PV 并在 Pod 中使用，这种方式叫做静态供给（Static Provision）。</p>\n<p>与之对应的是动态供给（Dynamical Provision），即如果没有满足 PVC 条件的 PV，会动态创建 PV。相比静态供给，动态供给有明显的优势：不需要提前创建 PV，减少了管理员的工作量，效率高。</p>\n<p>动态供给是通过 StorageClass 实现的，StorageClass 定义了如何创建 PV</p>\n<p>pv动态供给举例<br>StorageClass standard：</p>\n<p><img src=\"/medias/loading.gif\" data-original=\"/images/k8s/nfs/16373075330215.jpg\" alt=\"standard\"></p>\n<p>StorageClass slow：</p>\n<p><img src=\"/medias/loading.gif\" data-original=\"/images/k8s/nfs/16373075453270.jpg\" alt=\"slow\"></p>\n<p>这两个 StorageClass 都会动态创建 AWS EBS，不同在于 standard 创建的是 gp2 类型的 EBS，而 slow 创建的是 io1 类型的 EBS。不同类型的 EBS 支持的参数可参考 AWS 官方文档。</p>\n<p>StorageClass 支持 Delete 和 Retain 两种 reclaimPolicy，默认是 Delete。</p>\n<p>与之前一样，PVC 在申请 PV 时，只需要指定 StorageClass 和容量以及访问模式，比如：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> PersistentVolumeClaim\n<span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypvc1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n <span class=\"token key atrule\">accessModes</span><span class=\"token punctuation\">:</span>\n   <span class=\"token punctuation\">-</span> ReadWriteOnce\n <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n   <span class=\"token key atrule\">requests</span><span class=\"token punctuation\">:</span>\n     <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> 1Gi\n <span class=\"token key atrule\">storageClassName</span><span class=\"token punctuation\">:</span> standard\n</code></pre>\n<p>除了 AWS EBS，Kubernetes 支持其他多种动态供给 PV 的 Provisioner，完整列表请参考 <a href=\"https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner\">https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner</a></p>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "k8s",
                "k8s",
                "nfs",
                "storage"
            ]
        }
    ]
}