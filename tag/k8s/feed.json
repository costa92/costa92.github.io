{
    "version": "https://jsonfeed.org/version/1",
    "title": "翼舞成梦",
    "subtitle": "翼舞成梦",
    "icon": "https://costalong.com/images/favicon.ico",
    "description": "",
    "home_page_url": "https://costalong.com",
    "items": [
        {
            "id": "https://costalong.com/2023/09/14/k8s/pod-elegant-stop/",
            "url": "https://costalong.com/2023/09/14/k8s/pod-elegant-stop/",
            "title": "pods 优雅终止",
            "date_published": "2023-09-14T14:08:44.000Z",
            "content_html": "<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Pod 销毁时，会停止容器内的进程，通常在停止的过程中我们需要执行一些善后逻辑，比如等待存量请求处理完以避免连接中断，或通知相关依赖进行清理等，从而实现优雅终止目的。本文介绍在 Kubernetes 场景下，实现容器优雅终止的最佳实践。</p>\n<h2 id=\"当-Kubernetes-杀死一个-pod-时，会发生以下-5-个步骤：\"><a href=\"#当-Kubernetes-杀死一个-pod-时，会发生以下-5-个步骤：\" class=\"headerlink\" title=\"当 Kubernetes 杀死一个 pod 时，会发生以下 5 个步骤：\"></a>当 Kubernetes 杀死一个 pod 时，会发生以下 5 个步骤：</h2><ol>\n<li>Pod 切换到终止状态并停止接收任何新流量，容器仍在 pod 内运行。</li>\n<li>preStop 钩子是一个特殊的命令或 HTTP 请求被执行，并被发送到 pod 内的容器。</li>\n<li>SIGTERM 信号被发送到 pod，容器意识到它将很快关闭。</li>\n<li>Kubernetes 等待宽限期 (terminationGracePeriodSeconds)。此等待与 preStop hook 和 SIGTERM 信号执行并行（默认 30 秒）。因此，Kubernetes 不会等待这些完成。如果这段时间结束，则直接进入下一步。正确设置宽限期的值非常重要。</li>\n<li>向 pod 发送 SIGKILL 信号，然后移除 pod。如果容器在宽限期后仍在运行，则 Pod 被 SIGKILL 强行移除，终止完成。</li>\n</ol>\n<p>总结下大致分为两步，第一步定义 preStop，一般情况下可以休眠 30s，用于处理残余流量；第二步发送 SIGTERM 信号，服务收到信号后进行服务的收尾工作处理。比如：关闭连接、通知第三方注册中心服务关闭…..</p>\n<h2 id=\"Pods-生命周期的状态\"><a href=\"#Pods-生命周期的状态\" class=\"headerlink\" title=\"Pods 生命周期的状态\"></a>Pods 生命周期的状态</h2><p>phase表示一个Pod处于其生命周期的哪个阶段，一共有以下5个可能的取值：</p>\n<ol>\n<li>Pending：Pod已经被k8s系统接受，但Pod中还有容器没有被创建。Pod被调度前和下载容器镜像的时候都处于这个阶段</li>\n<li>Running：Pod已经被调度到Node上，所有的容器都已经被创建，并且至少有一个容器还在运行中（正在启动或重启中的容器也算）</li>\n<li>Succeeded：Pod中的所有容器都成功停止，并且不会再次重启</li>\n<li>Failed：Pod中的所有容器都已经停止，并且至少有一个容器是以失败停止的（以非0状态退出或被系统强制停止）</li>\n<li>Unknown：由于某种原因无法获得Pod的状态，一般是和Pod所在的Host出现通信问题导致</li>\n</ol>\n<p>Pod phase的查看方式：</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">kubectl get pods whoami-78c854646d-nhgl9 -o yaml |grep 'phase:'\n</code></pre>\n<p>输出：</p>\n<pre class=\" language-shell\"><code class=\"language-shell\"> phase: Running\n</code></pre>\n<h2 id=\"k8s-lifecycle-用法\"><a href=\"#k8s-lifecycle-用法\" class=\"headerlink\" title=\"k8s lifecycle 用法\"></a>k8s lifecycle 用法</h2><p>lifecycle 周期有两个hook钩子 postStart 与 preStop  </p>\n<ol>\n<li>PostStart hook是在容器创建(created)之后立马被调用，并且PostStart跟容器的ENTRYPOINT是异步执行的，无法保证它们之间的顺序.</li>\n<li>PreStop hook是容器处于Terminated状态时立马被调用(也就是说要是Job任务的话，执行完之后其状态为completed，所以不会触发PreStop的钩子)，同时PreStop是同步阻塞的，PreStop执行完才会执行删除Pod的操作</li>\n</ol>\n<p>注意:<br>PostStart 会阻塞容器成为Running状态,PreStop 会阻塞容器的删除，但是过了 terminationGracePeriodSeconds时间后，容器会被强制删除,<br>如果PreStop或者PostStart失败的话, 容器会被杀死;</p>\n<h3 id=\"钩子的回调函数支持三种方式定义动作：\"><a href=\"#钩子的回调函数支持三种方式定义动作：\" class=\"headerlink\" title=\"钩子的回调函数支持三种方式定义动作：\"></a>钩子的回调函数支持三种方式定义动作：</h3><ol>\n<li>exec：在容器内执行命令，如果命令的退出状态码是 0 表示执行成功，否则表示失败</li>\n</ol>\n<pre class=\" language-yaml\"><code class=\"language-yaml\">  lifecycle：\n    <span class=\"token key atrule\">postStart</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">exec</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> cat\n        <span class=\"token punctuation\">-</span> /tmp/healthy\n</code></pre>\n<ol start=\"2\">\n<li>httpGet：向指定 URL 发起 GET 请求，如果返回的 HTTP 状态码在 [200, 400) 之间表示请求成功，否则表示失败</li>\n</ol>\n<pre class=\" language-yaml\"><code class=\"language-yaml\">lifecycle：\n    <span class=\"token key atrule\">postStart</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">httpGet</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">path</span><span class=\"token punctuation\">:</span> /login   <span class=\"token comment\" spellcheck=\"true\"># URI地址</span>\n        <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">80  </span><span class=\"token comment\" spellcheck=\"true\"># 端口号</span>\n        <span class=\"token key atrule\">host</span><span class=\"token punctuation\">:</span> 192.168.126.100 <span class=\"token comment\" spellcheck=\"true\"># 主机地址</span>\n        <span class=\"token key atrule\">scheme</span><span class=\"token punctuation\">:</span> HTTP   <span class=\"token comment\" spellcheck=\"true\"># 支持的协议，http或https</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># http://192.168.126.100:80/login</span>\n</code></pre>\n<ol start=\"3\">\n<li>TCPSocket：在容器尝试访问指定的socket</li>\n</ol>\n<pre class=\" language-yaml\"><code class=\"language-yaml\">  lifecycle：\n    <span class=\"token key atrule\">postStart</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">tcpSocket</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8080</span>\n</code></pre>\n<p>Example:</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> apps/v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Deployment\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">creationTimestamp</span><span class=\"token punctuation\">:</span> <span class=\"token null important\">null</span>\n  <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> nginx\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> nginx\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">replicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n  <span class=\"token key atrule\">selector</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">matchLabels</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> nginx\n  <span class=\"token key atrule\">strategy</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token key atrule\">template</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">creationTimestamp</span><span class=\"token punctuation\">:</span> <span class=\"token null important\">null</span>\n      <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> nginx\n    <span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> nginx\n          <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> nginx\n          <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n          <span class=\"token key atrule\">lifecycle</span><span class=\"token punctuation\">:</span>\n            <span class=\"token key atrule\">postStart</span><span class=\"token punctuation\">:</span>\n              <span class=\"token key atrule\">exec</span><span class=\"token punctuation\">:</span>\n                <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"/bin/sh\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"-c\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"echo 11 >> /usr/share/nginx/html/index.html\"</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\" spellcheck=\"true\"># 启动容器应用之后执行</span>\n            <span class=\"token key atrule\">preStop</span><span class=\"token punctuation\">:</span>\n              <span class=\"token key atrule\">exec</span><span class=\"token punctuation\">:</span>\n                <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"/bin/sh\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"-c\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"echo 'Hello from the preStop handler' >> /var/log/nginx/message\"</span><span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\">## 删除pod 完成之前执行</span>\n<span class=\"token key atrule\">status</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code></pre>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "k8s",
                "k8s",
                "pods"
            ]
        },
        {
            "id": "https://costalong.com/2023/09/13/k8s/k8s-install-nfs/",
            "url": "https://costalong.com/2023/09/13/k8s/k8s-install-nfs/",
            "title": "nfs实现k8s持久化",
            "date_published": "2023-09-13T10:37:51.000Z",
            "content_html": "<h3 id=\"1-部署nfs服务端\"><a href=\"#1-部署nfs服务端\" class=\"headerlink\" title=\"1. 部署nfs服务端\"></a>1. 部署nfs服务端</h3><p>在任意一台服务器上安装</p>\n<p>（1）安装nfs服务:</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">yum <span class=\"token function\">install</span> -y nfs-utils rpcbind\nvim /etc/exports\n/nfsdata *<span class=\"token punctuation\">(</span>rw,no_root_squash,no_all_squash,sync<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>（2）保存配置文件后，执行如下操作：<br>在服务端创建对应的目录和赋予权限：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"> <span class=\"token function\">mkdir</span> /nfsdata\n <span class=\"token function\">chmod</span> 777 /nfsdata\n</code></pre>\n<p>（3） 启动rpcbind和nfs服务：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">systemctl start rpcbind <span class=\"token operator\">&amp;&amp;</span> systemctl <span class=\"token function\">enable</span> rpcbind\nsystemctl start nfs <span class=\"token operator\">&amp;&amp;</span> systemctl <span class=\"token function\">enable</span> nfs\n</code></pre>\n<p>（4）每个node安装nfs工具</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"> yum <span class=\"token function\">install</span> -y nfs-utils \n</code></pre>\n<p>（5） 每个node查询NFS服务器</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">showmount -e nfs-ip\nshowmount -e 192.168.11.101\n</code></pre>\n<h4 id=\"NFS-PersistentVolume\"><a href=\"#NFS-PersistentVolume\" class=\"headerlink\" title=\"NFS PersistentVolume\"></a>NFS PersistentVolume</h4><p>（1）下面创建一个 PV mypv1，配置文件 nfs-pv1.yml 如下：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> PersistentVolume\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypv1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">capacity</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> 1Gi\n  <span class=\"token key atrule\">accessModes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> ReadWriteOnce\n  <span class=\"token key atrule\">persistentVolumeReclaimPolicy</span><span class=\"token punctuation\">:</span> Recycle\n  <span class=\"token key atrule\">storageClassName</span><span class=\"token punctuation\">:</span> nfs\n  <span class=\"token key atrule\">nfs</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">path</span><span class=\"token punctuation\">:</span> /data/NFS/k8s/pv1\n    <span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span> 192.168.11.101\n</code></pre>\n<p>① capacity 指定 PV 的容量为 1G。</p>\n<p>② accessModes 指定访问模式为 ReadWriteOnce，支持的访问模式有：</p>\n<p>ReadWriteOnce – PV 能以 read-write 模式 mount 到单个节点。</p>\n<p>ReadOnlyMany – PV 能以 read-only 模式 mount 到多个节点。</p>\n<p>ReadWriteMany – PV 能以 read-write 模式 mount 到多个节点。</p>\n<p>③ persistentVolumeReclaimPolicy 指定当 PV 的回收策略为 Recycle，支持的策略有：</p>\n<p>Retain – 需要管理员手工回收。</p>\n<p>Recycle – 清除 PV 中的数据，效果相当于执行 rm -rf /thevolume/*。</p>\n<p>Delete – 删除 Storage Provider 上的对应存储资源，例如 AWS EBS、GCE PD、Azure Disk、OpenStack Cinder Volume 等。</p>\n<p>④ storageClassName 指定 PV 的 class 为 nfs。相当于为 PV 设置了一个分类，PVC 可以指定 class 申请相应 class 的 PV。</p>\n<p>⑤ 指定 PV 在 NFS 服务器上对应的目录。</p>\n<p>注意要做storage-provider段要提前建好文件夹</p>\n<p>注意要做storage-provider段要提前建好文件夹</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>dev@rediscom k8s<span class=\"token punctuation\">]</span>$ <span class=\"token function\">ls</span>\npv1\n</code></pre>\n<p>（2）创建 mypv1：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">kubectl apply -f nfs-pv1.yaml\n</code></pre>\n<p>（3）查看 mypv1：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">kubectl get <span class=\"token function\">pv</span>\n</code></pre>\n<p><img src=\"/medias/loading.gif\" data-original=\"/images/k8s/nfs/16373020145856.jpg\" alt=\"pv\"></p>\n<p>STATUS 为 Available，表示 mypv1 就绪，可以被 PVC 申请。</p>\n<h4 id=\"创建-PVC\"><a href=\"#创建-PVC\" class=\"headerlink\" title=\"创建 PVC\"></a>创建 PVC</h4><p>(1）接下来创建 PVC mypvc1，配置文件 nfs-pvc1.yml 如下：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> PersistentVolumeClaim\n<span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypvc1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">accessModes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> ReadWriteOnce\n  <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">requests</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> 1Gi\n  <span class=\"token key atrule\">storageClassName</span><span class=\"token punctuation\">:</span> nfs\n</code></pre>\n<p>PVC 就很简单了，只需要指定 PV 的容量，访问模式和 class。</p>\n<p>（2）创建 mypvc1：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl apply -f nfs-pvc1.yml</span>\npersistentvolumeclaim/mypvc1 created\n<span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pvc</span>\nNAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE\nmypvc1   Bound    mypv1    1Gi        RWO            nfs            11s\n</code></pre>\n<p>从 kubectl get pvc 和 kubectl get pv 的输出可以看到 mypvc1 已经 Bound 到 mypv1，申请成功。</p>\n<h3 id=\"2-Pod使用pvc\"><a href=\"#2-Pod使用pvc\" class=\"headerlink\" title=\"2 Pod使用pvc\"></a>2 Pod使用pvc</h3><p>（1）接下来就可以在 Pod 中使用存储了，Pod 配置文件 pod1.yml 如下：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Pod\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypod1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypod1\n      <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> busybox\n      <span class=\"token key atrule\">args</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> /bin/sh\n      <span class=\"token punctuation\">-</span> <span class=\"token punctuation\">-</span>c\n      <span class=\"token punctuation\">-</span> sleep 30000\n      <span class=\"token key atrule\">volumeMounts</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">mountPath</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"mydata\"</span>\n        <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mydata\n  <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mydata\n      <span class=\"token key atrule\">persistentVolumeClaim</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">claimName</span><span class=\"token punctuation\">:</span> mypvc1\n</code></pre>\n<p>与使用普通 Volume 的格式类似，在 volumes 中过 persistentVolumeClaim 指定使用 mypvc1 申请的 Volume。</p>\n<p>（2）创建 mypod1：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pod<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl apply -f pod1.yaml</span>\npod/mypod1 created\n<span class=\"token punctuation\">[</span>root@k8s-master pod<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pod -o wide</span>\nNAME                     READY   STATUS              RESTARTS   AGE     IP              NODE        NOMINATED NODE   READINESS GATES\nmypod1                   0/1     ContainerCreating   0          20s     <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>          k8s-node4   <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>           <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>\nnginx-58dcb77688-h8c5x   1/1     Running             0          3d23h   172.31.156.68   k8s-node1   <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>           <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>\n</code></pre>\n<p>（3）验证 PV 是否可用：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">kubectl <span class=\"token function\">exec</span> mypod1 <span class=\"token function\">touch</span> /mydata/hello\n</code></pre>\n<p>查看生成文件</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@rediscom ~<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># cd /data/NFS/k8s/pv1/</span>\n<span class=\"token punctuation\">[</span>root@rediscom pv1<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># ls</span>\nhello\n</code></pre>\n<p>可见，在 Pod 中创建的文件 /mydata/hello 确实已经保存到了 NFS 服务器目录 /nfsdata/pv1 中。</p>\n<p>如果不再需要使用 PV，可用删除 PVC 回收 PV。</p>\n<h3 id=\"3-回收-PV\"><a href=\"#3-回收-PV\" class=\"headerlink\" title=\"3. 回收 PV\"></a>3. 回收 PV</h3><p>通过pvc回收pv<br>（1）当 PV 不再需要时，可通过删除 PVC 回收。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pvc</span>\nNAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE\nmypvc1   Bound    mypv1    1Gi        RWO            nfs            22m\n<span class=\"token comment\" spellcheck=\"true\"># 删除pvc</span>\n<span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl delete pvc mypvc1</span>\npersistentvolumeclaim <span class=\"token string\">\"mypvc1\"</span> deleted\n</code></pre>\n<p>当 PVC mypvc1 被删除后，发现 Kubernetes 启动了一个新 Pod，这个 Pod 的作用就是清除 PV mypv1 的数据。这个时候再看 NFS 服务器目录 /data/NFS/k8s/pv1/ 中已经没有数据了</p>\n<p><img src=\"/medias/loading.gif\" data-original=\"/images/k8s/nfs/16373060619523.jpg\" alt=\"data1\"></p>\n<p><strong>注意:</strong> 删除 mypvc1 时之前要停止与它相关的 pod ，不然 mypvc1一直处于 Terminating 状态</p>\n<p>（2）当数据清除完毕，mypv1 的状态重新变为 Available，此时则可以被新的 PVC 申请。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pv</span>\nNAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE\nmypv1   1Gi        RWO            Recycle          Available           nfs                     67m\n</code></pre>\n<p>（3）因为 PV 的回收策略设置为 Recycle，所以数据会被清除，但这可能不是我们想要的结果。如果我们希望保留数据，可以将策略设置为 Retain。</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> PersistentVolume\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypv1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">capacity</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> 1Gi\n  <span class=\"token key atrule\">accessModes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> ReadWriteOnce\n  <span class=\"token key atrule\">persistentVolumeReclaimPolicy</span><span class=\"token punctuation\">:</span> Retain\n  <span class=\"token key atrule\">storageClassName</span><span class=\"token punctuation\">:</span> nfs\n  <span class=\"token key atrule\">nfs</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">path</span><span class=\"token punctuation\">:</span> /data/NFS/k8s/pv1\n    <span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span> 192.168.11.101\n</code></pre>\n<p>（4）通过 kubectl apply 更新 PV：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pv<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl apply -f nfs-pv1.yaml</span>\npersistentvolume/mypv1 configured\n<span class=\"token punctuation\">[</span>root@k8s-master pv<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pv</span>\nNAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE\nmypv1   1Gi        RWO            Retain           Available           nfs                     81m\n<span class=\"token punctuation\">[</span>root@k8s-master pv<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\">#</span>\n</code></pre>\n<p>（5）回收策略已经变为 Retain，通过下面步骤验证其效果：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl exec mypod1 touch /mydata/hello</span>\nkubectl exec <span class=\"token punctuation\">[</span>POD<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> is DEPRECATED and will be removed in a future version. Use kubectl exec <span class=\"token punctuation\">[</span>POD<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span> <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> instead.\n<span class=\"token key atrule\">error</span><span class=\"token punctuation\">:</span> unable to upgrade connection<span class=\"token punctuation\">:</span> container not found (\"mypod1\")\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pod</span>\nNAME                     READY   STATUS    RESTARTS   AGE\nmypod1                   1/1     Running   0          27s\nnginx<span class=\"token punctuation\">-</span>58dcb77688<span class=\"token punctuation\">-</span>h8c5x   1/1     Running   0          4d\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl exec mypod1 touch /mydata/hello</span>\nkubectl exec <span class=\"token punctuation\">[</span>POD<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> is DEPRECATED and will be removed in a future version. Use kubectl exec <span class=\"token punctuation\">[</span>POD<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span> <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> instead.\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl delete -f ../pod/pod1.yaml</span>\npod \"mypod1\" deleted\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pvc</span>\nNAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE\nmypvc1   Bound    mypv1    1Gi        RWO            nfs            3m48s\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl delete pvc mypvc1</span>\npersistentvolumeclaim \"mypvc1\" deleted\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pvc</span>\nNo resources found in default namespace.\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\">#</span>\n</code></pre>\n<p>（6）我们再看 NFS 服务器目录 /nfsdata/pv1 中数据还保留。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@rediscom pv1<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># ls</span>\nhello\n<span class=\"token punctuation\">[</span>root@rediscom pv1<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\">#</span>\n</code></pre>\n<p>（7）虽然 mypv1 中的数据得到了保留，但其 PV 状态会一直处于 Released，不能被其他 PVC 申请。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pv</span>\nNAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS     CLAIM            STORAGECLASS   REASON   AGE\nmypv1   1Gi        RWO            Retain           Released   default/mypvc1   nfs                     89m\n</code></pre>\n<p>8）为了重新使用存储资源，可以删除并重新创建 mypv1。删除操作只是删除了 PV 对象，存储空间中的数据并不会被删除。</p>\n<p>新建的 mypv1 状态为 Available，已经可以被 PVC 申请。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl delete pv mypv1</span>\n<span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># ubectl apply -f nfs-pv1.yaml</span>\n<span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pv</span>\nNAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE\nmypv1   1Gi        RWO            Retain           Available           nfs                     2s\n<span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\">#</span>\n</code></pre>\n<p>PV 还支持 Delete 的回收策略，会删除 PV 在 Storage Provider 上对应存储空间。NFS 的 PV 不支持 Delete，支持 Delete 的 Provider 有 AWS EBS、GCE PD、Azure Disk、OpenStack Cinder Volume 等</p>\n<h3 id=\"4-PV的动态供给\"><a href=\"#4-PV的动态供给\" class=\"headerlink\" title=\"4.  PV的动态供给\"></a>4.  PV的动态供给</h3><p>pv的供给方式</p>\n<p>前面的例子中，我们提前创建了 PV，然后通过 PVC 申请 PV 并在 Pod 中使用，这种方式叫做静态供给（Static Provision）。</p>\n<p>与之对应的是动态供给（Dynamical Provision），即如果没有满足 PVC 条件的 PV，会动态创建 PV。相比静态供给，动态供给有明显的优势：不需要提前创建 PV，减少了管理员的工作量，效率高。</p>\n<p>动态供给是通过 StorageClass 实现的，StorageClass 定义了如何创建 PV</p>\n<p>pv动态供给举例<br>StorageClass standard：</p>\n<p><img src=\"/medias/loading.gif\" data-original=\"/images/k8s/nfs/16373075330215.jpg\" alt=\"standard\"></p>\n<p>StorageClass slow：</p>\n<p><img src=\"/medias/loading.gif\" data-original=\"/images/k8s/nfs/16373075453270.jpg\" alt=\"slow\"></p>\n<p>这两个 StorageClass 都会动态创建 AWS EBS，不同在于 standard 创建的是 gp2 类型的 EBS，而 slow 创建的是 io1 类型的 EBS。不同类型的 EBS 支持的参数可参考 AWS 官方文档。</p>\n<p>StorageClass 支持 Delete 和 Retain 两种 reclaimPolicy，默认是 Delete。</p>\n<p>与之前一样，PVC 在申请 PV 时，只需要指定 StorageClass 和容量以及访问模式，比如：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> PersistentVolumeClaim\n<span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypvc1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n <span class=\"token key atrule\">accessModes</span><span class=\"token punctuation\">:</span>\n   <span class=\"token punctuation\">-</span> ReadWriteOnce\n <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n   <span class=\"token key atrule\">requests</span><span class=\"token punctuation\">:</span>\n     <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> 1Gi\n <span class=\"token key atrule\">storageClassName</span><span class=\"token punctuation\">:</span> standard\n</code></pre>\n<p>除了 AWS EBS，Kubernetes 支持其他多种动态供给 PV 的 Provisioner，完整列表请参考 <a href=\"https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner\">https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner</a></p>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "k8s",
                "k8s",
                "nfs",
                "storage"
            ]
        },
        {
            "id": "https://costalong.com/2023/09/13/traefik/treafik-introduce/",
            "url": "https://costalong.com/2023/09/13/traefik/treafik-introduce/",
            "title": "traefik 简介",
            "date_published": "2023-09-13T03:18:12.000Z",
            "content_html": "<h3 id=\"1-官方文档\"><a href=\"#1-官方文档\" class=\"headerlink\" title=\"1. 官方文档\"></a>1. 官方文档</h3><p><a href=\"https://doc.traefik.io/traefik/\">https://doc.traefik.io/traefik/</a></p>\n<h3 id=\"2-简介\"><a href=\"#2-简介\" class=\"headerlink\" title=\"2. 简介\"></a>2. 简介</h3><p>traefik是一个使你把微服务暴露出来变的更容易的http反向代理和负载均衡软件。traefik支持K8S、docker swarm、mesos、consul、etcd、zookeeper等基础设施组件，动态的应用它的配置文件设置。</p>\n<h3 id=\"3-流量示意图\"><a href=\"#3-流量示意图\" class=\"headerlink\" title=\"3. 流量示意图\"></a>3. 流量示意图</h3><p><img src=\"/medias/loading.gif\" data-original=\"http://file.longqiuhong.com/uploads/picgo/treafik-flow.png\" alt=\"treafik-flow\"></p>\n<p>代理入口</p>\n<p><img src=\"/medias/loading.gif\" data-original=\"https://file.longqiuhong.com/uploads/picgo/route-flow.png\" alt=\"route-flow\"></p>\n<p>路由：</p>\n<p><img src=\"/medias/loading.gif\" data-original=\"http://file.longqiuhong.com/uploads/picgo/routers.png\" alt=\"routers\"></p>\n<h3 id=\"4-核心概念\"><a href=\"#4-核心概念\" class=\"headerlink\" title=\"4. 核心概念\"></a>4. 核心概念</h3><p>当启动Traefik时，需要定义<code>entrypoints</code>，然后通过entrypoints的路由来分析传入的请求，来查看他们是否是一组规则匹配，如果匹配，则路由可能将请求通过一系列的转换过来在发送到服务上去。</p>\n<p><img src=\"/medias/loading.gif\" data-original=\"https://file.longqiuhong.com/uploads/picgo/agence.png\" alt=\"agence\"></p>\n<ul>\n<li><code>Providers</code> 是基础组件，traefik的配置发现是通过它来实现，它可以是协调器，容器引擎，云提供商或键值存储，通过查询 Providers 的API来查询路由的相关信息，一旦检查变化，就会动态更新路由</li>\n<li><code>Entrypoints</code>监听传入的流量，是网络的入口点，定义了接受请求的端口(HTTP或者TCP)</li>\n<li><code>Routers</code>分析请求(host,path,headers,SSL等)，负责将传入的请求连接到可以处理这些请求的服务上去</li>\n<li><code>Service</code>将请求转发给应用，负责配置如何最终将处理传入请求的实际服务</li>\n<li><code>Middlewares</code>中间件，用来修改请求或者根据请求来做出判断，中间件被附件到路由上，是一种在请求发送到服务之前调整请求的一种方法</li>\n</ul>\n<h3 id=\"5-路由规则\"><a href=\"#5-路由规则\" class=\"headerlink\" title=\"5. 路由规则\"></a>5. 路由规则</h3><p>路由类型分为三种，分别为：<code>http</code>、<code>tcp</code>、<code>udp</code></p>\n<p>路由规则是指，Traefik接收到的请求，根据给定规则路由到不同的服务中。</p>\n<table>\n<thead>\n<tr>\n<th>Rule</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Headers(<code>key</code>, <code>value</code>)</td>\n<td>Check if there is a key keydefined in the headers, with the value value</td>\n</tr>\n<tr>\n<td>HeadersRegexp(<code>key</code>, <code>regexp</code>)</td>\n<td>Check if there is a key keydefined in the headers, with a value that matches the regular expression regexp</td>\n</tr>\n<tr>\n<td>Host(<code>example.com</code>, …)</td>\n<td>Check if the request domain (host header value) targets one of the given domains.</td>\n</tr>\n<tr>\n<td>HostHeader(<code>example.com</code>, …)</td>\n<td>Check if the request domain (host header value) targets one of the given domains.</td>\n</tr>\n<tr>\n<td>HostRegexp(<code>example.com</code>, <code>{subdomain:[a-z]+}.example.com</code>, …)</td>\n<td>Check if the request domain matches the given regexp.</td>\n</tr>\n<tr>\n<td>Method(<code>GET</code>, …)</td>\n<td>Check if the request method is one of the given methods (GET, POST, PUT, DELETE, PATCH, HEAD)</td>\n</tr>\n<tr>\n<td>Path(<code>/path</code>, <code>/articles/{cat:[a-z]+}/{id:[0-9]+}</code>, …)</td>\n<td>Match exact request path. It accepts a sequence of literal and regular expression paths.</td>\n</tr>\n<tr>\n<td>PathPrefix(<code>/products/</code>, <code>/articles/{cat:[a-z]+}/{id:[0-9]+}</code>)</td>\n<td>Match request prefix path. It accepts a sequence of literal and regular expression prefix paths.</td>\n</tr>\n<tr>\n<td>Query(<code>foo=bar</code>, <code>bar=baz</code>)</td>\n<td>Match Query String parameters. It accepts a sequence of key=value pairs.</td>\n</tr>\n<tr>\n<td>ClientIP(<code>10.0.0.0/16</code>, <code>::1</code>)</td>\n<td>Match if the request client IP is one of the given IP/CIDR. It accepts IPv4, IPv6 and CIDR formats</td>\n</tr>\n</tbody></table>\n<p>这个正则配起来稍微有点小坑</p>\n<p>为了对<code>Host</code>和<code>Path</code>使用正则表达式，需要声明一个任意命名的变量，然后跟上用冒号分隔的正则表达式，所有这些都用花括号括起来。</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\">HostRegexp(`grafana.<span class=\"token punctuation\">{</span>domain<span class=\"token punctuation\">:</span>.*<span class=\"token punctuation\">}</span>`)\n</code></pre>\n<h3 id=\"6-服务\"><a href=\"#6-服务\" class=\"headerlink\" title=\"6. 服务\"></a>6. 服务</h3><p><img src=\"/medias/loading.gif\" data-original=\"https://file.longqiuhong.com/uploads/picgo/services.png\" alt=\"services\"></p>\n<p>服务负责配置如何到达实际的服务，最终将处理传入的请求。使用<code>service</code>定义：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">http</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">traefik</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">loadBalancer</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">servers</span><span class=\"token punctuation\">:</span>\n          <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">url</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"http://127.0.0.1:10000\"</span>\n</code></pre>\n<p>​\t更多配置，可以参考：<a href=\"https://doc.traefik.io/traefik/routing/services/\">官网介绍</a></p>\n<h3 id=\"7-中间件\"><a href=\"#7-中间件\" class=\"headerlink\" title=\"7. 中间件\"></a>7. 中间件</h3><p><img src=\"/medias/loading.gif\" data-original=\"http://file.longqiuhong.com/uploads/picgo/middleware.png\" alt=\"middleware\"></p>\n<p>从图中基本可以明白中间件的作用，也可以理解成拦截器。<br>Traefik中有几种可用的中间件：一些可以修改请求、请求头，一些负责重定向，一些可以添加身份验证等等。</p>\n<p>下面是一个官网给出的示例：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\" spellcheck=\"true\"># As YAML Configuration File</span>\n<span class=\"token key atrule\">http</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">routers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">router1</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">service</span><span class=\"token punctuation\">:</span> myService\n      <span class=\"token key atrule\">middlewares</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token string\">\"foo-add-prefix\"</span>\n      <span class=\"token key atrule\">rule</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"Host(`example.com`)\"</span>\n\n  <span class=\"token key atrule\">middlewares</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">foo-add-prefix</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">addPrefix</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">prefix</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"/foo\"</span>\n\n  <span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">service1</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">loadBalancer</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">servers</span><span class=\"token punctuation\">:</span>\n          <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">url</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"http://127.0.0.1:80\"</span>\n</code></pre>\n<h3 id=\"参考连接\"><a href=\"#参考连接\" class=\"headerlink\" title=\"参考连接\"></a>参考连接</h3><ul>\n<li><a href=\"https://github.com/traefik/traefik\">Traefik源码仓库</a></li>\n<li><a href=\"https://traefik.io/\">Traefik官网</a></li>\n<li><a href=\"https://doc.traefik.io/traefik/reference/static-configuration/file/\">Traefik静态配置项-File provider</a></li>\n<li><a href=\"https://letsencrypt.org/\">Let’s Encrypt</a></li>\n<li><a href=\"https://www.freedesktop.org/software/systemd/man/systemd.unit.html\">Systemd文档</a></li>\n<li><a href=\"https://ormissia.github.io/posts/deployment/3003-linux-traefik/\">ormissia blog</a></li>\n</ul>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "traefik",
                "k8s",
                "traefik"
            ]
        },
        {
            "id": "https://costalong.com/2023/09/09/k8s/initcontainers-mo-shi/",
            "url": "https://costalong.com/2023/09/09/k8s/initcontainers-mo-shi/",
            "title": "InitContainers模式",
            "date_published": "2023-09-09T15:05:13.000Z",
            "content_html": "<h1 id=\"initContainer使用\"><a href=\"#initContainer使用\" class=\"headerlink\" title=\"initContainer使用\"></a>initContainer使用</h1><h2 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h2><p>init容器是在同一个Pod中的其他容器之前启动和执行的容器。它的目的是<strong>为Pod上托管的主应用程序执行初始化逻辑</strong>。例如，创建必要的用户帐户、执行数据库迁移、创建数据库模式等等。</p>\n<h2 id=\"Init-Containers-注意事项\"><a href=\"#Init-Containers-注意事项\" class=\"headerlink\" title=\"Init Containers 注意事项\"></a>Init Containers 注意事项</h2><p>在创建 init 容器时，应该考虑一些注意事项：</p>\n<ol>\n<li><p>它们总是在 Pod 中的其他容器之前执行。因此，它们不应包含需要很长时间才能完成的复杂逻辑。启动脚本通常小而简洁。如果您发现向 init 容器添加了太多逻辑，则应考虑将其中的一部分移至应用程序容器本身。</p>\n</li>\n<li><p>init 容器按顺序启动和执行。除非成功完成其前任容器，否则不会调用 init 容器。因此，如果启动任务很长，您可以考虑将其分解为多个步骤，每个步骤由一个 init 容器处理，以便您知道哪些步骤失败。</p>\n</li>\n<li><p>如果任何 init 容器失败，整个 Pod 将重新启动（除非您将 restartPolicy 设置为 Never）。重新启动 Pod 意味着再次重新执行所有容器，包括任何 init 容器。因此，您可能需要确保启动逻辑可以容忍多次执行而不会导致重复。例如，如果数据库迁移已经完成，再次执行迁移命令应该被忽略。</p>\n</li>\n<li><p>init 容器是延迟应用程序初始化直到一个或多个依赖项可用的良好候选者。例如，如果您的应用程序依赖于强加 API 请求速率限制的 API，您可能需要等待特定时间段才能接收来自该 API 的响应。在应用程序容器中实现这个逻辑可能很复杂；因为它需要与健康和准备探测器相结合。一个更简单的方法是创建一个 init 容器，它会等待 API 准备就绪后再成功退出。只有在 init 容器成功完成其工作后，应用程序容器才会启动。</p>\n</li>\n<li><p>Init 容器不能像应用程序容器那样使用健康和就绪探测。原因是它们旨在成功启动和退出，就像 Jobs 和 CronJobs 的行为方式一样。</p>\n</li>\n<li><p>同一个 Pod 上的所有容器共享相同的 Volumes 和网络。您可以利用此功能在应用程序及其初始化容器之间共享数据。</p>\n</li>\n</ol>\n<h2 id=\"Init容器“Request”和“Limits”行为\"><a href=\"#Init容器“Request”和“Limits”行为\" class=\"headerlink\" title=\"Init容器“Request”和“Limits”行为\"></a>Init容器“Request”和“Limits”行为</h2><p>init 容器总是在同一个 Pod 上的其他应用程序容器之前启动。因此，调度程序对 init 容器的资源和限制给予更高的优先级。必须彻底考虑此类行为，因为它可能会导致不希望的结果。例如，如果你有一个 init 容器和一个应用程序容器，并且你将 init 容器的资源和限制设置为高于应用程序容器的资源和限制，那么只有在有一个满足 init 的可用节点时，整个 Pod 才会被调度容器要求。换句话说，即使有一个未使用的节点可以运行应用程序容器，如果 init 容器具有该节点可以处理的更高资源先决条件，Pod 也不会部署到该节点。因此，在定义 init 容器的请求和限制时，您应该尽可能严格。作为最佳实践，除非绝对需要，否则不要将这些参数设置为高于应用程序容器的值</p>\n<h5 id=\"应用场景01：为数据库做种\"><a href=\"#应用场景01：为数据库做种\" class=\"headerlink\" title=\"应用场景01：为数据库做种\"></a>应用场景01：为数据库做种</h5><p>在这个场景中，我们为 MySQL 数据库提供服务。该数据库用于测试应用程序。它不必包含真实数据，但必须填充足够的数据，以便我们可以测试应用程序的查询速度。我们使用 init 容器来处理 SQL 转储文件的下载并将其恢复到托管在另一个容器中的数据库。</p>\n<p>定义文件可能如下所示：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Pod\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mydb\n  <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> db\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">initContainers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> fetch\n      <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mwendler/wget\n      <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"wget\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"--no-check-certificate\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"https://sample-videos.com/sql/Sample-SQL-File-1000rows.sql\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"-O\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"/docker-entrypoint-initdb.d/dump.sql\"</span><span class=\"token punctuation\">]</span>\n      <span class=\"token key atrule\">volumeMounts</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">mountPath</span><span class=\"token punctuation\">:</span> /docker<span class=\"token punctuation\">-</span>entrypoint<span class=\"token punctuation\">-</span>initdb.d\n          <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> dump\n  <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mysql\n      <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mysql\n      <span class=\"token key atrule\">env</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> MYSQL_ROOT_PASSWORD\n          <span class=\"token key atrule\">value</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"example\"</span>\n      <span class=\"token key atrule\">volumeMounts</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">mountPath</span><span class=\"token punctuation\">:</span> /docker<span class=\"token punctuation\">-</span>entrypoint<span class=\"token punctuation\">-</span>initdb.d\n          <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> dump\n  <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">emptyDir</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n      <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> dump\n</code></pre>\n<p>上面的定义创建了一个 Pod，它托管着两个容器：init 容器和应用程序容器。让我们来看看这个定义的有趣方面：</p>\n<ol>\n<li>init 容器负责下载包含数据库转储的 SQL 文件。我们使用 mwendler/wget 镜像，因为我们只需要 wget 命令。</li>\n<li>下载的 SQL 的目标目录是 MySQL 镜像用来执行 SQL 文件的目录（/docker-entrypoint-initdb.d）。此行为内置于我们在应用程序容器中使用的 MySQL 镜像中。</li>\n<li>init 容器将/docker-entrypoint-initdb.d挂载到emptyDir卷。因为两个容器都托管在同一个 Pod 上，所以它们共享相同的卷。因此，数据库容器可以访问放置在 emptyDir 卷上的 SQL 文件。</li>\n</ol>\n<h5 id=\"如果没有使用-InitContainers会发生什么？\"><a href=\"#如果没有使用-InitContainers会发生什么？\" class=\"headerlink\" title=\"如果没有使用 InitContainers会发生什么？\"></a>如果没有使用 InitContainers会发生什么？</h5><p>在这个例子中，我们使用初始化模式来建立关注点分离的最佳实践。如果我们在不使用 init 模式的情况下实现相同的逻辑，我们必须基于 mysql 基础镜像创建一个新镜像，安装 wget，并使用它来下载 SQL 文件。这种方法的缺点是：</p>\n<p>如果我们需要对下载逻辑进行任何更改，我们需要创建一个新镜像，推送它并更改其在定义文件中的引用。这增加了必须维护自定义镜像的负担。</p>\n<p>它在 DB 容器与其启动逻辑之间创建了紧密耦合的关系，这使得应用程序更难管理并增加了引入错误和错误的可能性。</p>\n<h2 id=\"场景-02：延迟应用程序启动，直到依赖项准备就绪\"><a href=\"#场景-02：延迟应用程序启动，直到依赖项准备就绪\" class=\"headerlink\" title=\"场景 02：延迟应用程序启动，直到依赖项准备就绪\"></a>场景 02：延迟应用程序启动，直到依赖项准备就绪</h2><p>init 容器的另一个常见用例是当您需要应用程序等待另一个服务完全运行（响应请求）时。以下定义演示了这种情况：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Pod\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> myapp<span class=\"token punctuation\">-</span>pod\n  <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> myapp\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">initContainers</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> init<span class=\"token punctuation\">-</span>myservice\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> busybox<span class=\"token punctuation\">:</span><span class=\"token number\">1.28</span>\n    <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'sh'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'-c'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'until nslookup myservice; do echo waiting for myservice; sleep 2; done;'</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> myapp<span class=\"token punctuation\">-</span>container\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> busybox<span class=\"token punctuation\">:</span><span class=\"token number\">1.28</span>\n    <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'sh'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'-c'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'echo The app is running! &amp;&amp; sleep 3600'</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<p>因此，假设我们的应用程序在 myapp-container 上运行时无法正常运行，除非 myservice 应用程序正在运行。我们需要延迟 myapp 启动，直到 myservice 准备就绪。为此，我们使用一个简单的 nslookup 命令（第 11 行）不断检查“myservice”的名称解析是否成功。如果 nslookup 能够解析“myservice”，则服务将启动。使用成功退出代码，init 容器终止，让应用程序容器启动。否则，容器在再次尝试之前会休眠两秒钟，从而延迟应用程序容器的启动。</p>\n<p>为了完整起见，这是 myservice 的定义文件：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Service\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> myservice\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">protocol</span><span class=\"token punctuation\">:</span> TCP\n    <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">80</span>\n    <span class=\"token key atrule\">targetPort</span><span class=\"token punctuation\">:</span> <span class=\"token number\">9376</span>\n</code></pre>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>初始化模式是设计需要启动逻辑的应用程序时要遵循的重要实践。</p>\n<p>Kubernetes 提供 init 容器作为将应用程序逻辑与其启动过程分离的一种手段。</p>\n<p>将应用程序初始化逻辑放在 init 容器中具有许多优点：</p>\n<ol>\n<li><p>您将强加关注点分离原则。一个应用程序可以有它的工程师团队，而它的初始化逻辑是由另一个团队编写的。</p>\n</li>\n<li><p>当涉及到授权和访问控制时，拥有一个单独的团队来处理应用程序的初始化步骤可以使公司更加灵活。例如，如果启动应用程序需要使用需要安全许可的资源（例如，修改防火墙规则），则可以由具有合适凭据的人员完成。应用团队不参与操作。</p>\n</li>\n<li><p>如果涉及的初始化步骤太多，可以将它们分解成多个 init 容器依次执行。如果一个步骤失败，init 容器会报告错误，这可以让您更好地了解逻辑的哪一部分不成功。</p>\n</li>\n</ol>\n<p>使用 init 容器时应考虑以下几点：</p>\n<ol>\n<li><p>初始化容器在失败时重新启动。因此，他们的代码必须是幂等的。</p>\n</li>\n<li><p>初始化容器是请求和限制首先由调度程序检查。不正确的值可能会对调度程序关于放置整个 Pod（包括应用程序容器）的位置的决定产生负面影响。</p>\n</li>\n</ol>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "k8s",
                "k8s"
            ]
        },
        {
            "id": "https://costalong.com/2023/09/03/k8s/csi-fen-xi-rong-qi-chu-cun-jie-kou/",
            "url": "https://costalong.com/2023/09/03/k8s/csi-fen-xi-rong-qi-chu-cun-jie-kou/",
            "title": "CSI--容器储存接口",
            "date_published": "2023-09-03T14:08:17.000Z",
            "content_html": "<h2 id=\"1-CSI简介–-储存接口\"><a href=\"#1-CSI简介–-储存接口\" class=\"headerlink\" title=\"1. CSI简介– 储存接口\"></a>1. CSI简介– 储存接口</h2><p>  k8s 的设计理念是支持可插拔架构，从而有利用扩展k8s 的功能。在次思想下，k8s 提供了 3 个特定功能得到接口，分别是：容器网络接口（CNI）、容器运行时接口（CRI）、容器储存接口（CSI）。本文主要介绍容器储存接口（CSI）。</p>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "k8s",
                "k8s"
            ]
        }
    ]
}