{
    "version": "https://jsonfeed.org/version/1",
    "title": "翼舞成梦",
    "subtitle": "翼舞成梦",
    "icon": "https://costalong.com/images/favicon.ico",
    "description": "",
    "home_page_url": "https://costalong.com",
    "items": [
        {
            "id": "https://costalong.com/2024/11/19/git/git-rollback/",
            "url": "https://costalong.com/2024/11/19/git/git-rollback/",
            "title": "git 回滚",
            "date_published": "2024-11-19T02:28:21.000Z",
            "content_html": "<p>在 Git 中，<code>revert</code>、<code>reset</code> 和 <code>rebase</code> 都是用来修改提交记录或状态的，但它们的使用场景和效果各不相同。</p>\n<hr>\n<h2 id=\"恢复提交：git-revert\"><a href=\"#恢复提交：git-revert\" class=\"headerlink\" title=\"恢复提交：git revert\"></a><strong>恢复提交：<code>git revert</code></strong></h2><p><code>git revert</code> 命令的实际结果类似于 <code>reset</code>，但它的方法不同。<code>reset</code> 是通过移动分支指针撤销更改，而 <code>revert</code> 是通过添加一个新的提交取消更改。</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a><strong>用法</strong></h3><pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> revert <span class=\"token operator\">&lt;</span>commit-id<span class=\"token operator\">></span>\n</code></pre>\n<p>例如，撤销最近一次提交：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> revert HEAD\n</code></pre>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a><strong>特点</strong></h3><ul>\n<li>安全，不会修改历史记录。</li>\n<li>适合用于团队协作和已推送到远程的分支。</li>\n</ul>\n<hr>\n<h2 id=\"回退提交：git-reset\"><a href=\"#回退提交：git-reset\" class=\"headerlink\" title=\"回退提交：git reset\"></a><strong>回退提交：<code>git reset</code></strong></h2><p><code>git reset</code> 用于改变分支指针，并决定是否保留工作区和暂存区的更改。</p>\n<h3 id=\"步骤-1：查看提交历史\"><a href=\"#步骤-1：查看提交历史\" class=\"headerlink\" title=\"步骤 1：查看提交历史\"></a><strong>步骤 1：查看提交历史</strong></h3><p>使用 <code>git log</code> 查询需要退回的提交 ID：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> log\n</code></pre>\n<h3 id=\"步骤-2：选择回退模式\"><a href=\"#步骤-2：选择回退模式\" class=\"headerlink\" title=\"步骤 2：选择回退模式\"></a><strong>步骤 2：选择回退模式</strong></h3><ol>\n<li><p><strong>软回退 (<code>--soft</code>)</strong><br>仅回退分支指针，保留暂存区和工作区的更改。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> reset --soft <span class=\"token operator\">&lt;</span>commit-id<span class=\"token operator\">></span>\n</code></pre>\n</li>\n<li><p><strong>混合回退 (<code>--mixed</code>)</strong><br>回退分支指针，清除暂存区，保留工作区的更改。（这是默认模式）</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> reset --mixed <span class=\"token operator\">&lt;</span>commit-id<span class=\"token operator\">></span>\n</code></pre>\n</li>\n<li><p><strong>硬回退 (<code>--hard</code>)</strong><br>回退分支指针，同时清除暂存区和工作区的所有更改。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> reset --hard <span class=\"token operator\">&lt;</span>commit-id<span class=\"token operator\">></span>\n</code></pre>\n</li>\n</ol>\n<h3 id=\"推送到远程\"><a href=\"#推送到远程\" class=\"headerlink\" title=\"推送到远程\"></a><strong>推送到远程</strong></h3><p>如果需要将本地的变更覆盖远程分支：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> push --force\n</code></pre>\n<hr>\n<h2 id=\"变基：git-rebase\"><a href=\"#变基：git-rebase\" class=\"headerlink\" title=\"变基：git rebase\"></a><strong>变基：<code>git rebase</code></strong></h2><p><code>git rebase</code> 用于重新整理提交历史，将当前分支的更改重新应用到另一个基础提交上。</p>\n<h3 id=\"场景：分支变基\"><a href=\"#场景：分支变基\" class=\"headerlink\" title=\"场景：分支变基\"></a><strong>场景：分支变基</strong></h3><p>假设有以下分支：</p>\n<ul>\n<li><strong>master</strong>: <code>C4 -&gt; C2 -&gt; C1 -&gt; C0</code></li>\n<li><strong>feature</strong>: <code>C5 -&gt; C3 -&gt; C2 -&gt; C1 -&gt; C0</code></li>\n</ul>\n<p>要将 <code>feature</code> 分支的提交重新基于 <code>master</code> 分支：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> checkout feature\n<span class=\"token function\">git</span> rebase master\n</code></pre>\n<p>变基后的结果：</p>\n<ul>\n<li><strong>master</strong>: <code>C4 -&gt; C2 -&gt; C1 -&gt; C0</code></li>\n<li><strong>feature</strong>: <code>C5' -&gt; C3' -&gt; C4 -&gt; C2 -&gt; C1 -&gt; C0</code></li>\n</ul>\n<h3 id=\"交互式变基\"><a href=\"#交互式变基\" class=\"headerlink\" title=\"交互式变基\"></a><strong>交互式变基</strong></h3><p>可以通过 <code>-i</code> 参数合并、修改或删除提交：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> rebase -i <span class=\"token operator\">&lt;</span>base-branch<span class=\"token operator\">></span>\n</code></pre>\n<p>编辑器中提供以下选项：</p>\n<ul>\n<li><code>pick</code>: 保留提交。</li>\n<li><code>squash</code>: 合并当前提交到上一个提交。</li>\n<li><code>edit</code>: 修改提交内容。</li>\n</ul>\n<hr>\n<h2 id=\"恢复历史：git-reflog\"><a href=\"#恢复历史：git-reflog\" class=\"headerlink\" title=\"恢复历史：git reflog\"></a><strong>恢复历史：<code>git reflog</code></strong></h2><p><code>git reflog</code> 用于查看分支操作历史。它记录了所有分支指针的变动，帮助找回丢失的提交。</p>\n<h3 id=\"用法-1\"><a href=\"#用法-1\" class=\"headerlink\" title=\"用法\"></a><strong>用法</strong></h3><pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> reflog\n</code></pre>\n<p>示例输出：</p>\n<pre class=\" language-plaintext\"><code class=\"language-plaintext\">e309ee8 (HEAD -> master) HEAD@{0}: pull: Fast-forward\n30c0e5e HEAD@{1}: commit: fix: 优化代码\n9429f03 HEAD@{2}: commit: fix: 优化代码\n1bdcafe HEAD@{3}: commit: fix: 修改配置\n</code></pre>\n<p>如果误操作（如 <code>git reset --hard</code>），可以通过 <code>git reflog</code> 找到目标提交并恢复：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> reset --hard <span class=\"token operator\">&lt;</span>commit-id<span class=\"token operator\">></span>\n</code></pre>\n<hr>\n<h2 id=\"对比总结\"><a href=\"#对比总结\" class=\"headerlink\" title=\"对比总结\"></a><strong>对比总结</strong></h2><table>\n<thead>\n<tr>\n<th>功能</th>\n<th><code>git revert</code></th>\n<th><code>git reset</code></th>\n<th><code>git rebase</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>作用</strong></td>\n<td>撤销提交，创建新提交</td>\n<td>改变提交历史</td>\n<td>重组提交历史</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td>安全，适合已推送分支</td>\n<td>高风险，慎用于远程分支</td>\n<td>高风险，慎用于远程分支</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>团队协作，回滚指定提交</td>\n<td>修改本地提交</td>\n<td>清理历史、线性合并</td>\n</tr>\n</tbody></table>\n<p>选择合适的工具，确保团队协作无缝进行！</p>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "Tool",
                "git"
            ]
        },
        {
            "id": "https://costalong.com/2024/11/19/git/git-commit/",
            "url": "https://costalong.com/2024/11/19/git/git-commit/",
            "title": "Git Commit",
            "date_published": "2024-11-19T02:28:21.000Z",
            "content_html": "<h2 id=\"Git-Commit-介绍\"><a href=\"#Git-Commit-介绍\" class=\"headerlink\" title=\"Git Commit 介绍\"></a><strong>Git Commit 介绍</strong></h2><p><code>git commit</code> 命令用于将工作区或暂存区的更改提交到版本库，形成可追踪的历史记录点。<br>它是 Git 工作流的核心操作，常用来保存代码的进展或完成阶段性开发。</p>\n<hr>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a><strong>基本用法</strong></h2><pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 将暂存区内容提交到版本库，进入编辑器填写提交信息</span>\n<span class=\"token function\">git</span> commit\n\n<span class=\"token comment\" spellcheck=\"true\"># 将特定文件提交到版本库（需已被跟踪）</span>\n<span class=\"token function\">git</span> commit <span class=\"token punctuation\">[</span>file1<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>file2<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 将暂存区内容提交到版本库，同时直接添加提交信息（无需打开编辑器）</span>\n<span class=\"token function\">git</span> commit -m <span class=\"token string\">\"&lt;message>\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 跳过 git add，将所有已跟踪文件的更改提交到版本库</span>\n<span class=\"token function\">git</span> commit -am <span class=\"token string\">\"&lt;message>\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 替代上一次提交：</span>\n<span class=\"token comment\" spellcheck=\"true\"># - 若代码无更改，用于修改提交信息</span>\n<span class=\"token comment\" spellcheck=\"true\"># - 若代码有更改，将其合并到上一次提交</span>\n<span class=\"token function\">git</span> commit --amend -m <span class=\"token string\">\"&lt;message>\"</span>\n</code></pre>\n<hr>\n<h2 id=\"常用选项\"><a href=\"#常用选项\" class=\"headerlink\" title=\"常用选项\"></a><strong>常用选项</strong></h2><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>-m &lt;message&gt;</code></td>\n<td>指定提交信息，避免打开编辑器</td>\n</tr>\n<tr>\n<td><code>-a</code></td>\n<td>提交所有已修改或删除的文件（限已被 Git 跟踪的文件）</td>\n</tr>\n<tr>\n<td><code>--amend</code></td>\n<td>修改最近一次提交（包括内容或提交信息）</td>\n</tr>\n<tr>\n<td><code>--no-edit</code></td>\n<td>不修改提交信息，直接沿用上次的提交消息</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"修改历史提交\"><a href=\"#修改历史提交\" class=\"headerlink\" title=\"修改历史提交\"></a><strong>修改历史提交</strong></h2><h3 id=\"修改最近一次提交\"><a href=\"#修改最近一次提交\" class=\"headerlink\" title=\"修改最近一次提交\"></a><strong>修改最近一次提交</strong></h3><p>如果需要修改最近一次提交的内容或提交信息：</p>\n<ol>\n<li>编辑文件，完成更改后添加到暂存区：<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> add <span class=\"token operator\">&lt;</span>file-name<span class=\"token operator\">></span>\n</code></pre>\n</li>\n<li>使用 <code>--amend</code> 更新提交：<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> commit --amend\n</code></pre>\n</li>\n</ol>\n<h3 id=\"修改更早的提交\"><a href=\"#修改更早的提交\" class=\"headerlink\" title=\"修改更早的提交\"></a><strong>修改更早的提交</strong></h3><p>通过交互式变基（<code>git rebase -i</code>）修改历史提交：</p>\n<ol>\n<li><p>启动交互式变基<br>例如，修改最近 3 次提交：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> rebase -i HEAD~3\n</code></pre>\n</li>\n<li><p>编辑器中显示提交历史：</p>\n<pre class=\" language-plaintext\"><code class=\"language-plaintext\">pick 1234567 feat: 添加新功能\npick 89abcde fix: 修复启动问题\npick def7890 docs: 更新文档\n</code></pre>\n</li>\n<li><p>将需要修改的提交改为 <code>edit</code>：</p>\n<pre class=\" language-plaintext\"><code class=\"language-plaintext\">pick 1234567 feat: 添加新功能\nedit 89abcde fix: 修复启动问题\npick def7890 docs: 更新文档\n</code></pre>\n</li>\n<li><p>保存并退出。</p>\n</li>\n<li><p>修改文件并更新提交：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> add <span class=\"token operator\">&lt;</span>file-name<span class=\"token operator\">></span>\n<span class=\"token function\">git</span> commit --amend\n</code></pre>\n</li>\n<li><p>完成修改后继续变基：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> rebase --continue\n</code></pre>\n</li>\n</ol>\n<hr>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a><strong>最佳实践</strong></h2><ol>\n<li><p><strong>编写清晰的提交信息</strong><br>遵循 <a href=\"https://www.conventionalcommits.org/\">Conventional Commits</a> 格式：</p>\n<pre class=\" language-plaintext\"><code class=\"language-plaintext\"><type>(<scope>): <subject>\n<空行>\n<body>\n<空行>\n<footer>\n</code></pre>\n<p><strong>示例：</strong></p>\n<pre class=\" language-plaintext\"><code class=\"language-plaintext\">feat(app): 添加用户登录功能\n\n实现用户登录和身份验证。解决了之前登录状态丢失的问题。\n\nCloses #123\n</code></pre>\n</li>\n<li><p><strong>保持提交单一职责</strong><br>每次提交只包含一种逻辑更改（例如，修复一个 bug 或实现一个功能），避免混合提交。</p>\n</li>\n<li><p><strong>修改已推送提交时的注意事项</strong></p>\n<ul>\n<li>若已推送到远程分支，需使用 <code>git push --force</code> 强制覆盖。</li>\n<li>与团队协作时应谨慎，确保其他人未基于该提交工作。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><ul>\n<li><strong><code>git commit</code> 是 Git 的核心命令</strong>，通过合适的参数选项可以更高效地管理提交。</li>\n<li>选择适合的用法（如 <code>--amend</code> 或 <code>rebase</code>）来优化历史提交，同时注意团队协作中的代码一致性。</li>\n</ul>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "Tool",
                "git"
            ]
        },
        {
            "id": "https://costalong.com/2024/07/11/git/no-sensitive/",
            "url": "https://costalong.com/2024/07/11/git/no-sensitive/",
            "title": "如何在 Git 提交中禁止包含敏感信息",
            "date_published": "2024-07-11T10:58:20.000Z",
            "content_html": "<p>为了防止在 Git 提交中包含敏感信息（如数据库密码），可以采取以下几种方法：</p>\n<h2 id=\"1-使用-gitignore\"><a href=\"#1-使用-gitignore\" class=\"headerlink\" title=\"1. 使用 .gitignore\"></a>1. 使用 .gitignore</h2><p>将包含敏感信息的文件添加到 <code>.gitignore</code> 文件中，这样 Git 就不会跟踪这些文件。例如，如果你的敏感信息存储在 <code>config.json</code> 文件中，你可以在 <code>.gitignore</code> 中添加：</p>\n<pre><code>config.json\n</code></pre>\n<h2 id=\"2-使用环境变量\"><a href=\"#2-使用环境变量\" class=\"headerlink\" title=\"2. 使用环境变量\"></a>2. 使用环境变量</h2><p>将敏感信息存储在环境变量中，而不是直接在代码中。例如，在代码中读取环境变量：</p>\n<pre class=\" language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> os\n\ndb_password <span class=\"token operator\">=</span> os<span class=\"token punctuation\">.</span>getenv<span class=\"token punctuation\">(</span><span class=\"token string\">'DB_PASSWORD'</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>在运行应用程序之前，设置环境变量：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">export DB_PASSWORD=\"your_database_password\"\n</code></pre>\n<h2 id=\"3-使用-Git-钩子（pre-commit-钩子）\"><a href=\"#3-使用-Git-钩子（pre-commit-钩子）\" class=\"headerlink\" title=\"3. 使用 Git 钩子（pre-commit 钩子）\"></a>3. 使用 Git 钩子（pre-commit 钩子）</h2><p>可以编写一个 Git pre-commit 钩子，在每次提交之前检查提交内容中是否包含敏感信息。如果包含，则拒绝提交。</p>\n<h3 id=\"方法1：手动编写-pre-commit-钩子\"><a href=\"#方法1：手动编写-pre-commit-钩子\" class=\"headerlink\" title=\"方法1：手动编写 pre-commit 钩子\"></a>方法1：手动编写 pre-commit 钩子</h3><p>首先，创建一个 pre-commit 钩子脚本：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">#!/bin/sh\n# 定义敏感信息模式\nSENSITIVE_PATTERNS=(\"your_database_password\" \"another_sensitive_pattern\")\n\n# 获取已暂存的文件\nSTAGED_FILES=$(git diff --cached --name-only)\n\nfor FILE in $STAGED_FILES; do\n  for PATTERN in \"${SENSITIVE_PATTERNS[@]}\"; do\n    if git grep -q \"$PATTERN\" \"$FILE\"; then\n      echo \"Error: Sensitive information found in $FILE\"\n      exit 1\n    fi\n  done\ndone\n\nexit 0\n</code></pre>\n<p>将这个脚本保存到 <code>.git/hooks/pre-commit</code> 文件中，并确保它具有可执行权限：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">chmod +x .git/hooks/pre-commit\n</code></pre>\n<h3 id=\"方法2：使用-pre-commit-工具-禁止已经提交的文件\"><a href=\"#方法2：使用-pre-commit-工具-禁止已经提交的文件\" class=\"headerlink\" title=\"方法2：使用 pre-commit 工具 禁止已经提交的文件\"></a>方法2：使用 pre-commit 工具 禁止已经提交的文件</h3><ol>\n<li>安装 pre-commit</li>\n</ol>\n<pre class=\" language-sh\"><code class=\"language-sh\">pip install pre-commit\n</code></pre>\n<p>或者</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">brew install pre-commit   # mac \napt install pre-commit    # linux\n</code></pre>\n<ol start=\"2\">\n<li>添加默认配置文件</li>\n</ol>\n<pre class=\" language-sh\"><code class=\"language-sh\">pre-commit sample-config > .pre-commit-config.yaml\n</code></pre>\n<p>在项目根目录下生成文件 <code>.pre-commit-config.yaml</code>，内容如下：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\" spellcheck=\"true\"># See https://pre-commit.com for more information</span>\n<span class=\"token comment\" spellcheck=\"true\"># See https://pre-commit.com/hooks.html for more hooks</span>\n<span class=\"token key atrule\">repos</span><span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">-</span>   <span class=\"token key atrule\">repo</span><span class=\"token punctuation\">:</span> https<span class=\"token punctuation\">:</span>//github.com/pre<span class=\"token punctuation\">-</span>commit/pre<span class=\"token punctuation\">-</span>commit<span class=\"token punctuation\">-</span>hooks\n    <span class=\"token key atrule\">rev</span><span class=\"token punctuation\">:</span> v3.2.0\n    <span class=\"token key atrule\">hooks</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span>   <span class=\"token key atrule\">id</span><span class=\"token punctuation\">:</span> trailing<span class=\"token punctuation\">-</span>whitespace\n    <span class=\"token punctuation\">-</span>   <span class=\"token key atrule\">id</span><span class=\"token punctuation\">:</span> end<span class=\"token punctuation\">-</span>of<span class=\"token punctuation\">-</span>file<span class=\"token punctuation\">-</span>fixer\n    <span class=\"token punctuation\">-</span>   <span class=\"token key atrule\">id</span><span class=\"token punctuation\">:</span> check<span class=\"token punctuation\">-</span>yaml\n    <span class=\"token punctuation\">-</span>   <span class=\"token key atrule\">id</span><span class=\"token punctuation\">:</span> check<span class=\"token punctuation\">-</span>added<span class=\"token punctuation\">-</span>large<span class=\"token punctuation\">-</span>files\n</code></pre>\n<ol start=\"3\">\n<li>配置 pre-commit 钩子：</li>\n</ol>\n<p>在 <code>.pre-commit-config.yaml</code> 文件中添加一个自定义钩子来检查指定文件是否被修改。例如，假设你想保护文件 <code>protected_file.txt</code>，可以这样配置：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">repos</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">repo</span><span class=\"token punctuation\">:</span> local\n    <span class=\"token key atrule\">hooks</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">id</span><span class=\"token punctuation\">:</span> protect<span class=\"token punctuation\">-</span>protected<span class=\"token punctuation\">-</span>file\n        <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Protect protected_file.txt\n        <span class=\"token key atrule\">entry</span><span class=\"token punctuation\">:</span> bash protect<span class=\"token punctuation\">-</span>protected<span class=\"token punctuation\">-</span>file.sh\n        <span class=\"token key atrule\">language</span><span class=\"token punctuation\">:</span> system\n        <span class=\"token key atrule\">stages</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>commit<span class=\"token punctuation\">]</span>\n</code></pre>\n<ol start=\"4\">\n<li>创建自定义钩子脚本</li>\n</ol>\n<pre class=\" language-sh\"><code class=\"language-sh\">#!/bin/sh\n\n# 要保护的文件列表\nPROTECTED_FILES=(\n    \"protected_file.txt\" \n)\n\n# 检查是否有文件被修改\nfor FILE in \"${PROTECTED_FILES[@]}\"; do\n  if git diff --cached --name-only | grep -q \"^$FILE$\"; then\n    echo \"Error: You are trying to modify $FILE, which is protected.\"\n    exit 1\n  fi\ndone\n\n# 允许提交\nexit 0\n</code></pre>\n<ol start=\"5\">\n<li>使脚本可执行：</li>\n</ol>\n<pre class=\" language-sh\"><code class=\"language-sh\">chmod +x protect-protected-file.sh\n</code></pre>\n<ol start=\"6\">\n<li>安装 pre-commit 钩子：</li>\n</ol>\n<pre class=\" language-sh\"><code class=\"language-sh\">pre-commit install\n</code></pre>\n<h2 id=\"4-使用工具（如-git-secrets）\"><a href=\"#4-使用工具（如-git-secrets）\" class=\"headerlink\" title=\"4. 使用工具（如 git-secrets）\"></a>4. 使用工具（如 git-secrets）</h2><p><code>git-secrets</code> 是一个专门用于防止在 Git 仓库中提交敏感信息的工具。它可以在提交之前扫描提交内容，并阻止包含敏感信息的提交。</p>\n<h3 id=\"安装-git-secrets\"><a href=\"#安装-git-secrets\" class=\"headerlink\" title=\"安装 git-secrets\"></a>安装 git-secrets</h3><h4 id=\"对于-macOS\"><a href=\"#对于-macOS\" class=\"headerlink\" title=\"对于 macOS\"></a>对于 macOS</h4><pre class=\" language-sh\"><code class=\"language-sh\">brew install git-secrets\n</code></pre>\n<h4 id=\"对于-Linux\"><a href=\"#对于-Linux\" class=\"headerlink\" title=\"对于 Linux\"></a>对于 Linux</h4><pre class=\" language-sh\"><code class=\"language-sh\">git clone https://github.com/awslabs/git-secrets.git\ncd git-secrets\nsudo make install\n</code></pre>\n<p>然后在你的 Git 仓库中初始化 git-secrets 并添加敏感信息模式：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">cd your-repo\ngit secrets --install\ngit secrets --add 'your_database_password'\ngit secrets --add 'another_sensitive_pattern'\n</code></pre>\n<p>这样，每次提交时，git-secrets 都会扫描提交内容并阻止包含敏感信息的提交。</p>\n<h2 id=\"5-使用-Secret-Scanning-服务\"><a href=\"#5-使用-Secret-Scanning-服务\" class=\"headerlink\" title=\"5. 使用 Secret Scanning 服务\"></a>5. 使用 Secret Scanning 服务</h2><p>一些代码托管平台（如 GitHub）提供了 Secret Scanning 服务，可以自动扫描仓库中的敏感信息，并在发现敏感信息时发出警告。</p>\n<p>通过以上方法，可以有效防止在 Git 提交中包含敏感信息，保护你的代码库安全。</p>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "Tool",
                "git"
            ]
        },
        {
            "id": "https://costalong.com/2023/01/28/git/git/",
            "url": "https://costalong.com/2023/01/28/git/git/",
            "title": "git 安装",
            "date_published": "2023-01-28T03:18:12.000Z",
            "content_html": "<p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p>\n<h2 id=\"Mac-install\"><a href=\"#Mac-install\" class=\"headerlink\" title=\"Mac install\"></a>Mac install</h2><pre class=\" language-bash\"><code class=\"language-bash\">brew <span class=\"token function\">install</span> <span class=\"token function\">git</span>\n</code></pre>\n<h2 id=\"Ubuntu-install\"><a href=\"#Ubuntu-install\" class=\"headerlink\" title=\"Ubuntu install\"></a>Ubuntu install</h2><pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> apt <span class=\"token function\">install</span> <span class=\"token function\">git</span>\n</code></pre>\n<h2 id=\"git-提交标准\"><a href=\"#git-提交标准\" class=\"headerlink\" title=\"git 提交标准\"></a>git 提交标准</h2><p><img src=\"/medias/loading.gif\" data-original=\"http://file.longqiuhong.com/uploads/picgo/16315958305196.jpg\" alt=\"git 提交标准\"></p>\n<h2 id=\"git-常用命令\"><a href=\"#git-常用命令\" class=\"headerlink\" title=\"git 常用命令\"></a>git 常用命令</h2><p><img src=\"/medias/loading.gif\" data-original=\"https://file.longqiuhong.com/uploads/picgo/04453ab5aed44227919c808b392b48d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"git 常用的命令\"></p>\n<p>查看代码版本：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git describe --always --tags --abbrev=0 --match 'v*' --exclude '*/*' | tr -d \"[\\r\\n]\"\n</code></pre>\n<p>删除tag</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git tag --delete  tag name  // v本地\ngit push origin :refs/tags/v1.0.0  // 删除远程 v1.0.0\n</code></pre>\n<p>修改tag 名称</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git tag new_tag old_tag\ngit tag -d old_tag\ngit push origin :refs/tags/old_tag\ngit push --tags\n</code></pre>\n<p>删除远程分支</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git push origin --delete <branchName>\n</code></pre>\n<p>强制切换到 commit_id 这个记录</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git reset --hard commit_id\n</code></pre>\n<p>强制提交到远程</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git push -f\n</code></pre>\n<p>删除本地的远程不存在的分支</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git remote prune origin\n</code></pre>\n<p><code>git commit</code>完之后，还没有执行<code>git push</code>，想修改/撤销这个<code>commit</code>，怎么办？<br>如果只是想修改注释，可以这样操作</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git commit --amend\n这个时候进入`vim`编辑，直接修改即可，修改完注释，退出`vim`编辑\n`:wq`保存已编辑的注释，重新`git push`即可\n</code></pre>\n<p>要撤回commit</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git reset --soft HEAD^\n这样就能成功的撤回你刚刚的`commit`操作。\nHEAD^的意思是上一个版本，也可以写成HEAD~1\n如果你进行了2次commit，想都撤回，可以使用HEAD~2\n</code></pre>\n<p><strong>注意，这个命令仅仅是撤回commit操作，写的代码仍然保留</strong></p>\n<p>恢复本地未提交内容</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git checkout .\n</code></pre>\n<pre class=\" language-sh\"><code class=\"language-sh\">git reset HEAD  *\n# 回退到上一个版本\ngit reset --hard HEAD^\n#回退到上上次版本\ngit reset --hard HEAD^^\ngit reset --hard HEAD^^^\n\n#回退到指定commitid的版本\ngit reset --hard  commit_id\n</code></pre>\n<p>恢复本地已提交内容</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git reset --hard\n</code></pre>\n<p>恢复远程未提交内容</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git fetch origin\ngit reset --hard origin/master\n</code></pre>\n<h2 id=\"git-常见的错误处理\"><a href=\"#git-常见的错误处理\" class=\"headerlink\" title=\"git 常见的错误处理\"></a>git 常见的错误处理</h2><p>1、fatal: Not possible to fast-forward, aborting.</p>\n<p>出现的原因：</p>\n<p>两个分之同时改了同样的地方，造成冲突。一般的情况使用 merge  合并分支</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git checkout master\ngit merge dev\n</code></pre>\n<p>如果出现代码冲突的时候需要手动解决，但是有时候是无法合并成功的。</p>\n<p>解决:</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git checkout master\ngit rebase dev\n</code></pre>\n<p>如果是一个分支，但是代码出现修改，也会出现改错误。</p>\n<p>解决:</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git pull origin master --rebase\n\ngit pull origin development --rebase\n\ngit pull origin test --rebase\n</code></pre>\n<p><strong>注意</strong> 修改冲突代码</p>\n<p>在提交代码</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">git push origin HEAD:develop     // develop 是分支\n</code></pre>\n<p>在冲突解决完毕并且提交代码后，执行下面的命令：</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">// 在终端也会有需要执行这个命令的提示\ngit rebase --continue\n</code></pre>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "Tool",
                "git"
            ]
        }
    ]
}