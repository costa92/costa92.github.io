{
    "version": "https://jsonfeed.org/version/1",
    "title": "翼舞成梦",
    "subtitle": "翼舞成梦",
    "icon": "https://costalong.com/images/favicon.ico",
    "description": "",
    "home_page_url": "https://costalong.com",
    "items": [
        {
            "id": "https://costalong.com/2023/09/13/k8s/k8s-install-nfs/",
            "url": "https://costalong.com/2023/09/13/k8s/k8s-install-nfs/",
            "title": "nfs实现k8s持久化",
            "date_published": "2023-09-13T10:37:51.000Z",
            "content_html": "<h3 id=\"1-部署nfs服务端\"><a href=\"#1-部署nfs服务端\" class=\"headerlink\" title=\"1. 部署nfs服务端\"></a>1. 部署nfs服务端</h3><p>在任意一台服务器上安装</p>\n<p>（1）安装nfs服务:</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">yum <span class=\"token function\">install</span> -y nfs-utils rpcbind\nvim /etc/exports\n/nfsdata *<span class=\"token punctuation\">(</span>rw,no_root_squash,no_all_squash,sync<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>（2）保存配置文件后，执行如下操作：<br>在服务端创建对应的目录和赋予权限：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"> <span class=\"token function\">mkdir</span> /nfsdata\n <span class=\"token function\">chmod</span> 777 /nfsdata\n</code></pre>\n<p>（3） 启动rpcbind和nfs服务：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">systemctl start rpcbind <span class=\"token operator\">&amp;&amp;</span> systemctl <span class=\"token function\">enable</span> rpcbind\nsystemctl start nfs <span class=\"token operator\">&amp;&amp;</span> systemctl <span class=\"token function\">enable</span> nfs\n</code></pre>\n<p>（4）每个node安装nfs工具</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"> yum <span class=\"token function\">install</span> -y nfs-utils \n</code></pre>\n<p>（5） 每个node查询NFS服务器</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">showmount -e nfs-ip\nshowmount -e 192.168.11.101\n</code></pre>\n<h4 id=\"NFS-PersistentVolume\"><a href=\"#NFS-PersistentVolume\" class=\"headerlink\" title=\"NFS PersistentVolume\"></a>NFS PersistentVolume</h4><p>（1）下面创建一个 PV mypv1，配置文件 nfs-pv1.yml 如下：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> PersistentVolume\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypv1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">capacity</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> 1Gi\n  <span class=\"token key atrule\">accessModes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> ReadWriteOnce\n  <span class=\"token key atrule\">persistentVolumeReclaimPolicy</span><span class=\"token punctuation\">:</span> Recycle\n  <span class=\"token key atrule\">storageClassName</span><span class=\"token punctuation\">:</span> nfs\n  <span class=\"token key atrule\">nfs</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">path</span><span class=\"token punctuation\">:</span> /data/NFS/k8s/pv1\n    <span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span> 192.168.11.101\n</code></pre>\n<p>① capacity 指定 PV 的容量为 1G。</p>\n<p>② accessModes 指定访问模式为 ReadWriteOnce，支持的访问模式有：</p>\n<p>ReadWriteOnce – PV 能以 read-write 模式 mount 到单个节点。</p>\n<p>ReadOnlyMany – PV 能以 read-only 模式 mount 到多个节点。</p>\n<p>ReadWriteMany – PV 能以 read-write 模式 mount 到多个节点。</p>\n<p>③ persistentVolumeReclaimPolicy 指定当 PV 的回收策略为 Recycle，支持的策略有：</p>\n<p>Retain – 需要管理员手工回收。</p>\n<p>Recycle – 清除 PV 中的数据，效果相当于执行 rm -rf /thevolume/*。</p>\n<p>Delete – 删除 Storage Provider 上的对应存储资源，例如 AWS EBS、GCE PD、Azure Disk、OpenStack Cinder Volume 等。</p>\n<p>④ storageClassName 指定 PV 的 class 为 nfs。相当于为 PV 设置了一个分类，PVC 可以指定 class 申请相应 class 的 PV。</p>\n<p>⑤ 指定 PV 在 NFS 服务器上对应的目录。</p>\n<p>注意要做storage-provider段要提前建好文件夹</p>\n<p>注意要做storage-provider段要提前建好文件夹</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>dev@rediscom k8s<span class=\"token punctuation\">]</span>$ <span class=\"token function\">ls</span>\npv1\n</code></pre>\n<p>（2）创建 mypv1：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">kubectl apply -f nfs-pv1.yaml\n</code></pre>\n<p>（3）查看 mypv1：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">kubectl get <span class=\"token function\">pv</span>\n</code></pre>\n<p><img src=\"/medias/loading.gif\" data-original=\"/images/k8s/nfs/16373020145856.jpg\" alt=\"pv\"></p>\n<p>STATUS 为 Available，表示 mypv1 就绪，可以被 PVC 申请。</p>\n<h4 id=\"创建-PVC\"><a href=\"#创建-PVC\" class=\"headerlink\" title=\"创建 PVC\"></a>创建 PVC</h4><p>(1）接下来创建 PVC mypvc1，配置文件 nfs-pvc1.yml 如下：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> PersistentVolumeClaim\n<span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypvc1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">accessModes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> ReadWriteOnce\n  <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">requests</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> 1Gi\n  <span class=\"token key atrule\">storageClassName</span><span class=\"token punctuation\">:</span> nfs\n</code></pre>\n<p>PVC 就很简单了，只需要指定 PV 的容量，访问模式和 class。</p>\n<p>（2）创建 mypvc1：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl apply -f nfs-pvc1.yml</span>\npersistentvolumeclaim/mypvc1 created\n<span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pvc</span>\nNAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE\nmypvc1   Bound    mypv1    1Gi        RWO            nfs            11s\n</code></pre>\n<p>从 kubectl get pvc 和 kubectl get pv 的输出可以看到 mypvc1 已经 Bound 到 mypv1，申请成功。</p>\n<h3 id=\"2-Pod使用pvc\"><a href=\"#2-Pod使用pvc\" class=\"headerlink\" title=\"2 Pod使用pvc\"></a>2 Pod使用pvc</h3><p>（1）接下来就可以在 Pod 中使用存储了，Pod 配置文件 pod1.yml 如下：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Pod\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypod1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypod1\n      <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> busybox\n      <span class=\"token key atrule\">args</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> /bin/sh\n      <span class=\"token punctuation\">-</span> <span class=\"token punctuation\">-</span>c\n      <span class=\"token punctuation\">-</span> sleep 30000\n      <span class=\"token key atrule\">volumeMounts</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">mountPath</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"mydata\"</span>\n        <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mydata\n  <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mydata\n      <span class=\"token key atrule\">persistentVolumeClaim</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">claimName</span><span class=\"token punctuation\">:</span> mypvc1\n</code></pre>\n<p>与使用普通 Volume 的格式类似，在 volumes 中过 persistentVolumeClaim 指定使用 mypvc1 申请的 Volume。</p>\n<p>（2）创建 mypod1：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pod<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl apply -f pod1.yaml</span>\npod/mypod1 created\n<span class=\"token punctuation\">[</span>root@k8s-master pod<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pod -o wide</span>\nNAME                     READY   STATUS              RESTARTS   AGE     IP              NODE        NOMINATED NODE   READINESS GATES\nmypod1                   0/1     ContainerCreating   0          20s     <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>          k8s-node4   <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>           <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>\nnginx-58dcb77688-h8c5x   1/1     Running             0          3d23h   172.31.156.68   k8s-node1   <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>           <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>\n</code></pre>\n<p>（3）验证 PV 是否可用：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">kubectl <span class=\"token function\">exec</span> mypod1 <span class=\"token function\">touch</span> /mydata/hello\n</code></pre>\n<p>查看生成文件</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@rediscom ~<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># cd /data/NFS/k8s/pv1/</span>\n<span class=\"token punctuation\">[</span>root@rediscom pv1<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># ls</span>\nhello\n</code></pre>\n<p>可见，在 Pod 中创建的文件 /mydata/hello 确实已经保存到了 NFS 服务器目录 /nfsdata/pv1 中。</p>\n<p>如果不再需要使用 PV，可用删除 PVC 回收 PV。</p>\n<h3 id=\"3-回收-PV\"><a href=\"#3-回收-PV\" class=\"headerlink\" title=\"3. 回收 PV\"></a>3. 回收 PV</h3><p>通过pvc回收pv<br>（1）当 PV 不再需要时，可通过删除 PVC 回收。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pvc</span>\nNAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE\nmypvc1   Bound    mypv1    1Gi        RWO            nfs            22m\n<span class=\"token comment\" spellcheck=\"true\"># 删除pvc</span>\n<span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl delete pvc mypvc1</span>\npersistentvolumeclaim <span class=\"token string\">\"mypvc1\"</span> deleted\n</code></pre>\n<p>当 PVC mypvc1 被删除后，发现 Kubernetes 启动了一个新 Pod，这个 Pod 的作用就是清除 PV mypv1 的数据。这个时候再看 NFS 服务器目录 /data/NFS/k8s/pv1/ 中已经没有数据了</p>\n<p><img src=\"/medias/loading.gif\" data-original=\"/images/k8s/nfs/16373060619523.jpg\" alt=\"data1\"></p>\n<p><strong>注意:</strong> 删除 mypvc1 时之前要停止与它相关的 pod ，不然 mypvc1一直处于 Terminating 状态</p>\n<p>（2）当数据清除完毕，mypv1 的状态重新变为 Available，此时则可以被新的 PVC 申请。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pv</span>\nNAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE\nmypv1   1Gi        RWO            Recycle          Available           nfs                     67m\n</code></pre>\n<p>（3）因为 PV 的回收策略设置为 Recycle，所以数据会被清除，但这可能不是我们想要的结果。如果我们希望保留数据，可以将策略设置为 Retain。</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> PersistentVolume\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypv1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">capacity</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> 1Gi\n  <span class=\"token key atrule\">accessModes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> ReadWriteOnce\n  <span class=\"token key atrule\">persistentVolumeReclaimPolicy</span><span class=\"token punctuation\">:</span> Retain\n  <span class=\"token key atrule\">storageClassName</span><span class=\"token punctuation\">:</span> nfs\n  <span class=\"token key atrule\">nfs</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">path</span><span class=\"token punctuation\">:</span> /data/NFS/k8s/pv1\n    <span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span> 192.168.11.101\n</code></pre>\n<p>（4）通过 kubectl apply 更新 PV：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pv<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl apply -f nfs-pv1.yaml</span>\npersistentvolume/mypv1 configured\n<span class=\"token punctuation\">[</span>root@k8s-master pv<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pv</span>\nNAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE\nmypv1   1Gi        RWO            Retain           Available           nfs                     81m\n<span class=\"token punctuation\">[</span>root@k8s-master pv<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\">#</span>\n</code></pre>\n<p>（5）回收策略已经变为 Retain，通过下面步骤验证其效果：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl exec mypod1 touch /mydata/hello</span>\nkubectl exec <span class=\"token punctuation\">[</span>POD<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> is DEPRECATED and will be removed in a future version. Use kubectl exec <span class=\"token punctuation\">[</span>POD<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span> <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> instead.\n<span class=\"token key atrule\">error</span><span class=\"token punctuation\">:</span> unable to upgrade connection<span class=\"token punctuation\">:</span> container not found (\"mypod1\")\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pod</span>\nNAME                     READY   STATUS    RESTARTS   AGE\nmypod1                   1/1     Running   0          27s\nnginx<span class=\"token punctuation\">-</span>58dcb77688<span class=\"token punctuation\">-</span>h8c5x   1/1     Running   0          4d\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl exec mypod1 touch /mydata/hello</span>\nkubectl exec <span class=\"token punctuation\">[</span>POD<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> is DEPRECATED and will be removed in a future version. Use kubectl exec <span class=\"token punctuation\">[</span>POD<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span> <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> instead.\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl delete -f ../pod/pod1.yaml</span>\npod \"mypod1\" deleted\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pvc</span>\nNAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE\nmypvc1   Bound    mypv1    1Gi        RWO            nfs            3m48s\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl delete pvc mypvc1</span>\npersistentvolumeclaim \"mypvc1\" deleted\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pvc</span>\nNo resources found in default namespace.\n<span class=\"token punctuation\">[</span>root@k8s<span class=\"token punctuation\">-</span>master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\">#</span>\n</code></pre>\n<p>（6）我们再看 NFS 服务器目录 /nfsdata/pv1 中数据还保留。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@rediscom pv1<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># ls</span>\nhello\n<span class=\"token punctuation\">[</span>root@rediscom pv1<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\">#</span>\n</code></pre>\n<p>（7）虽然 mypv1 中的数据得到了保留，但其 PV 状态会一直处于 Released，不能被其他 PVC 申请。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pv</span>\nNAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS     CLAIM            STORAGECLASS   REASON   AGE\nmypv1   1Gi        RWO            Retain           Released   default/mypvc1   nfs                     89m\n</code></pre>\n<p>8）为了重新使用存储资源，可以删除并重新创建 mypv1。删除操作只是删除了 PV 对象，存储空间中的数据并不会被删除。</p>\n<p>新建的 mypv1 状态为 Available，已经可以被 PVC 申请。</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl delete pv mypv1</span>\n<span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># ubectl apply -f nfs-pv1.yaml</span>\n<span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># kubectl get pv</span>\nNAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE\nmypv1   1Gi        RWO            Retain           Available           nfs                     2s\n<span class=\"token punctuation\">[</span>root@k8s-master pvc<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\">#</span>\n</code></pre>\n<p>PV 还支持 Delete 的回收策略，会删除 PV 在 Storage Provider 上对应存储空间。NFS 的 PV 不支持 Delete，支持 Delete 的 Provider 有 AWS EBS、GCE PD、Azure Disk、OpenStack Cinder Volume 等</p>\n<h3 id=\"4-PV的动态供给\"><a href=\"#4-PV的动态供给\" class=\"headerlink\" title=\"4.  PV的动态供给\"></a>4.  PV的动态供给</h3><p>pv的供给方式</p>\n<p>前面的例子中，我们提前创建了 PV，然后通过 PVC 申请 PV 并在 Pod 中使用，这种方式叫做静态供给（Static Provision）。</p>\n<p>与之对应的是动态供给（Dynamical Provision），即如果没有满足 PVC 条件的 PV，会动态创建 PV。相比静态供给，动态供给有明显的优势：不需要提前创建 PV，减少了管理员的工作量，效率高。</p>\n<p>动态供给是通过 StorageClass 实现的，StorageClass 定义了如何创建 PV</p>\n<p>pv动态供给举例<br>StorageClass standard：</p>\n<p><img src=\"/medias/loading.gif\" data-original=\"/images/k8s/nfs/16373075330215.jpg\" alt=\"standard\"></p>\n<p>StorageClass slow：</p>\n<p><img src=\"/medias/loading.gif\" data-original=\"/images/k8s/nfs/16373075453270.jpg\" alt=\"slow\"></p>\n<p>这两个 StorageClass 都会动态创建 AWS EBS，不同在于 standard 创建的是 gp2 类型的 EBS，而 slow 创建的是 io1 类型的 EBS。不同类型的 EBS 支持的参数可参考 AWS 官方文档。</p>\n<p>StorageClass 支持 Delete 和 Retain 两种 reclaimPolicy，默认是 Delete。</p>\n<p>与之前一样，PVC 在申请 PV 时，只需要指定 StorageClass 和容量以及访问模式，比如：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> PersistentVolumeClaim\n<span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mypvc1\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n <span class=\"token key atrule\">accessModes</span><span class=\"token punctuation\">:</span>\n   <span class=\"token punctuation\">-</span> ReadWriteOnce\n <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n   <span class=\"token key atrule\">requests</span><span class=\"token punctuation\">:</span>\n     <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> 1Gi\n <span class=\"token key atrule\">storageClassName</span><span class=\"token punctuation\">:</span> standard\n</code></pre>\n<p>除了 AWS EBS，Kubernetes 支持其他多种动态供给 PV 的 Provisioner，完整列表请参考 <a href=\"https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner\">https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner</a></p>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "k8s",
                "k8s",
                "nfs",
                "storage"
            ]
        },
        {
            "id": "https://costalong.com/2023/09/09/k8s/initcontainers-mo-shi/",
            "url": "https://costalong.com/2023/09/09/k8s/initcontainers-mo-shi/",
            "title": "InitContainers模式",
            "date_published": "2023-09-09T15:05:13.000Z",
            "content_html": "<h1 id=\"initContainer使用\"><a href=\"#initContainer使用\" class=\"headerlink\" title=\"initContainer使用\"></a>initContainer使用</h1><h2 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h2><p>init容器是在同一个Pod中的其他容器之前启动和执行的容器。它的目的是<strong>为Pod上托管的主应用程序执行初始化逻辑</strong>。例如，创建必要的用户帐户、执行数据库迁移、创建数据库模式等等。</p>\n<h2 id=\"Init-Containers-注意事项\"><a href=\"#Init-Containers-注意事项\" class=\"headerlink\" title=\"Init Containers 注意事项\"></a>Init Containers 注意事项</h2><p>在创建 init 容器时，应该考虑一些注意事项：</p>\n<ol>\n<li><p>它们总是在 Pod 中的其他容器之前执行。因此，它们不应包含需要很长时间才能完成的复杂逻辑。启动脚本通常小而简洁。如果您发现向 init 容器添加了太多逻辑，则应考虑将其中的一部分移至应用程序容器本身。</p>\n</li>\n<li><p>init 容器按顺序启动和执行。除非成功完成其前任容器，否则不会调用 init 容器。因此，如果启动任务很长，您可以考虑将其分解为多个步骤，每个步骤由一个 init 容器处理，以便您知道哪些步骤失败。</p>\n</li>\n<li><p>如果任何 init 容器失败，整个 Pod 将重新启动（除非您将 restartPolicy 设置为 Never）。重新启动 Pod 意味着再次重新执行所有容器，包括任何 init 容器。因此，您可能需要确保启动逻辑可以容忍多次执行而不会导致重复。例如，如果数据库迁移已经完成，再次执行迁移命令应该被忽略。</p>\n</li>\n<li><p>init 容器是延迟应用程序初始化直到一个或多个依赖项可用的良好候选者。例如，如果您的应用程序依赖于强加 API 请求速率限制的 API，您可能需要等待特定时间段才能接收来自该 API 的响应。在应用程序容器中实现这个逻辑可能很复杂；因为它需要与健康和准备探测器相结合。一个更简单的方法是创建一个 init 容器，它会等待 API 准备就绪后再成功退出。只有在 init 容器成功完成其工作后，应用程序容器才会启动。</p>\n</li>\n<li><p>Init 容器不能像应用程序容器那样使用健康和就绪探测。原因是它们旨在成功启动和退出，就像 Jobs 和 CronJobs 的行为方式一样。</p>\n</li>\n<li><p>同一个 Pod 上的所有容器共享相同的 Volumes 和网络。您可以利用此功能在应用程序及其初始化容器之间共享数据。</p>\n</li>\n</ol>\n<h2 id=\"Init容器“Request”和“Limits”行为\"><a href=\"#Init容器“Request”和“Limits”行为\" class=\"headerlink\" title=\"Init容器“Request”和“Limits”行为\"></a>Init容器“Request”和“Limits”行为</h2><p>init 容器总是在同一个 Pod 上的其他应用程序容器之前启动。因此，调度程序对 init 容器的资源和限制给予更高的优先级。必须彻底考虑此类行为，因为它可能会导致不希望的结果。例如，如果你有一个 init 容器和一个应用程序容器，并且你将 init 容器的资源和限制设置为高于应用程序容器的资源和限制，那么只有在有一个满足 init 的可用节点时，整个 Pod 才会被调度容器要求。换句话说，即使有一个未使用的节点可以运行应用程序容器，如果 init 容器具有该节点可以处理的更高资源先决条件，Pod 也不会部署到该节点。因此，在定义 init 容器的请求和限制时，您应该尽可能严格。作为最佳实践，除非绝对需要，否则不要将这些参数设置为高于应用程序容器的值</p>\n<h5 id=\"应用场景01：为数据库做种\"><a href=\"#应用场景01：为数据库做种\" class=\"headerlink\" title=\"应用场景01：为数据库做种\"></a>应用场景01：为数据库做种</h5><p>在这个场景中，我们为 MySQL 数据库提供服务。该数据库用于测试应用程序。它不必包含真实数据，但必须填充足够的数据，以便我们可以测试应用程序的查询速度。我们使用 init 容器来处理 SQL 转储文件的下载并将其恢复到托管在另一个容器中的数据库。</p>\n<p>定义文件可能如下所示：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Pod\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mydb\n  <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> db\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">initContainers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> fetch\n      <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mwendler/wget\n      <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"wget\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"--no-check-certificate\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"https://sample-videos.com/sql/Sample-SQL-File-1000rows.sql\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"-O\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"/docker-entrypoint-initdb.d/dump.sql\"</span><span class=\"token punctuation\">]</span>\n      <span class=\"token key atrule\">volumeMounts</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">mountPath</span><span class=\"token punctuation\">:</span> /docker<span class=\"token punctuation\">-</span>entrypoint<span class=\"token punctuation\">-</span>initdb.d\n          <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> dump\n  <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> mysql\n      <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mysql\n      <span class=\"token key atrule\">env</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> MYSQL_ROOT_PASSWORD\n          <span class=\"token key atrule\">value</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"example\"</span>\n      <span class=\"token key atrule\">volumeMounts</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">mountPath</span><span class=\"token punctuation\">:</span> /docker<span class=\"token punctuation\">-</span>entrypoint<span class=\"token punctuation\">-</span>initdb.d\n          <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> dump\n  <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">emptyDir</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n      <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> dump\n</code></pre>\n<p>上面的定义创建了一个 Pod，它托管着两个容器：init 容器和应用程序容器。让我们来看看这个定义的有趣方面：</p>\n<ol>\n<li>init 容器负责下载包含数据库转储的 SQL 文件。我们使用 mwendler/wget 镜像，因为我们只需要 wget 命令。</li>\n<li>下载的 SQL 的目标目录是 MySQL 镜像用来执行 SQL 文件的目录（/docker-entrypoint-initdb.d）。此行为内置于我们在应用程序容器中使用的 MySQL 镜像中。</li>\n<li>init 容器将/docker-entrypoint-initdb.d挂载到emptyDir卷。因为两个容器都托管在同一个 Pod 上，所以它们共享相同的卷。因此，数据库容器可以访问放置在 emptyDir 卷上的 SQL 文件。</li>\n</ol>\n<h5 id=\"如果没有使用-InitContainers会发生什么？\"><a href=\"#如果没有使用-InitContainers会发生什么？\" class=\"headerlink\" title=\"如果没有使用 InitContainers会发生什么？\"></a>如果没有使用 InitContainers会发生什么？</h5><p>在这个例子中，我们使用初始化模式来建立关注点分离的最佳实践。如果我们在不使用 init 模式的情况下实现相同的逻辑，我们必须基于 mysql 基础镜像创建一个新镜像，安装 wget，并使用它来下载 SQL 文件。这种方法的缺点是：</p>\n<p>如果我们需要对下载逻辑进行任何更改，我们需要创建一个新镜像，推送它并更改其在定义文件中的引用。这增加了必须维护自定义镜像的负担。</p>\n<p>它在 DB 容器与其启动逻辑之间创建了紧密耦合的关系，这使得应用程序更难管理并增加了引入错误和错误的可能性。</p>\n<h2 id=\"场景-02：延迟应用程序启动，直到依赖项准备就绪\"><a href=\"#场景-02：延迟应用程序启动，直到依赖项准备就绪\" class=\"headerlink\" title=\"场景 02：延迟应用程序启动，直到依赖项准备就绪\"></a>场景 02：延迟应用程序启动，直到依赖项准备就绪</h2><p>init 容器的另一个常见用例是当您需要应用程序等待另一个服务完全运行（响应请求）时。以下定义演示了这种情况：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Pod\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> myapp<span class=\"token punctuation\">-</span>pod\n  <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span> myapp\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">initContainers</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> init<span class=\"token punctuation\">-</span>myservice\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> busybox<span class=\"token punctuation\">:</span><span class=\"token number\">1.28</span>\n    <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'sh'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'-c'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'until nslookup myservice; do echo waiting for myservice; sleep 2; done;'</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> myapp<span class=\"token punctuation\">-</span>container\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> busybox<span class=\"token punctuation\">:</span><span class=\"token number\">1.28</span>\n    <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'sh'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'-c'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'echo The app is running! &amp;&amp; sleep 3600'</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<p>因此，假设我们的应用程序在 myapp-container 上运行时无法正常运行，除非 myservice 应用程序正在运行。我们需要延迟 myapp 启动，直到 myservice 准备就绪。为此，我们使用一个简单的 nslookup 命令（第 11 行）不断检查“myservice”的名称解析是否成功。如果 nslookup 能够解析“myservice”，则服务将启动。使用成功退出代码，init 容器终止，让应用程序容器启动。否则，容器在再次尝试之前会休眠两秒钟，从而延迟应用程序容器的启动。</p>\n<p>为了完整起见，这是 myservice 的定义文件：</p>\n<pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Service\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> myservice\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">protocol</span><span class=\"token punctuation\">:</span> TCP\n    <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">80</span>\n    <span class=\"token key atrule\">targetPort</span><span class=\"token punctuation\">:</span> <span class=\"token number\">9376</span>\n</code></pre>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>初始化模式是设计需要启动逻辑的应用程序时要遵循的重要实践。</p>\n<p>Kubernetes 提供 init 容器作为将应用程序逻辑与其启动过程分离的一种手段。</p>\n<p>将应用程序初始化逻辑放在 init 容器中具有许多优点：</p>\n<ol>\n<li><p>您将强加关注点分离原则。一个应用程序可以有它的工程师团队，而它的初始化逻辑是由另一个团队编写的。</p>\n</li>\n<li><p>当涉及到授权和访问控制时，拥有一个单独的团队来处理应用程序的初始化步骤可以使公司更加灵活。例如，如果启动应用程序需要使用需要安全许可的资源（例如，修改防火墙规则），则可以由具有合适凭据的人员完成。应用团队不参与操作。</p>\n</li>\n<li><p>如果涉及的初始化步骤太多，可以将它们分解成多个 init 容器依次执行。如果一个步骤失败，init 容器会报告错误，这可以让您更好地了解逻辑的哪一部分不成功。</p>\n</li>\n</ol>\n<p>使用 init 容器时应考虑以下几点：</p>\n<ol>\n<li><p>初始化容器在失败时重新启动。因此，他们的代码必须是幂等的。</p>\n</li>\n<li><p>初始化容器是请求和限制首先由调度程序检查。不正确的值可能会对调度程序关于放置整个 Pod（包括应用程序容器）的位置的决定产生负面影响。</p>\n</li>\n</ol>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "k8s",
                "k8s"
            ]
        },
        {
            "id": "https://costalong.com/2023/09/03/k8s/csi-fen-xi-rong-qi-chu-cun-jie-kou/",
            "url": "https://costalong.com/2023/09/03/k8s/csi-fen-xi-rong-qi-chu-cun-jie-kou/",
            "title": "CSI--容器储存接口",
            "date_published": "2023-09-03T14:08:17.000Z",
            "content_html": "<h2 id=\"1-CSI简介–-储存接口\"><a href=\"#1-CSI简介–-储存接口\" class=\"headerlink\" title=\"1. CSI简介– 储存接口\"></a>1. CSI简介– 储存接口</h2><p>  k8s 的设计理念是支持可插拔架构，从而有利用扩展k8s 的功能。在次思想下，k8s 提供了 3 个特定功能得到接口，分别是：容器网络接口（CNI）、容器运行时接口（CRI）、容器储存接口（CSI）。本文主要介绍容器储存接口（CSI）。</p>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "k8s",
                "k8s"
            ]
        }
    ]
}